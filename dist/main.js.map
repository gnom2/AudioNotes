{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/standardized-audio-context/build/es2019/globals.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/constants.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js","webpack:///./node_modules/tone/build/esm/version.js","webpack:///./node_modules/tone/build/esm/core/util/Debug.js","webpack:///./node_modules/tone/build/esm/core/util/TypeCheck.js","webpack:///./node_modules/tone/build/esm/core/context/AudioContext.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/tone/build/esm/core/clock/Ticker.js","webpack:///./node_modules/tone/build/esm/core/util/AdvancedTypeCheck.js","webpack:///./node_modules/tone/build/esm/core/util/Defaults.js","webpack:///./node_modules/tone/build/esm/core/Tone.js","webpack:///./node_modules/tone/build/esm/core/util/Math.js","webpack:///./node_modules/tone/build/esm/core/util/Timeline.js","webpack:///./node_modules/tone/build/esm/core/context/ContextInitialization.js","webpack:///./node_modules/tone/build/esm/core/util/Emitter.js","webpack:///./node_modules/tone/build/esm/core/context/BaseContext.js","webpack:///./node_modules/tone/build/esm/core/context/Context.js","webpack:///./node_modules/tone/build/esm/core/util/Interface.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioBuffer.js","webpack:///./node_modules/tone/build/esm/core/context/OfflineContext.js","webpack:///./node_modules/tone/build/esm/core/Global.js","webpack:///./node_modules/tone/build/esm/core/context/DummyContext.js","webpack:///./node_modules/tone/build/esm/core/type/Conversions.js","webpack:///./node_modules/tone/build/esm/core/type/TimeBase.js","webpack:///./node_modules/tone/build/esm/core/type/Time.js","webpack:///./node_modules/tone/build/esm/core/type/Frequency.js","webpack:///./node_modules/tone/build/esm/core/type/TransportTime.js","webpack:///./node_modules/tone/build/esm/core/context/ToneWithContext.js","webpack:///./node_modules/tone/build/esm/core/util/StateTimeline.js","webpack:///./node_modules/tone/build/esm/core/context/Param.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioNode.js","webpack:///./node_modules/tone/build/esm/core/context/Gain.js","webpack:///./node_modules/tone/build/esm/source/OneShotSource.js","webpack:///./node_modules/tone/build/esm/signal/ToneConstantSource.js","webpack:///./node_modules/tone/build/esm/signal/Signal.js","webpack:///./node_modules/tone/build/esm/core/clock/TickParam.js","webpack:///./node_modules/tone/build/esm/core/clock/TickSignal.js","webpack:///./node_modules/tone/build/esm/core/clock/TickSource.js","webpack:///./node_modules/tone/build/esm/core/clock/Clock.js","webpack:///./node_modules/tone/build/esm/core/util/TimelineValue.js","webpack:///./node_modules/tone/build/esm/core/type/Ticks.js","webpack:///./node_modules/tone/build/esm/core/util/IntervalTimeline.js","webpack:///./node_modules/tone/build/esm/core/clock/TransportEvent.js","webpack:///./node_modules/tone/build/esm/core/clock/TransportRepeatEvent.js","webpack:///./node_modules/tone/build/esm/core/clock/Transport.js","webpack:///./node_modules/tone/build/esm/core/context/Delay.js","webpack:///./node_modules/tone/build/esm/component/channel/Volume.js","webpack:///./node_modules/tone/build/esm/core/context/Destination.js","webpack:///./node_modules/tone/build/esm/core/context/Offline.js","webpack:///./node_modules/tone/build/esm/core/context/ToneAudioBuffers.js","webpack:///./node_modules/tone/build/esm/core/type/Midi.js","webpack:///./node_modules/tone/build/esm/core/util/Draw.js","webpack:///./node_modules/tone/build/esm/source/Source.js","webpack:///./node_modules/tone/build/esm/source/buffer/ToneBufferSource.js","webpack:///./node_modules/tone/build/esm/source/Noise.js","webpack:///./node_modules/tone/build/esm/source/UserMedia.js","webpack:///./node_modules/tone/build/esm/source/oscillator/OscillatorInterface.js","webpack:///./node_modules/tone/build/esm/source/oscillator/ToneOscillatorNode.js","webpack:///./node_modules/tone/build/esm/source/oscillator/Oscillator.js","webpack:///./node_modules/tone/build/esm/signal/SignalOperator.js","webpack:///./node_modules/tone/build/esm/signal/WaveShaper.js","webpack:///./node_modules/tone/build/esm/signal/AudioToGain.js","webpack:///./node_modules/tone/build/esm/signal/Multiply.js","webpack:///./node_modules/tone/build/esm/source/oscillator/AMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/FMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/PulseOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/FatOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/PWMOscillator.js","webpack:///./node_modules/tone/build/esm/source/oscillator/OmniOscillator.js","webpack:///./node_modules/tone/build/esm/signal/Add.js","webpack:///./node_modules/tone/build/esm/signal/Scale.js","webpack:///./node_modules/tone/build/esm/signal/Zero.js","webpack:///./node_modules/tone/build/esm/source/oscillator/LFO.js","webpack:///./node_modules/tone/build/esm/core/util/Decorator.js","webpack:///./node_modules/tone/build/esm/source/buffer/Player.js","webpack:///./node_modules/tone/build/esm/source/buffer/Players.js","webpack:///./node_modules/tone/build/esm/source/buffer/GrainPlayer.js","webpack:///./node_modules/tone/build/esm/signal/Abs.js","webpack:///./node_modules/tone/build/esm/signal/GainToAudio.js","webpack:///./node_modules/tone/build/esm/signal/Negate.js","webpack:///./node_modules/tone/build/esm/signal/Subtract.js","webpack:///./node_modules/tone/build/esm/signal/GreaterThanZero.js","webpack:///./node_modules/tone/build/esm/signal/GreaterThan.js","webpack:///./node_modules/tone/build/esm/signal/Pow.js","webpack:///./node_modules/tone/build/esm/signal/ScaleExp.js","webpack:///./node_modules/tone/build/esm/signal/SyncedSignal.js","webpack:///./node_modules/tone/build/esm/component/envelope/Envelope.js","webpack:///./node_modules/tone/build/esm/instrument/Instrument.js","webpack:///./node_modules/tone/build/esm/instrument/Monophonic.js","webpack:///./node_modules/tone/build/esm/component/envelope/AmplitudeEnvelope.js","webpack:///./node_modules/tone/build/esm/instrument/Synth.js","webpack:///./node_modules/tone/build/esm/instrument/ModulationSynth.js","webpack:///./node_modules/tone/build/esm/instrument/AMSynth.js","webpack:///./node_modules/tone/build/esm/component/filter/Filter.js","webpack:///./node_modules/tone/build/esm/component/envelope/FrequencyEnvelope.js","webpack:///./node_modules/tone/build/esm/instrument/MonoSynth.js","webpack:///./node_modules/tone/build/esm/instrument/DuoSynth.js","webpack:///./node_modules/tone/build/esm/instrument/FMSynth.js","webpack:///./node_modules/tone/build/esm/instrument/MetalSynth.js","webpack:///./node_modules/tone/build/esm/instrument/MembraneSynth.js","webpack:///./node_modules/tone/build/esm/instrument/NoiseSynth.js","webpack:///./node_modules/tone/build/esm/core/worklet/WorkletGlobalScope.js","webpack:///./node_modules/tone/build/esm/core/worklet/ToneAudioWorklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/ToneAudioWorkletProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/AudioWorkletProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","webpack:///./node_modules/tone/build/esm/core/worklet/DelayLine.worklet.js","webpack:///./node_modules/tone/build/esm/component/filter/FeedbackCombFilter.worklet.js","webpack:///./node_modules/tone/build/esm/component/filter/FeedbackCombFilter.js","webpack:///./node_modules/tone/build/esm/component/filter/OnePoleFilter.js","webpack:///./node_modules/tone/build/esm/component/filter/LowpassCombFilter.js","webpack:///./node_modules/tone/build/esm/instrument/PluckSynth.js","webpack:///./node_modules/tone/build/esm/instrument/PolySynth.js","webpack:///./node_modules/tone/build/esm/instrument/Sampler.js","webpack:///./node_modules/tone/build/esm/event/ToneEvent.js","webpack:///./node_modules/tone/build/esm/event/Loop.js","webpack:///./node_modules/tone/build/esm/event/Part.js","webpack:///./node_modules/tone/build/esm/event/PatternGenerator.js","webpack:///./node_modules/tone/build/esm/event/Pattern.js","webpack:///./node_modules/tone/build/esm/event/Sequence.js","webpack:///./node_modules/tone/build/esm/component/channel/CrossFade.js","webpack:///./node_modules/tone/build/esm/effect/Effect.js","webpack:///./node_modules/tone/build/esm/effect/LFOEffect.js","webpack:///./node_modules/tone/build/esm/effect/AutoFilter.js","webpack:///./node_modules/tone/build/esm/component/channel/Panner.js","webpack:///./node_modules/tone/build/esm/effect/AutoPanner.js","webpack:///./node_modules/tone/build/esm/component/analysis/Follower.js","webpack:///./node_modules/tone/build/esm/effect/AutoWah.js","webpack:///./node_modules/tone/build/esm/effect/BitCrusher.worklet.js","webpack:///./node_modules/tone/build/esm/effect/BitCrusher.js","webpack:///./node_modules/tone/build/esm/effect/Chebyshev.js","webpack:///./node_modules/tone/build/esm/component/channel/Split.js","webpack:///./node_modules/tone/build/esm/component/channel/Merge.js","webpack:///./node_modules/tone/build/esm/effect/StereoEffect.js","webpack:///./node_modules/tone/build/esm/effect/StereoFeedbackEffect.js","webpack:///./node_modules/tone/build/esm/effect/Chorus.js","webpack:///./node_modules/tone/build/esm/effect/Distortion.js","webpack:///./node_modules/tone/build/esm/effect/FeedbackEffect.js","webpack:///./node_modules/tone/build/esm/effect/FeedbackDelay.js","webpack:///./node_modules/tone/build/esm/component/filter/PhaseShiftAllpass.js","webpack:///./node_modules/tone/build/esm/effect/FrequencyShifter.js","webpack:///./node_modules/tone/build/esm/effect/Freeverb.js","webpack:///./node_modules/tone/build/esm/effect/JCReverb.js","webpack:///./node_modules/tone/build/esm/effect/StereoXFeedbackEffect.js","webpack:///./node_modules/tone/build/esm/effect/PingPongDelay.js","webpack:///./node_modules/tone/build/esm/effect/PitchShift.js","webpack:///./node_modules/tone/build/esm/effect/Phaser.js","webpack:///./node_modules/tone/build/esm/effect/Reverb.js","webpack:///./node_modules/tone/build/esm/component/channel/MidSideSplit.js","webpack:///./node_modules/tone/build/esm/component/channel/MidSideMerge.js","webpack:///./node_modules/tone/build/esm/effect/MidSideEffect.js","webpack:///./node_modules/tone/build/esm/effect/StereoWidener.js","webpack:///./node_modules/tone/build/esm/effect/Tremolo.js","webpack:///./node_modules/tone/build/esm/effect/Vibrato.js","webpack:///./node_modules/tone/build/esm/component/analysis/Analyser.js","webpack:///./node_modules/tone/build/esm/component/analysis/MeterBase.js","webpack:///./node_modules/tone/build/esm/component/analysis/Meter.js","webpack:///./node_modules/tone/build/esm/component/analysis/FFT.js","webpack:///./node_modules/tone/build/esm/component/analysis/DCMeter.js","webpack:///./node_modules/tone/build/esm/component/analysis/Waveform.js","webpack:///./node_modules/tone/build/esm/component/channel/Solo.js","webpack:///./node_modules/tone/build/esm/component/channel/PanVol.js","webpack:///./node_modules/tone/build/esm/component/channel/Channel.js","webpack:///./node_modules/tone/build/esm/component/channel/MultibandSplit.js","webpack:///./node_modules/tone/build/esm/core/context/Listener.js","webpack:///./node_modules/tone/build/esm/component/channel/Panner3D.js","webpack:///./node_modules/tone/build/esm/component/channel/Recorder.js","webpack:///./node_modules/tone/build/esm/component/dynamics/Compressor.js","webpack:///./node_modules/tone/build/esm/component/dynamics/Gate.js","webpack:///./node_modules/tone/build/esm/component/dynamics/Limiter.js","webpack:///./node_modules/tone/build/esm/component/dynamics/MidSideCompressor.js","webpack:///./node_modules/tone/build/esm/component/dynamics/MultibandCompressor.js","webpack:///./node_modules/tone/build/esm/component/filter/EQ3.js","webpack:///./node_modules/tone/build/esm/component/filter/Convolver.js","webpack:///./node_modules/tone/build/esm/index.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js","webpack:///./node_modules/standardized-audio-context/build/es2019/module.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js","webpack:///./node_modules/automation-events/build/es5/bundle.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js","webpack:///./node_modules/standardized-audio-context/build/es2019/read-only-map.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js","webpack:///./node_modules/standardized-audio-context/build/es2019/interfaces/index.js","webpack:///./node_modules/standardized-audio-context/build/es2019/types/index.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/abort-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-backup-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-delay-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-gain-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-automation.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/window.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js","webpack:///./node_modules/standardized-audio-context/build/es2019/guards/delay-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node-factory.js","webpack:///./node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack:///./node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:///./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack:///./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/createClass.js","webpack:///./src/synth.js","webpack:///./src/notes.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","assignNativeAudioNodeOptions","nativeAudioNode","options","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isOwnedByContext","nativeContext","context","assignNativeAudioNodeOption","option","undefined","assignNativeAudioNodeAudioParamValue","audioParam","getNativeAudioNode","audioNode","createInvalidStateError","DOMException","err","code","getAudioNodeConnections","version","assert","statement","error","Error","assertRange","gte","lte","Infinity","RangeError","assertContextRunning","isOffline","state","warn","defaultLogger","console","setLogger","logger","log","args","isUndef","arg","isDefined","isFunction","isNumber","isObject","toString","constructor","isBoolean","isArray","Array","isString","isNote","test","createOfflineAudioContext","channels","length","sampleRate","theWindow","self","hasAudioContext","__decorate","decorators","target","desc","arguments","getOwnPropertyDescriptor","Reflect","decorate","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Ticker","callback","type","updateInterval","this","_callback","_type","_updateInterval","_createClock","blob","Blob","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","_worker","_timeout","setTimeout","_createTimeout","_createWorker","clearTimeout","terminate","interval","Math","max","postMessage","_disposeClock","isAudioParam","isAudioNode","isOfflineAudioContext","isAudioContext","isAudioBuffer","AudioBuffer","noCopy","deepMerge","sources","source","shift","assign","optionsFromArguments","defaults","argsArray","keys","objKey","opts","from","has","some","splice","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","forEach","prop","debug","_wasDisposed","TONE_DEBUG_CLASS","GT","a","b","GTE","EQ","LT","abs","clamp","min","super","_timeline","getDefaults","memory","increasing","event","time","valueOf","lastValue","push","index","_search","diff","param","len","after","slice","beginning","end","midPoint","floor","nextEvent","lowerBound","upperBound","_iterate","startTime","endTime","dispose","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","split","eventName","_events","boundCallback","off","on","eventList","constr","_constants","Map","_timeouts","_timeoutIds","_initialized","_workletModules","_context","_latencyHint","latencyHint","lookAhead","_ticker","emit","clockSource","_timeoutLoop","onstatechange","ctx","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","numberOfChannels","createBuffer","numberOfInputs","createChannelMerger","numberOfOutputs","createChannelSplitter","createConstantSource","createConvolver","maxDelayTime","createDelay","createDynamicsCompressor","createGain","feedForward","feedback","createIIRFilter","createPanner","real","imag","constraints","createPeriodicWave","createStereoPanner","createWaveShaper","stream","createMediaStreamSource","createMediaStreamDestination","audioData","decodeAudioData","currentTime","initialize","_listener","_transport","_draw","_destination","createAudioWorkletNode","rawContext","url","audioWorklet","set","addModule","promises","promise","all","hint","lookAheadValue","resume","close","val","buffer","arr","getChannelData","constant","channelCount","channelCountMode","loop","start","map","disconnect","now","firstEvent","peek","fn","timeout","add","id","remove","intervalFn","readOnly","str","writable","noOp","onload","reverse","load","catch","onerror","_buffer","getContext","loaded","_reversed","_reverse","doneLoading","audioBuffer","downloads","array","isMultidimensional","multiChannelArray","copyToChannel","chanNum","fromArray","toArray","outputArray","Float32Array","numChannels","channel","channelArray","sample","ret","duration","startSamples","endSamples","retBuffer","subarray","rev","matches","match","extensions","extension","ext","supportsType","replace","baseUrl","endsWith","response","fetch","ok","arrayBuffer","document","createElement","canPlayType","_currentTime","_duration","asynchronous","yieldEvery","workletsAreReady","_renderClock","startRendering","dummyContext","_numberOfChannels","_length","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_audioData","_name","_options","_url","_fn","_id","_interval","_val","_d","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","pow","gainToDb","gain","LN10","intervalToFrequencyRatio","A4","ftom","frequency","round","log2","ftomf","mtof","midi","units","defaultUnits","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","trim","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","transport","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","testNotations","power","closest","closestSeconds","notation","notationSeconds","quarterTime","quarters","measures","sixteenths","sixteenthString","join","Time","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","intervals","transpose","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","Frequency","TransportTime","defaultContext","props","attribute","member","setValueAtTime","_getPartialProperties","initial","_initial","setStateAtTime","overridden","_minOutput","_param","_swappable","swappable","input","connect","_initialValue","defaultValue","convert","_minValue","minValue","_maxValue","maxValue","_toType","getValueAtTime","cancelScheduledValues","_fromType","_is","computedTime","isFinite","JSON","stringify","_assertRange","getAfter","before","beforeValue","previous","getBefore","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","exponentialRampToValueAtTime","rampTime","setRampPoint","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","values","scaling","startingValue","segTime","cancel","valueAtTime","sampleTime","exponentialRampTo","linearRampTo","previousEvent","subdivisions","forEachAfter","t0","v0","v1","exp","t1","_internalChannels","output","node","nodeList","_isAudioNode","_getInternalNodes","channelInterpretation","_getChannelProperties","_setChannelProperties","destination","outputNum","inputNum","toDestination","nodes","connectSeries","first","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber","_gainNode","onended","_startTime","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","curve","fadeInTime","_stopGain","cancelStop","fadeOutTime","targetRampTo","additionalTail","_stopSource","_onended","_source","offset","_startGain","stop","override","_constantSource","connectSignal","setValueCurveAtTime","rampTo","signal","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","currentTick","getTicksAtTime","getTimeOfTick","tick","delta","k","sqrt","sol1","sol2","when","getDurationOfTicks","computedDuration","startTicks","ticksToTime","timeToTicks","_state","_tickOffset","setTicksAtTime","stopEvent","getLastState","tmpEvent","lastState","elapsedTicks","forEachBetween","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","lastStateEvent","forEachTickBetween","maxStartTime","ceil","nextTickTime","_lastUpdate","_boundLoop","_loop","_tickSource","pause","mixin","initialValue","Ticks","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","_removeNode","forEachFrom","replacement","isLeftChild","left","right","_setRoot","_replaceNodeInParent","temp","getBalance","pivotNode","balance","_rotateLeft","_rotateRight","low","allNodes","traverse","searchAfter","high","_left","_right","height","point","_eventId","_once","once","clear","_currentId","_nextId","_nextTick","_boundRestart","_restart","_createEvents","invoke","scheduleOnce","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","loopEnd","loopStart","swing","swingSubdivision","tickTime","progress","amount","sin","PI","forEachAtTime","_addEvent","eventId","item","timeline","computedAfter","offsetTicks","timeSig","startPosition","endPosition","toNotation","toBarsBeatsSixteenths","remainingTicks","ratio","computedFreq","ratioSignal","syncedSignal","maxDelayInSeconds","maxDelay","_maxDelay","delayTime","_delayNode","volume","_unmutedVolume","mute","unshift","maxChannelCount","Offline","originalContext","bufferPromise","render","_buffers","_loadingCount","urls","_bufferLoaded","every","_","Midi","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","requestAnimationFrame","cancelAnimationFrame","draw","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","sched","schedule","_start","restart","getNextState","_stop","stateEvent","startOffset","unsync","_sourceStarted","_sourceStopped","playbackRate","computedOffset","loopDuration","computedDur","_playbackRate","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","labelOrId","supported","devices","enumerateDevices","_device","find","device","label","deviceId","audio","echoCancellation","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","mediaStreamNode","_mediaStream","getAudioTracks","track","filter","kind","active","groupId","generateWaveform","instance","detune","_oscillator","periodicWave","setPeriodicWave","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncSignal","unsyncSignal","_periodicWaveCache","description","_phase","arrayA","arrayB","element","oscProps","isBasicType","cache","_getCachedPeriodicWave","wave","_getRealImaginary","partial","exec","fullPartials","v","periodicWaveSize","fftSize","piFactor","TypeError","cos","sum","twoPi","_inverseFFT","_shaper","mapping","setMap","normalized","oversample","oversampling","includes","_norm","x","_mult","factor","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","chain","modulationIndex","_widthGate","_thresh","width","_triangle","_oscillators","_spread","spread","count","_forEach","osc","iterator","sourceType","_scale","_pulse","modulationFrequency","carrierType","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc","blockTime","sType","mType","_sum","addend","_add","_min","_max","_setRange","_gain","getConstant","_stoppedValue","_clampValue","_amplitudeGain","amplitude","_stoppedSignal","_zeros","_a2g","_scaler","sync","syncFrequency","unsyncFrequency","getInitialValue","currentMin","currentMax","range","valueMap","propertyKey","configurable","newValue","timeRange","_activeSources","Set","_onload","autostart","delete","size","origDuration","_onSourceEnd","implicitEnd","_players","player","_tick","grainSize","_grainSize","_overlap","overlap","_onstop","_abs","_multiply","_neg","subtrahend","_subtract","_gtz","comparator","_exponentScaler","_expFunc","_exponent","exponent","_exp","_lastVal","scheduleRepeat","_onTick","_syncedCallback","_anchorValue","_sig","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","direction","curveName","EnvelopeCurves","curveDef","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","velocity","currentValue","decayValue","decayStart","triggerAttack","triggerRelease","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","j","bounce","In","Out","cosine","exponential","linear","ripple","sine","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","envelope","computedAttack","computedDecay","modulation","modulationEnvelope","fan","_filters","Q","rolloff","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","freqValues","magValues","phaseValues","filterClone","getFrequencyResponse","_octaves","octaves","_baseFrequency","baseFrequency","filterEnvelope","voice0","voice1","_vibrato","vibratoRate","_vibratoGain","vibratoAmount","inharmRatios","_freqMultipliers","_amplitude","_highpass","mult","_filterFreqScaler","resonance","freqMult","pitchDecay","hertz","maxNote","noise","workletContext","addToWorklet","classOrFunction","classOrFunctionToString","RegExp","getPrototypeOf","registerProcessor","classDesc","processor","workletOptions","onprocessorerror","_audioWorkletName","_dummyGain","_dummyParam","addAudioWorkletModule","disposed","_worklet","onReady","port","parameterDescriptors","MessagePort","_inputs","_outputs","_parameters","blockSize","data","params","parameters","paramName","inputs","outputs","updateParams","inputSample","generate","writeHead","delay","readHead","delayLine","DelayLine","delayedSample","setParam","_frequency","_createFilter","oldFilter","_filter","a0","fq","_combFilter","_lowpass","dampening","_noise","attackNoise","_lfcf","delayAmount","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","voice","maxPolyphony","_dummyVoice","_getNextAvailableVoice","setInterval","_collectGarbage","activeVoiceIndex","findIndex","_makeVoiceAvailable","activeVoices","firstAvail","notes","midiNote","released","_triggerAttack","_triggerRelease","_scheduleEvent","durationSeconds","sanitizedOptions","clearInterval","urlMap","mid","difference","_findClosest","closestNote","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","prob","variation","reschedulTime","lastEvent","_event","iterations","iters","events","_startNote","timeInTicks","at","_restartEvent","attr","_setAll","_testLoopBoundries","upPatternGen","clampToArraySize","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomOnce","copy","PatternGenerator","pattern","randomIndex","randomGen","randomWalk","_values","_pattern","_value","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","Proxy","_rescheduleSequence","sequence","eventOffset","_panner","_split","_g2a","fade","pan","_dryWet","wet","effectSend","effectReturn","effect","_lfo","depth","connectEffect","oct","smoothing","_smoothing","_follower","follower","_sweepRange","_inputBoost","_bandpass","_peaking","_setSweepRange","sensitivity","baseFreq","_channel","bits","_bitCrusherWorklet","_order","order","degree","memo","_getCoefficient","_splitter","_merger","_merge","_feedbackL","_feedbackR","_feedbackSplit","_feedbackMerge","_depth","_delayTime","_lfoL","_lfoR","_delayNodeL","_delayNodeR","connectEffectLeft","connectEffectRight","deviation","_distortion","distortion","deg","_feedbackGain","offset90","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","bankValues","coefficients","_sine","_cosine","_sineMultiply","_cosineMultiply","_negate","_phaseShifter","immediate","combFilterTunings","allpassFilterFrequencies","_combFilters","_allpassFiltersL","_allpassFiltersR","roomSize","allpassL","allpassR","lfpf","al","ar","cf","combFilterDelayTimes","combFilterResonances","allpassFilterFreqs","_allpassFilters","_feedbackCombFilters","_scaleRoomSize","allpass","fbcf","apf","_leftDelay","_rightDelay","_rightPreDelay","_delayA","_lfoA","_delayB","_lfoB","_crossFade","_crossFadeLFO","_feedbackDelay","_pitch","_windowSize","windowSize","_filtersL","_makeFilters","stages","_filtersR","connectToFreq","filters","_convolver","ready","_decay","_preDelay","preDelay","previousReady","noiseL","noiseR","merge","gainNode","renderPromise","_midAdd","SQRT1_2","_sideSubtract","side","_leftMult","_rightMult","_midSideMerge","_midSideSplit","_midSend","_sideSend","_midReturn","_sideReturn","_twoTimesWidthMid","_twoTimesWidthSide","_midMult","connectEffectMid","_oneMinusWidth","_sideMult","connectEffectSide","_amplitudeL","_amplitudeR","_analysers","analyser","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","smoothingTimeConstant","_analyser","_rms","normalRange","getValue","aValues","vals","totalSquared","rms","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","_soloed","_noSolos","_solo","_panVol","muted","buses","bus","_getBus","sendKnob","_lowMidFilter","lowFrequency","highFrequency","positionX","listener","positionY","positionZ","forwardX","forwardY","forwardZ","upX","upY","upZ","panningModel","maxDistance","distanceModel","coneOuterGain","coneOuterAngle","coneInnerAngle","refDistance","rolloffFactor","orientationX","orientationY","orientationZ","y","z","_recorder","MediaRecorder","mimeType","startPromise","handleStart","removeEventListener","addEventListener","dataPromise","handleData","_compressor","threshold","knee","reduction","_gt","_gate","thresh","smoothingTime","_multibandSplit","_lowGain","_midGain","_highGain","normalize","buff","norm","Buffer","Buffers","BufferSource","getValueForKey","createNotSupportedError","interceptConnections","original","interceptor","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","cacheTestResult","window","nativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","getBackupNativeContext","createNativeAudioNode","createNativeAnalyserNode","getAudioNodeRenderer","renderInputsOfAudioNode","createAnalyserNodeRenderer","auxiliaryGainNodeStore","getNativeContext","audioParamAudioNodeStore","eventTargetConstructor","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","audioNodeConstructor","analyserNodeConstructor","audioBufferStore","nativeAudioBufferConstructor","convertNumberToUnsignedLong","Uint32Array","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","createNativeGainNode","addSilentConnection","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","renderInputsOfAudioParam","connectAudioParam","createNativeAudioBufferSourceNode","renderAutomation","createAudioBufferSourceNodeRenderer","createAudioParam","audioBufferSourceNodeConstructor","audioDestinationNodeConstructor","createNativeBiquadFilterNode","createBiquadFilterNodeRenderer","biquadFilterNodeConstructor","monitorConnections","wrapChannelMergerNode","createNativeChannelMergerNode","createChannelMergerNodeRenderer","channelMergerNodeConstructor","createNativeChannelSplitterNode","createChannelSplitterNodeRenderer","channelSplitterNodeConstructor","createNativeConstantSourceNodeFaker","createNativeConstantSourceNode","createConstantSourceNodeRenderer","constantSourceNodeConstructor","createNativeConvolverNodeFaker","createNativeConvolverNode","createConvolverNodeRenderer","convolverNodeConstructor","createNativeDelayNode","createDelayNodeRenderer","delayNodeConstructor","createNativeDynamicsCompressorNode","createDynamicsCompressorNodeRenderer","dynamicsCompressorNodeConstructor","createGainNodeRenderer","gainNodeConstructor","createNativeScriptProcessorNode","createNativeIIRFilterNodeFaker","renderNativeOfflineAudioContext","createIIRFilterNodeRenderer","createNativeIIRFilterNode","iIRFilterNodeConstructor","createAudioListener","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","createNativeOscillatorNode","createOscillatorNodeRenderer","oscillatorNodeConstructor","createConnectedNativeAudioBufferSourceNode","createNativeWaveShaperNodeFaker","createNativeWaveShaperNode","createNativePannerNodeFaker","createNativePannerNode","createPannerNodeRenderer","pannerNodeConstructor","createNativePeriodicWave","periodicWaveConstructor","nativeStereoPannerNodeFakerFactory","createNativeStereoPannerNode","createStereoPannerNodeRenderer","stereoPannerNodeConstructor","createWaveShaperNodeRenderer","waveShaperNodeConstructor","isSecureContext","exposeCurrentFrameAndCurrentTime","isNativeContext","baseAudioContextConstructor","createNativeMediaElementAudioSourceNode","mediaElementAudioSourceNodeConstructor","createNativeMediaStreamAudioDestinationNode","mediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioSourceNode","mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","mediaStreamTrackAudioSourceNodeConstructor","audioContextConstructor","getUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","connectMultipleOutputs","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createNativeAudioWorkletNodeFaker","createNativeAudioWorkletNode","nativeAudioWorkletNodeConstructor","createAudioWorkletNodeRenderer","audioWorkletNodeConstructor","createNativeOfflineAudioContext","offlineAudioContextConstructor","isAnyAudioContext","isAnyAudioNode","isAnyAudioParam","isAnyOfflineAudioContext","isSupported","testPromiseSupport","uint32Array","createIndexSizeError","insertElementInSet","predicate","ignoreDuplicates","lmnt","setInternalStateToActive","eventListener","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","insertTime","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","createSetValueCurveAutomationEvent","getTargetValueAtTime","valueAtStartTime","_ref","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","upperIndex","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","_automationEvents","_currenTime","_defaultValue","eventTime","removedAutomationEvent","lastAutomationEvent","startValue","truncatedAutomationEvent","_index","previousAutomationEvent","persistentAutomationEvent","remainingAutomationEvents","firstRemainingAutomationEvent","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","factory","isPartOfACycle","getEventListenersOfAudioNode","setInternalStateToPassive","isAudioNodeOutputConnection","outputConnection","isActiveAudioNode","audioNodeOrAudioParam","nativeAudioNodeOrAudioParam","getAudioParamConnections","getNativeAudioParam","wrapEventListener","descriptor","defineProperties","currentTarget","handleEvent","wrapAudioBufferGetChannelDataMethod","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","fakeNativeDestinationAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","copyFromChannel","channelNumber","bufferOffset","byteLength","channelData","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","arrays","createInvalidAccessError","overwriteAccessors","createGetter","createSetter","isValidLatencyHint","ReadOnlyMap","_map","entries","filterBuffer","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","computeBufferSize","baseLatency","createUnknownError","isDCCurve","createAbortError","createAddAudioNodeConnections","audioNodeConnectionsStore","audioNodeRenderer","activeInputs","passiveInputs","renderer","createAddAudioParamConnections","audioParamConnectionsStore","audioParamRenderer","createAddSilentConnection","nativeGainNode","createAddUnrenderedAudioWorkletNode","audioWorkletNode","DEFAULT_OPTIONS","maxDecibels","minDecibels","createAnalyserNodeConstructor","audionNodeConstructor","mergedOptions","nativeAnalyserNode","_nativeAnalyserNode","getByteFrequencyData","getByteTimeDomainData","createAnalyserNodeRendererFactory","renderedNativeAnalyserNodes","proxy","nativeOfflineAudioContext","trace","renderedNativeAnalyserNode","async","createAnalyserNode","createAudioBufferConstructor","testNativeAudioBufferConstructorSupport","hasInstance","createAudioBufferSourceNodeConstructor","nativeAudioBufferSourceNode","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","fill","wrappedListener","nativeOnEnded","resetInternalStateToPassive","createAudioBufferSourceNodeRendererFactory","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioContextConstructor","nativeAudioContext","_baseLatency","_nativeAudioContext","revokeState","mediaElement","mediaStream","mediaStreamTrack","resolvePromise","suspend","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","nativeAudioDestinationNodePromise","createAudioDestinationNode","createAudioListenerFactory","nativeListener","channelMergerNode","scriptProcessorNode","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","onaudioprocess","inputBuffer","orientation","setOrientation","positon","setPosition","createFakeAudioParams","createAudioParamFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","nativeAudioParam","automationEventList","flush","previousLastEvent","pop","currentLastEvent","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","outputChannelCount","parameterData","processorOptions","createChannelCount","createAudioWorkletNodeConstructor","nodeNameToProcessorConstructorMap","processorConstructor","nativeAudioWorkletNode","nm","_nativeAudioWorkletNode","_onprocessorerror","nativeOnProcessorError","createBaseAudioContextConstructor","_nativeContext","_audioWorklet","moduleURL","disableNormalization","successCallback","errorCallback","createBiquadFilterNodeConstructor","nativeBiquadFilterNode","_Q","_detune","log10","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createCacheTestResult","ongoingTests","testResults","tester","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createChannelMergerNodeConstructor","createChannelMergerNodeRendererFactory","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createConnectAudioParam","createConnectMultipleOutputs","outputAudioNodes","outputAudioNode","createConnectedNativeAudioBufferSourceNodeFactory","createConstantSourceNodeConstructor","createConstantSourceNodeRendererFactory","nativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","createConvertNumberToUnsignedLong","unit32Array","createConvolverNodeConstructor","nativeConvolverNode","_nativeConvolverNode","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createCreateNativeOfflineAudioContext","createDataCloneError","createDecrementCycleCounter","cycleCounters","cycleCounter","nativeDestinationAudioParam","createDelayNodeConstructor","nativeDelayNode","createDelayNodeRendererFactory","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDeleteUnrenderedAudioWorkletNode","getOutputAudioNodeAtIndex","createDisconnectMultipleOutputs","destinationOrOutput","createDynamicsCompressorNodeConstructor","nativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createEncodingError","createEvaluateSource","SyntaxError","head","script","originalOnErrorHandler","removeErrorEventListenerAndRevokeUrl","revokeObjectURL","message","src","lineno","colno","location","href","appendChild","createEventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","dispatchEvent","createExposeCurrentFrameAndCurrentTime","currentFrame","createFetchSource","text","createGainNodeConstructor","createGainNodeRendererFactory","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGetAudioNodeRenderer","audioNodeConnections","createGetAudioParamRenderer","audioParamConnections","createGetBackupNativeContext","backupNativeContext","bckpNtveCntxt","createGetNativeContext","contextStore","createGetUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodes","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","ntvCntxt","partialOfflineAudioContext","renderedBuffer","filteredBuffer","filterFullBuffer","createIncrementCycleCounterFactory","createIsAnyAudioContext","anything","createIsAnyAudioNode","audioNodeStore","createIsAnyAudioParam","createIsAnyOfflineAudioContext","createIsNativeAudioContext","createIsNativeAudioNode","AudioNode","createIsNativeAudioParam","AudioParam","createIsNativeContext","createIsNativeOfflineAudioContext","createIsSecureContext","createIsSupportedPromise","testAudioBufferCopyChannelMethodsSubarraySupport","testAudioContextCloseMethodSupport","testAudioContextDecodeAudioDataMethodTypeErrorSupport","testAudioContextOptionsSupport","testAudioNodeConnectMethodSupport","testAudioWorkletProcessorNoOutputsSupport","testChannelMergerNodeChannelCountSupport","testConstantSourceNodeAccurateSchedulingSupport","testConvolverNodeBufferReassignabilitySupport","testIsSecureContextSupport","testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","testStereoPannerNodeDefaultValueSupport","testTransferablesSupport","createMediaElementAudioSourceNodeConstructor","nativeMediaElementAudioSourceNode","_mediaElement","_nativeMediaElementAudioSourceNode","createMediaStreamAudioDestinationNodeConstructor","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","createMediaStreamAudioSourceNodeConstructor","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","createMinimalAudioContextConstructor","createMinimalBaseAudioContextConstructor","_onstatechange","nativeOnStateChange","createMinimalOfflineAudioContextConstructor","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_nativeOfflineAudioContext","createMonitorConnections","whenConnected","whenDisconnected","connections","wasDisconnected","connection","wasConnected","isDisconnected","createNativeAudioBufferConstructor","createNativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","createNativeAudioNodeFactory","factoryFunction","createNativeAudioWorkletNodeConstructor","AudioWorkletNode","createNativeBiquadFilterNodeFactory","createNativeChannelMergerNodeFactory","nativeChannelMergerNode","createNativeConstantSourceNodeFactory","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","audioBufferSourceNode","nativeConstantSourceNodeFaker","createNativeConvolverNodeFactory","createNativeConvolverNodeFakerFactory","convolverNode","nativeConvolverNodeFaker","createNativeDelayNodeFactory","createNativeDynamicsCompressorNodeFactory","createNativeGainNodeFactory","createNativeIIRFilterNodeFactory","divide","denominator","evaluatePolynomial","coefficient","createNativeIIRFilterNodeFakerFactory","bufferSize","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","atan2","createNativeMediaElementAudioSourceNodeFactory","ntvDCntxt","createMediaElementSource","createNativeMediaStreamAudioDestinationNodeFactory","createNativeMediaStreamAudioSourceNodeFactory","audioStreamTracks","filteredAudioStreamTracks","sort","MediaStream","createNativeMediaStreamTrackAudioSourceNodeFactory","createMediaStreamTrackSource","createNativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOscillatorNodeFactory","nativeOscillatorNode","createNativePannerNodeFactory","nativePannerNode","createNativePannerNodeFakerFactory","pannerNode","SINGLE_CHANNEL_OPTIONS","inputGainNode","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePeriodicWaveFactory","wrappedImag","wrappedReal","createNativeScriptProcessorNodeFactory","numberOfInputChannels","numberOfOutputChannels","createScriptProcessor","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","nativeStereoPannerNode","createNativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","CURVE_SIZE","channelSplitterNode","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","connectGraph","disconnectGraph","isConnected","createNativeWaveShaperNodeFactory","nativeWaveShaperNode","disconnectNativeAudioBufferSourceNode","createNativeWaveShaperNodeFakerFactory","negativeWaveShaperNode","positiveWaveShaperNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","createOfflineAudioContextConstructor","createOscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createPannerNodeConstructor","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeRendererFactory","renderedBufferPromise","renderedNativeGainNodeOrNativePannerNode","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","createPeriodicWaveConstructor","periodicWaveStore","PeriodicWave","createRenderAutomation","getAudioParamRenderer","replay","createRenderInputsOfAudioNode","nextTrace","allRenderingPromises","renderingPromises","createRenderInputsOfAudioParam","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","createStartRendering","createStereoPannerNodeConstructor","_pan","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createTestAudioBufferConstructorSupport","createTestAudioBufferCopyChannelMethodsSubarraySupport","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","offlineAudioContext","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport","createTestAudioContextCloseMethodSupport","audioContext","isAudioContextClosable","createTestAudioContextDecodeAudioDataMethodTypeErrorSupport","isPending","createTestAudioContextOptionsSupport","createTestAudioNodeConnectMethodSupport","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","createTestAudioWorkletProcessorNoOutputsSupport","isCallingProcess","createTestChannelMergerNodeChannelCountSupport","createTestConstantSourceNodeAccurateSchedulingSupport","Number","POSITIVE_INFINITY","createTestConvolverNodeBufferReassignabilitySupport","createTestIsSecureContextSupport","createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","createTestOfflineAudioContextCurrentTimeSupport","createTestStereoPannerNodeDefaultValueSupport","stereoPanner","createWaveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWindow","createWrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","nullifiedBuffer","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","createWrapChannelMergerNode","monitorConnectionsFunction","ArrayBuffer","port1","port2","MessageChannel","wrapAudioBufferSourceNodeStartMethodOffsetClamping","clampedOffset","isAudioWorkletNode","deleteEventListenerOfAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","matchingElement","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","analyzer","dummy","ones","chnnlDt","visitEachAudioNodeOnce","cycles","visitor","counts","cycle","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputConnections","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","eventListeners","isActive","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","createAudioNodeConstructor","addAudioNodeConnections","createIncrementCycleCounter","decrementCycleCounter","detectCycles","_nativeAudioNode","returnValue","connectionsToDestination","filteredConnections","wrapAudioNodeDisconnectMethod","auxiliaryGainNodes","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","destinations","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","deleteConnectionToDestination","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","onmessageerror","cloneAudioWorkletNodeOptions","createNativeAudioWorkletNodeFakerFactory","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessor","nodeToProcessorMap","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","prmtrs","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","potentiallyEmptyInputs","activeSourceFlag","process","ErrorEvent","disconnectFakeGraph","connectFakeGraph","createNativeAudioBufferSourceNodeFactory","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","stopTime","actualStartTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","createNativeAnalyserNodeFactory","byteTimeDomainData","Uint8Array","wrapAnalyserNodeGetFloatTimeDomainDataMethod","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","importStatements","sourceWithoutImportStatements","unresolvedUrl","importStatementWithResolvedUrl","verifyParameterDescriptors","verifyProcessorCtor","processorCtor","constructible","isConstructible","createAddAudioWorkletModule","evaluateSource","fetchSource","ongoingRequests","resolvedRequests","credentials","absoluteUrl","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","evaluateAudioWorkletGlobalScope","_AWGS","rslvdRqstsFCntxt","ngngRqstsFCntxt","createDetectCycles","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","createDecodeAudioData","detachedArrayBuffers","anyContext","complete","detachArrayBuffer","fail","createNativeAudioWorkletNodeFactory","testClonabilityOfAudioWorkletNodeOptions","processBuffer","processedBuffer","getAudioWorkletProcessor","createAudioWorkletNodeRendererFactory","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","createNativeChannelSplitterNodeFactory","nativeChannelSplitterNode","wrapChannelSplitterNode","createIIRFilterNodeConstructor","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","runtime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","Context","_invoke","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","__await","unwrapped","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","iter","skipTempReset","charAt","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","_arr","_n","_e","_s","_i","arrayLikeToArray","minLen","arr2","Constructor","_defineProperties","protoProps","staticProps","synths","Tone","toMaster","synth","body","querySelectorAll","classList","check","play","querySelector","rows","tempo","row","style","boxShadow","checkbox","checked","ToneNote","require","synthNote","PolySynth","gainNote","Gain","sequencerKey","buttons","stopPropagation","offsetWidth"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 689);\n","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_PARAM_CONNECTIONS_STORE = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const EVENT_LISTENERS = new WeakMap();\nexport const CYCLE_COUNTERS = new WeakMap(); // This clunky name is borrowed from the spec. :-)\n\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n  assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n  return nativeAudioNode.context === nativeContext;\n};","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n  const value = options[option];\n\n  if (value !== undefined && value !== nativeAudioNode[option]) {\n    nativeAudioNode[option] = value;\n  }\n};","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n  const value = options[audioParam];\n\n  if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n    nativeAudioNode[audioParam].value = value;\n  }\n};","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = audioNode => {\n  return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};","export const createInvalidStateError = () => {\n  try {\n    return new DOMException('', 'InvalidStateError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 11;\n    err.name = 'InvalidStateError';\n    return err;\n  }\n};","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = audioNode => {\n  return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};","export const version = \"14.6.8\";","/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement, error) {\n  if (!statement) {\n    throw new Error(error);\n  }\n}\n/**\n * Make sure that the given value is within the range\n */\n\nexport function assertRange(value, gte, lte = Infinity) {\n  if (!(gte <= value && value <= lte)) {\n    throw new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n  }\n}\n/**\n * Make sure that the given value is within the range\n */\n\nexport function assertContextRunning(context) {\n  // add a warning if the context is not started\n  if (!context.isOffline && context.state !== \"running\") {\n    warn(\"The AudioContext is \\\"suspended\\\". Invoke Tone.start() from a user action to start the audio.\");\n  }\n}\n/**\n * The default logger is the console\n */\n\nlet defaultLogger = console;\n/**\n * Set the logging interface\n */\n\nexport function setLogger(logger) {\n  defaultLogger = logger;\n}\n/**\n * Log anything\n */\n\nexport function log(...args) {\n  defaultLogger.log(...args);\n}\n/**\n * Warn anything\n */\n\nexport function warn(...args) {\n  defaultLogger.warn(...args);\n}","/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg) {\n  return typeof arg === \"undefined\";\n}\n/**\n * Test if the arg is not undefined\n */\n\nexport function isDefined(arg) {\n  return !isUndef(arg);\n}\n/**\n * Test if the arg is a function\n */\n\nexport function isFunction(arg) {\n  return typeof arg === \"function\";\n}\n/**\n * Test if the argument is a number.\n */\n\nexport function isNumber(arg) {\n  return typeof arg === \"number\";\n}\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\n\nexport function isObject(arg) {\n  return Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object;\n}\n/**\n * Test if the argument is a boolean.\n */\n\nexport function isBoolean(arg) {\n  return typeof arg === \"boolean\";\n}\n/**\n * Test if the argument is an Array\n */\n\nexport function isArray(arg) {\n  return Array.isArray(arg);\n}\n/**\n * Test if the argument is a string.\n */\n\nexport function isString(arg) {\n  return typeof arg === \"string\";\n}\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\n\nexport function isNote(arg) {\n  return isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}","import { AudioContext as stdAudioContext, AudioWorkletNode as stdAudioWorkletNode, OfflineAudioContext as stdOfflineAudioContext } from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n/**\n * Create a new AudioContext\n */\n\nexport function createAudioContext() {\n  return new stdAudioContext();\n}\n/**\n * Create a new OfflineAudioContext\n */\n\nexport function createOfflineAudioContext(channels, length, sampleRate) {\n  return new stdOfflineAudioContext(channels, length, sampleRate);\n}\n/**\n * A reference to the window object\n * @hidden\n */\n\nexport const theWindow = typeof self === \"object\" ? self : null;\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\n\nexport const hasAudioContext = theWindow && (theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\nexport function createAudioWorkletNode(context, name, options) {\n  assert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\"); // @ts-ignore\n\n  return new stdAudioWorkletNode(context, name, options);\n}\n/**\n * This promise resolves to a boolean which indicates if the\n * functionality is supported within the currently used browse.\n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\n\nexport { isSupported as supported } from \"standardized-audio-context\";","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nexport var __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nexport function __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nexport function __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nexport function __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nexport function __exportStar(m, exports) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n;\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n;\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result.default = mod;\n  return result;\n}\nexport function __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    default: mod\n  };\n}\nexport function __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n}","/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval; // create the clock source for the first time\n\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n\n\n  _createWorker() {\n    const blob = new Blob([\n    /* javascript */\n    `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n\n\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n\n\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n\n\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n\n\n  get updateInterval() {\n    return this._updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._disposeClock();\n\n    this._type = type;\n\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this._disposeClock();\n  }\n\n}","import { isAnyAudioContext, isAnyAudioNode, isAnyAudioParam, isAnyOfflineAudioContext } from \"standardized-audio-context\";\n/**\n * Test if the given value is an instanceof AudioParam\n */\n\nexport function isAudioParam(arg) {\n  return isAnyAudioParam(arg);\n}\n/**\n * Test if the given value is an instanceof AudioNode\n */\n\nexport function isAudioNode(arg) {\n  return isAnyAudioNode(arg);\n}\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\n\nexport function isOfflineAudioContext(arg) {\n  return isAnyOfflineAudioContext(arg);\n}\n/**\n * Test if the arg is an instanceof AudioContext\n */\n\nexport function isAudioContext(arg) {\n  return isAnyAudioContext(arg);\n}\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\n\nexport function isAudioBuffer(arg) {\n  return arg instanceof AudioBuffer;\n}","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n/**\n * Some objects should not be merged\n */\n\nfunction noCopy(key, arg) {\n  return key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\nexport function deepMerge(target, ...sources) {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (noCopy(key, source[key])) {\n        target[key] = source[key];\n      } else if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  } // @ts-ignore\n\n\n  return deepMerge(target, ...sources);\n}\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\n\nexport function deepEquals(arrayA, arrayB) {\n  return arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n/**\n * Convert an args array into an object.\n */\n\nexport function optionsFromArguments(defaults, argsArray, keys = [], objKey) {\n  const opts = {};\n  const args = Array.from(argsArray); // if the first argument is an object and has an object key\n\n  if (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n    // if it's not part of the defaults\n    const partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\n    if (!partOfDefaults) {\n      // merge that key\n      deepMerge(opts, {\n        [objKey]: args[0]\n      }); // remove the obj key from the keys\n\n      keys.splice(keys.indexOf(objKey), 1); // shift the first argument off\n\n      args.shift();\n    }\n  }\n\n  if (args.length === 1 && isObject(args[0])) {\n    deepMerge(opts, args[0]);\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      if (isDefined(args[i])) {\n        opts[keys[i]] = args[i];\n      }\n    }\n  }\n\n  return deepMerge(defaults, opts);\n}\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\n\nexport function getDefaultsFromInstance(instance) {\n  return instance.constructor.getDefaults();\n}\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\n\nexport function defaultArg(given, fallback) {\n  if (isUndef(given)) {\n    return fallback;\n  } else {\n    return given;\n  }\n}\n/**\n * Remove all of the properties belonging to omit from obj.\n */\n\nexport function omitFromObject(obj, omit) {\n  omit.forEach(prop => {\n    if (Reflect.has(obj, prop)) {\n      delete obj[prop];\n    }\n  });\n  return obj;\n}","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { log } from \"./util/Debug\";\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\n\nexport class Tone {\n  constructor() {\n    //-------------------------------------\n    // \tDEBUGGING\n    //-------------------------------------\n\n    /**\n     * Set this debug flag to log all events that happen in this class.\n     */\n    this.debug = false; //-------------------------------------\n    // \tDISPOSING\n    //-------------------------------------\n\n    /**\n     * Indicates if the instance was disposed\n     */\n\n    this._wasDisposed = false;\n  }\n  /**\n   * Returns all of the default options belonging to the class.\n   */\n\n\n  static getDefaults() {\n    return {};\n  }\n  /**\n   * Prints the outputs to the console log for debugging purposes.\n   * Prints the contents only if either the object has a property\n   * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n   * is set to the name of the class.\n   * @example\n   * const osc = new Tone.Oscillator();\n   * // prints all logs originating from this oscillator\n   * osc.debug = true;\n   * // calls to start/stop will print in the console\n   * osc.start();\n   */\n\n\n  log(...args) {\n    // if the object is either set to debug = true\n    // or if there is a string on the Tone.global.with the class name\n    if (this.debug || theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS) {\n      log(this, ...args);\n    }\n  }\n  /**\n   * disconnect and dispose.\n   */\n\n\n  dispose() {\n    this._wasDisposed = true;\n    return this;\n  }\n  /**\n   * Indicates if the instance was disposed. 'Disposing' an\n   * instance means that all of the Web Audio nodes that were\n   * created for the instance are disconnected and freed for garbage collection.\n   */\n\n\n  get disposed() {\n    return this._wasDisposed;\n  }\n  /**\n   * Convert the class to a string\n   * @example\n   * const osc = new Tone.Oscillator();\n   * console.log(osc.toString());\n   */\n\n\n  toString() {\n    return this.name;\n  }\n\n}\n/**\n * The version number semver\n */\n\nTone.version = version;","/**\n * The threshold for correctness for operators. Less than one sample even\n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n/**\n * Test if A is greater than B\n */\n\nexport function GT(a, b) {\n  return a > b + EPSILON;\n}\n/**\n * Test if A is greater than or equal to B\n */\n\nexport function GTE(a, b) {\n  return GT(a, b) || EQ(a, b);\n}\n/**\n * Test if A is less than B\n */\n\nexport function LT(a, b) {\n  return a + EPSILON < b;\n}\n/**\n * Test if A is less than B\n */\n\nexport function EQ(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n/**\n * Clamp the value within the given range\n */\n\nexport function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n}","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\n\nexport class Timeline extends Tone {\n  constructor() {\n    super();\n    this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n\n    this._timeline = [];\n    const options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    this.memory = options.memory;\n    this.increasing = options.increasing;\n  }\n\n  static getDefaults() {\n    return {\n      memory: Infinity,\n      increasing: false\n    };\n  }\n  /**\n   * The number of items in the timeline.\n   */\n\n\n  get length() {\n    return this._timeline.length;\n  }\n  /**\n   * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n   * @param event  The event object to insert into the timeline.\n   */\n\n\n  add(event) {\n    // the event needs to have a time attribute\n    assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n    event.time = event.time.valueOf();\n\n    if (this.increasing && this.length) {\n      const lastValue = this._timeline[this.length - 1];\n      assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\n      this._timeline.push(event);\n    } else {\n      const index = this._search(event.time);\n\n      this._timeline.splice(index + 1, 0, event);\n    } // if the length is more than the memory, remove the previous ones\n\n\n    if (this.length > this.memory) {\n      const diff = this.length - this.memory;\n\n      this._timeline.splice(0, diff);\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  {Object}  event  The event object to remove from the list.\n   * @returns {Timeline} this\n   */\n\n\n  remove(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index !== -1) {\n      this._timeline.splice(index, 1);\n    }\n\n    return this;\n  }\n  /**\n   * Get the nearest event whose time is less than or equal to the given time.\n   * @param  time  The time to query.\n   */\n\n\n  get(time, param = \"time\") {\n    const index = this._search(time, param);\n\n    if (index !== -1) {\n      return this._timeline[index];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Return the first event in the timeline without removing it\n   * @returns {Object} The first event object\n   */\n\n\n  peek() {\n    return this._timeline[0];\n  }\n  /**\n   * Return the first event in the timeline and remove it\n   */\n\n\n  shift() {\n    return this._timeline.shift();\n  }\n  /**\n   * Get the event which is scheduled after the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getAfter(time, param = \"time\") {\n    const index = this._search(time, param);\n\n    if (index + 1 < this._timeline.length) {\n      return this._timeline[index + 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the event before the event at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getBefore(time) {\n    const len = this._timeline.length; // if it's after the last item, return the last item\n\n    if (len > 0 && this._timeline[len - 1].time < time) {\n      return this._timeline[len - 1];\n    }\n\n    const index = this._search(time);\n\n    if (index - 1 >= 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Cancel events at and after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    if (this._timeline.length > 1) {\n      let index = this._search(after);\n\n      if (index >= 0) {\n        if (EQ(this._timeline[index].time, after)) {\n          // get the first item with that time\n          for (let i = index; i >= 0; i--) {\n            if (EQ(this._timeline[i].time, after)) {\n              index = i;\n            } else {\n              break;\n            }\n          }\n\n          this._timeline = this._timeline.slice(0, index);\n        } else {\n          this._timeline = this._timeline.slice(0, index + 1);\n        }\n      } else {\n        this._timeline = [];\n      }\n    } else if (this._timeline.length === 1) {\n      // the first item's time\n      if (GTE(this._timeline[0].time, after)) {\n        this._timeline = [];\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Cancel events before or equal to the given time.\n   * @param  time  The time to cancel before.\n   */\n\n\n  cancelBefore(time) {\n    const index = this._search(time);\n\n    if (index >= 0) {\n      this._timeline = this._timeline.slice(index + 1);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the previous event if there is one. null otherwise\n   * @param  event The event to find the previous one of\n   * @return The event right before the given event\n   */\n\n\n  previousEvent(event) {\n    const index = this._timeline.indexOf(event);\n\n    if (index > 0) {\n      return this._timeline[index - 1];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Does a binary search on the timeline array and returns the\n   * nearest event index whose time is after or equal to the given time.\n   * If a time is searched before the first index in the timeline, -1 is returned.\n   * If the time is after the end, the index of the last item is returned.\n   */\n\n\n  _search(time, param = \"time\") {\n    if (this._timeline.length === 0) {\n      return -1;\n    }\n\n    let beginning = 0;\n    const len = this._timeline.length;\n    let end = len;\n\n    if (len > 0 && this._timeline[len - 1][param] <= time) {\n      return len - 1;\n    }\n\n    while (beginning < end) {\n      // calculate the midpoint for roughly equal partition\n      let midPoint = Math.floor(beginning + (end - beginning) / 2);\n      const event = this._timeline[midPoint];\n      const nextEvent = this._timeline[midPoint + 1];\n\n      if (EQ(event[param], time)) {\n        // choose the last one that has the same time\n        for (let i = midPoint; i < this._timeline.length; i++) {\n          const testEvent = this._timeline[i];\n\n          if (EQ(testEvent[param], time)) {\n            midPoint = i;\n          } else {\n            break;\n          }\n        }\n\n        return midPoint;\n      } else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n        return midPoint;\n      } else if (GT(event[param], time)) {\n        // search lower\n        end = midPoint;\n      } else {\n        // search upper\n        beginning = midPoint + 1;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Internal iterator. Applies extra safety checks for\n   * removing items from the array.\n   */\n\n\n  _iterate(callback, lowerBound = 0, upperBound = this._timeline.length - 1) {\n    this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n  }\n  /**\n   * Iterate over everything in the array\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    this._iterate(callback);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or before the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBefore(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array after the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAfter(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const lowerBound = this._search(time);\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array between the startTime and endTime.\n   * The timerange is inclusive of the startTime, but exclusive of the endTime.\n   * range = [startTime, endTime).\n   * @param  startTime The time to check if items are before\n   * @param  endTime The end of the test interval.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachBetween(startTime, endTime, callback) {\n    let lowerBound = this._search(startTime);\n\n    let upperBound = this._search(endTime);\n\n    if (lowerBound !== -1 && upperBound !== -1) {\n      if (this._timeline[lowerBound].time !== startTime) {\n        lowerBound += 1;\n      } // exclusive of the end time\n\n\n      if (this._timeline[upperBound].time === endTime) {\n        upperBound -= 1;\n      }\n\n      this._iterate(callback, lowerBound, upperBound);\n    } else if (lowerBound === -1) {\n      this._iterate(callback, 0, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at or after the given time. Similar to\n   * forEachAfter, but includes the item(s) at the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    let lowerBound = this._search(time); // work backwards until the event time is less than time\n\n\n    while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n      lowerBound--;\n    }\n\n    this._iterate(callback, lowerBound + 1);\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array at the given time\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    // iterate over the items in reverse so that removing an item doesn't break things\n    const upperBound = this._search(time);\n\n    if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n      let lowerBound = upperBound;\n\n      for (let i = upperBound; i >= 0; i--) {\n        if (EQ(this._timeline[i].time, time)) {\n          lowerBound = i;\n        } else {\n          break;\n        }\n      }\n\n      this._iterate(event => {\n        callback(event);\n      }, lowerBound, upperBound);\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._timeline = [];\n    return this;\n  }\n\n}","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext = [];\n/**\n * Used internally to setup a new Context\n */\n\nexport function onContextInit(cb) {\n  notifyNewContext.push(cb);\n}\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\n\nexport function initializeContext(ctx) {\n  // add any additional modules\n  notifyNewContext.forEach(cb => cb(ctx));\n}\n/**\n * Array of callbacks to invoke when a new context is created\n */\n\nconst notifyCloseContext = [];\n/**\n * Used internally to tear down a Context\n */\n\nexport function onContextClose(cb) {\n  notifyCloseContext.push(cb);\n}\nexport function closeContext(ctx) {\n  // add any additional modules\n  notifyCloseContext.forEach(cb => cb(ctx));\n}","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\n\nexport class Emitter extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"Emitter\";\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  on(event, callback) {\n    // split the event\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (!this._events.hasOwnProperty(eventName)) {\n        this._events[eventName] = [];\n      }\n\n      this._events[eventName].push(callback);\n    });\n    return this;\n  }\n  /**\n   * Bind a callback which is only invoked once\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  once(event, callback) {\n    const boundCallback = (...args) => {\n      // invoke the callback\n      callback(...args); // remove the event\n\n      this.off(event, boundCallback);\n    };\n\n    this.on(event, boundCallback);\n    return this;\n  }\n  /**\n   * Remove the event listener.\n   * @param  event     The event to stop listening to.\n   * @param  callback  The callback which was bound to the event with Emitter.on.\n   *                   If no callback is given, all callbacks events are removed.\n   */\n\n\n  off(event, callback) {\n    const events = event.split(/\\W+/);\n    events.forEach(eventName => {\n      if (isUndef(this._events)) {\n        this._events = {};\n      }\n\n      if (this._events.hasOwnProperty(event)) {\n        if (isUndef(callback)) {\n          this._events[event] = [];\n        } else {\n          const eventList = this._events[event];\n\n          for (let i = 0; i < eventList.length; i++) {\n            if (eventList[i] === callback) {\n              eventList.splice(i, 1);\n            }\n          }\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Invoke all of the callbacks bound to the event\n   * with any arguments passed in.\n   * @param  event  The name of the event.\n   * @param args The arguments to pass to the functions listening.\n   */\n\n\n  emit(event, ...args) {\n    if (this._events) {\n      if (this._events.hasOwnProperty(event)) {\n        const eventList = this._events[event].slice(0);\n\n        for (let i = 0, len = eventList.length; i < len; i++) {\n          eventList[i].apply(this, args);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Add Emitter functions (on/off/emit) to the object\n   */\n\n\n  static mixin(constr) {\n    // instance._events = {};\n    [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n      const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n      Object.defineProperty(constr.prototype, name, property);\n    });\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._events = undefined;\n    return this;\n  }\n\n}","import { Emitter } from \"../util/Emitter\";\nexport class BaseContext extends Emitter {\n  constructor() {\n    super(...arguments);\n    this.isOffline = false;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nexport class Context extends BaseContext {\n  constructor() {\n    super();\n    this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    this._workletModules = new Map();\n    const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      this._context = options.context;\n    } else {\n      this._context = createAudioContext();\n    }\n\n    this._latencyHint = options.latencyHint;\n    this.lookAhead = options.lookAhead;\n    this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n    this.on(\"tick\", this._timeoutLoop.bind(this)); // fwd events from the context\n\n    this._context.onstatechange = () => {\n      this.emit(\"statechange\", this.state);\n    };\n  }\n\n  static getDefaults() {\n    return {\n      clockSource: \"worker\",\n      latencyHint: \"interactive\",\n      lookAhead: 0.1,\n      updateInterval: 0.05\n    };\n  }\n  /**\n   * Finish setting up the context. **You usually do not need to do this manually.**\n   */\n\n\n  initialize() {\n    if (!this._initialized) {\n      // add any additional modules\n      initializeContext(this);\n      this._initialized = true;\n    }\n\n    return this;\n  } //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAnalyser() {\n    return this._context.createAnalyser();\n  }\n\n  createOscillator() {\n    return this._context.createOscillator();\n  }\n\n  createBufferSource() {\n    return this._context.createBufferSource();\n  }\n\n  createBiquadFilter() {\n    return this._context.createBiquadFilter();\n  }\n\n  createBuffer(numberOfChannels, length, sampleRate) {\n    return this._context.createBuffer(numberOfChannels, length, sampleRate);\n  }\n\n  createChannelMerger(numberOfInputs) {\n    return this._context.createChannelMerger(numberOfInputs);\n  }\n\n  createChannelSplitter(numberOfOutputs) {\n    return this._context.createChannelSplitter(numberOfOutputs);\n  }\n\n  createConstantSource() {\n    return this._context.createConstantSource();\n  }\n\n  createConvolver() {\n    return this._context.createConvolver();\n  }\n\n  createDelay(maxDelayTime) {\n    return this._context.createDelay(maxDelayTime);\n  }\n\n  createDynamicsCompressor() {\n    return this._context.createDynamicsCompressor();\n  }\n\n  createGain() {\n    return this._context.createGain();\n  }\n\n  createIIRFilter(feedForward, feedback) {\n    // @ts-ignore\n    return this._context.createIIRFilter(feedForward, feedback);\n  }\n\n  createPanner() {\n    return this._context.createPanner();\n  }\n\n  createPeriodicWave(real, imag, constraints) {\n    return this._context.createPeriodicWave(real, imag, constraints);\n  }\n\n  createStereoPanner() {\n    return this._context.createStereoPanner();\n  }\n\n  createWaveShaper() {\n    return this._context.createWaveShaper();\n  }\n\n  createMediaStreamSource(stream) {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamSource(stream);\n  }\n\n  createMediaStreamDestination() {\n    assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n    const context = this._context;\n    return context.createMediaStreamDestination();\n  }\n\n  decodeAudioData(audioData) {\n    return this._context.decodeAudioData(audioData);\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get currentTime() {\n    return this._context.currentTime;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get state() {\n    return this._context.state;\n  }\n  /**\n   * The current time in seconds of the AudioContext.\n   */\n\n\n  get sampleRate() {\n    return this._context.sampleRate;\n  }\n  /**\n   * The listener\n   */\n\n\n  get listener() {\n    this.initialize();\n    return this._listener;\n  }\n\n  set listener(l) {\n    assert(!this._initialized, \"The listener cannot be set after initialization.\");\n    this._listener = l;\n  }\n  /**\n   * There is only one Transport per Context. It is created on initialization.\n   */\n\n\n  get transport() {\n    this.initialize();\n    return this._transport;\n  }\n\n  set transport(t) {\n    assert(!this._initialized, \"The transport cannot be set after initialization.\");\n    this._transport = t;\n  }\n  /**\n   * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n   */\n\n\n  get draw() {\n    this.initialize();\n    return this._draw;\n  }\n\n  set draw(d) {\n    assert(!this._initialized, \"Draw cannot be set after initialization.\");\n    this._draw = d;\n  }\n  /**\n   * A reference to the Context's destination node.\n   */\n\n\n  get destination() {\n    this.initialize();\n    return this._destination;\n  }\n\n  set destination(d) {\n    assert(!this._initialized, \"The destination cannot be set after initialization.\");\n    this._destination = d;\n  }\n  /**\n   * Create an audio worklet node from a name and options. The module\n   * must first be loaded using [[addAudioWorkletModule]].\n   */\n\n\n  createAudioWorkletNode(name, options) {\n    return createAudioWorkletNode(this.rawContext, name, options);\n  }\n  /**\n   * Add an AudioWorkletProcessor module\n   * @param url The url of the module\n   * @param name The name of the module\n   */\n\n\n  addAudioWorkletModule(url, name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n      if (!this._workletModules.has(name)) {\n        this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n      }\n\n      yield this._workletModules.get(name);\n    });\n  }\n  /**\n   * Returns a promise which resolves when all of the worklets have been loaded on this context\n   */\n\n\n  workletsAreReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = [];\n\n      this._workletModules.forEach(promise => promises.push(promise));\n\n      yield Promise.all(promises);\n    });\n  } //---------------------------\n  // TICKER\n  //---------------------------\n\n  /**\n   * How often the interval callback is invoked.\n   * This number corresponds to how responsive the scheduling\n   * can be. context.updateInterval + context.lookAhead gives you the\n   * total latency between scheduling an event and hearing it.\n   */\n\n\n  get updateInterval() {\n    return this._ticker.updateInterval;\n  }\n\n  set updateInterval(interval) {\n    this._ticker.updateInterval = interval;\n  }\n  /**\n   * What the source of the clock is, either \"worker\" (default),\n   * \"timeout\", or \"offline\" (none).\n   */\n\n\n  get clockSource() {\n    return this._ticker.type;\n  }\n\n  set clockSource(type) {\n    this._ticker.type = type;\n  }\n  /**\n   * The type of playback, which affects tradeoffs between audio\n   * output latency and responsiveness.\n   * In addition to setting the value in seconds, the latencyHint also\n   * accepts the strings \"interactive\" (prioritizes low latency),\n   * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n   * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n   * @example\n   * // set the latencyHint to prioritize smooth playback at the expensive of latency\n   * Tone.context.latencyHint = \"playback\";\n   */\n\n\n  get latencyHint() {\n    return this._latencyHint;\n  }\n\n  set latencyHint(hint) {\n    let lookAheadValue = 0;\n    this._latencyHint = hint;\n\n    if (isString(hint)) {\n      switch (hint) {\n        case \"interactive\":\n          lookAheadValue = 0.1;\n          break;\n\n        case \"playback\":\n          lookAheadValue = 0.8;\n          break;\n\n        case \"balanced\":\n          lookAheadValue = 0.25;\n          break;\n\n        case \"fastest\":\n          lookAheadValue = 0.01;\n          break;\n      }\n    }\n\n    this.lookAhead = lookAheadValue;\n    this.updateInterval = lookAheadValue / 2;\n  }\n  /**\n   * The unwrapped AudioContext.\n   */\n\n\n  get rawContext() {\n    return this._context;\n  }\n  /**\n   * The current audio context time plus a short [[lookAhead]].\n   */\n\n\n  now() {\n    return this._context.currentTime + this.lookAhead;\n  }\n  /**\n   * The current audio context time without the [[lookAhead]].\n   * In most cases it is better to use [[now]] instead of [[immediate]] since\n   * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n   * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n   * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n   */\n\n\n  immediate() {\n    return this._context.currentTime;\n  }\n  /**\n   * Starts the audio context from a suspended state. This is required\n   * to initially start the AudioContext.\n   */\n\n\n  resume() {\n    if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n      return this._context.resume();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  /**\n   * Promise which is invoked when the context is running.\n   * Tries to resume the context if it's not started.\n   */\n\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isAudioContext(this._context)) {\n        yield this._context.close();\n      }\n\n      if (this._initialized) {\n        closeContext(this);\n      }\n    });\n  }\n  /**\n   * Generate a looped buffer at some constant value.\n   */\n\n\n  getConstant(val) {\n    if (this._constants.has(val)) {\n      return this._constants.get(val);\n    } else {\n      const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n      const arr = buffer.getChannelData(0);\n\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = val;\n      }\n\n      const constant = this._context.createBufferSource();\n\n      constant.channelCount = 1;\n      constant.channelCountMode = \"explicit\";\n      constant.buffer = buffer;\n      constant.loop = true;\n      constant.start(0);\n\n      this._constants.set(val, constant);\n\n      return constant;\n    }\n  }\n  /**\n   * Clean up. Also closes the audio context.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._ticker.dispose();\n\n    this._timeouts.dispose();\n\n    Object.keys(this._constants).map(val => this._constants[val].disconnect());\n    return this;\n  } //---------------------------\n  // TIMEOUTS\n  //---------------------------\n\n  /**\n   * The private loop which keeps track of the context scheduled timeouts\n   * Is invoked from the clock source\n   */\n\n\n  _timeoutLoop() {\n    const now = this.now();\n\n    let firstEvent = this._timeouts.peek();\n\n    while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n      // invoke the callback\n      firstEvent.callback(); // shift the first event off\n\n      this._timeouts.shift(); // get the next one\n\n\n      firstEvent = this._timeouts.peek();\n    }\n  }\n  /**\n   * A setTimeout which is guaranteed by the clock source.\n   * Also runs in the offline context.\n   * @param  fn       The callback to invoke\n   * @param  timeout  The timeout in seconds\n   * @returns ID to use when invoking Context.clearTimeout\n   */\n\n\n  setTimeout(fn, timeout) {\n    this._timeoutIds++;\n    const now = this.now();\n\n    this._timeouts.add({\n      callback: fn,\n      id: this._timeoutIds,\n      time: now + timeout\n    });\n\n    return this._timeoutIds;\n  }\n  /**\n   * Clears a previously scheduled timeout with Tone.context.setTimeout\n   * @param  id  The ID returned from setTimeout\n   */\n\n\n  clearTimeout(id) {\n    this._timeouts.forEach(event => {\n      if (event.id === id) {\n        this._timeouts.remove(event);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Clear the function scheduled by [[setInterval]]\n   */\n\n\n  clearInterval(id) {\n    return this.clearTimeout(id);\n  }\n  /**\n   * Adds a repeating event to the context's callback clock\n   */\n\n\n  setInterval(fn, interval) {\n    const id = ++this._timeoutIds;\n\n    const intervalFn = () => {\n      const now = this.now();\n\n      this._timeouts.add({\n        callback: () => {\n          // invoke the callback\n          fn(); // invoke the event to repeat it\n\n          intervalFn();\n        },\n        id,\n        time: now + interval\n      });\n    }; // kick it off\n\n\n    intervalFn();\n    return id;\n  }\n\n}","import { isArray } from \"./TypeCheck\";\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\n\nexport function readOnly(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => readOnly(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      enumerable: true,\n      writable: false\n    });\n  }\n}\n/**\n * Make an attribute writeable. Internal use only.\n */\n\nexport function writable(target, property) {\n  if (isArray(property)) {\n    property.forEach(str => writable(target, str));\n  } else {\n    Object.defineProperty(target, property, {\n      writable: true\n    });\n  }\n}\nexport const noOp = () => {// no operation here!\n};","import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport class ToneAudioBuffer extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    this.onload = noOp;\n    const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    this.reverse = options.reverse;\n    this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      this.load(options.url).catch(options.onerror);\n    }\n  }\n\n  static getDefaults() {\n    return {\n      onerror: noOp,\n      onload: noOp,\n      reverse: false\n    };\n  }\n  /**\n   * The sample rate of the AudioBuffer\n   */\n\n\n  get sampleRate() {\n    if (this._buffer) {\n      return this._buffer.sampleRate;\n    } else {\n      return getContext().sampleRate;\n    }\n  }\n  /**\n   * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n   */\n\n\n  set(buffer) {\n    if (buffer instanceof ToneAudioBuffer) {\n      // if it's loaded, set it\n      if (buffer.loaded) {\n        this._buffer = buffer.get();\n      } else {\n        // otherwise when it's loaded, invoke it's callback\n        buffer.onload = () => {\n          this.set(buffer);\n          this.onload(this);\n        };\n      }\n    } else {\n      this._buffer = buffer;\n    } // reverse it initially\n\n\n    if (this._reversed) {\n      this._reverse();\n    }\n\n    return this;\n  }\n  /**\n   * The audio buffer stored in the object.\n   */\n\n\n  get() {\n    return this._buffer;\n  }\n  /**\n   * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n   * Invokes the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   * @returns A Promise which resolves with this ToneAudioBuffer\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n        this.set(audioBuffer); // invoke the onload method\n\n        this.onload(this);\n      });\n      ToneAudioBuffer.downloads.push(doneLoading);\n\n      try {\n        yield doneLoading;\n      } finally {\n        // remove the downloaded file\n        const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n        ToneAudioBuffer.downloads.splice(index, 1);\n      }\n\n      return this;\n    });\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._buffer = undefined;\n    return this;\n  }\n  /**\n   * Set the audio buffer from the array.\n   * To create a multichannel AudioBuffer, pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   */\n\n\n  fromArray(array) {\n    const isMultidimensional = isArray(array) && array[0].length > 0;\n    const channels = isMultidimensional ? array.length : 1;\n    const len = isMultidimensional ? array[0].length : array.length;\n    const context = getContext();\n    const buffer = context.createBuffer(channels, len, context.sampleRate);\n    const multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n    for (let c = 0; c < channels; c++) {\n      buffer.copyToChannel(multiChannelArray[c], c);\n    }\n\n    this._buffer = buffer;\n    return this;\n  }\n  /**\n   * Sums multiple channels into 1 channel\n   * @param chanNum Optionally only copy a single channel from the array.\n   */\n\n\n  toMono(chanNum) {\n    if (isNumber(chanNum)) {\n      this.fromArray(this.toArray(chanNum));\n    } else {\n      let outputArray = new Float32Array(this.length);\n      const numChannels = this.numberOfChannels;\n\n      for (let channel = 0; channel < numChannels; channel++) {\n        const channelArray = this.toArray(channel);\n\n        for (let i = 0; i < channelArray.length; i++) {\n          outputArray[i] += channelArray[i];\n        }\n      } // divide by the number of channels\n\n\n      outputArray = outputArray.map(sample => sample / numChannels);\n      this.fromArray(outputArray);\n    }\n\n    return this;\n  }\n  /**\n   * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n   * Float32Array, and multichannel buffers will return multidimensional arrays.\n   * @param channel Optionally only copy a single channel from the array.\n   */\n\n\n  toArray(channel) {\n    if (isNumber(channel)) {\n      return this.getChannelData(channel);\n    } else if (this.numberOfChannels === 1) {\n      return this.toArray(0);\n    } else {\n      const ret = [];\n\n      for (let c = 0; c < this.numberOfChannels; c++) {\n        ret[c] = this.getChannelData(c);\n      }\n\n      return ret;\n    }\n  }\n  /**\n   * Returns the Float32Array representing the PCM audio data for the specific channel.\n   * @param  channel  The channel number to return\n   * @return The audio as a TypedArray\n   */\n\n\n  getChannelData(channel) {\n    if (this._buffer) {\n      return this._buffer.getChannelData(channel);\n    } else {\n      return new Float32Array(0);\n    }\n  }\n  /**\n   * Cut a subsection of the array and return a buffer of the\n   * subsection. Does not modify the original buffer\n   * @param start The time to start the slice\n   * @param end The end time to slice. If none is given will default to the end of the buffer\n   */\n\n\n  slice(start, end = this.duration) {\n    const startSamples = Math.floor(start * this.sampleRate);\n    const endSamples = Math.floor(end * this.sampleRate);\n    assert(startSamples < endSamples, \"The start time must be less than the end time\");\n    const length = endSamples - startSamples;\n    const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n    for (let channel = 0; channel < this.numberOfChannels; channel++) {\n      retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n    }\n\n    return new ToneAudioBuffer(retBuffer);\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  _reverse() {\n    if (this.loaded) {\n      for (let i = 0; i < this.numberOfChannels; i++) {\n        this.getChannelData(i).reverse();\n      }\n    }\n\n    return this;\n  }\n  /**\n   * If the buffer is loaded or not\n   */\n\n\n  get loaded() {\n    return this.length > 0;\n  }\n  /**\n   * The duration of the buffer in seconds.\n   */\n\n\n  get duration() {\n    if (this._buffer) {\n      return this._buffer.duration;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The length of the buffer in samples\n   */\n\n\n  get length() {\n    if (this._buffer) {\n      return this._buffer.length;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n   */\n\n\n  get numberOfChannels() {\n    if (this._buffer) {\n      return this._buffer.numberOfChannels;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Reverse the buffer.\n   */\n\n\n  get reverse() {\n    return this._reversed;\n  }\n\n  set reverse(rev) {\n    if (this._reversed !== rev) {\n      this._reversed = rev;\n\n      this._reverse();\n    }\n  }\n  /**\n   * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n   * pass in a multidimensional array.\n   * @param array The array to fill the audio buffer\n   * @return A ToneAudioBuffer created from the array\n   */\n\n\n  static fromArray(array) {\n    return new ToneAudioBuffer().fromArray(array);\n  }\n  /**\n   * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n   * @param  url The url to load.\n   * @return A promise which resolves to a ToneAudioBuffer\n   */\n\n\n  static fromUrl(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const buffer = new ToneAudioBuffer();\n      return yield buffer.load(url);\n    });\n  }\n  /**\n   * Loads a url using fetch and returns the AudioBuffer.\n   */\n\n\n  static load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // test if the url contains multiple extensions\n      const matches = url.match(/\\[(.+\\|?)+\\]$/);\n\n      if (matches) {\n        const extensions = matches[1].split(\"|\");\n        let extension = extensions[0];\n\n        for (const ext of extensions) {\n          if (ToneAudioBuffer.supportsType(ext)) {\n            extension = ext;\n            break;\n          }\n        }\n\n        url = url.replace(matches[0], extension);\n      } // make sure there is a slash between the baseUrl and the url\n\n\n      const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n      const response = yield fetch(baseUrl + url);\n\n      if (!response.ok) {\n        throw new Error(`could not load url: ${url}`);\n      }\n\n      const arrayBuffer = yield response.arrayBuffer();\n      const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n      return audioBuffer;\n    });\n  }\n  /**\n   * Checks a url's extension to see if the current browser can play that file type.\n   * @param url The url/extension to test\n   * @return If the file extension can be played\n   * @static\n   * @example\n   * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n   * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n   */\n\n\n  static supportsType(url) {\n    const extensions = url.split(\".\");\n    const extension = extensions[extensions.length - 1];\n    const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n    return response !== \"\";\n  }\n  /**\n   * Returns a Promise which resolves when all of the buffers have loaded\n   */\n\n\n  static loaded() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // this makes sure that the function is always async\n      yield Promise.resolve();\n\n      while (ToneAudioBuffer.downloads.length) {\n        yield ToneAudioBuffer.downloads[0];\n      }\n    });\n  }\n\n} //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport class OfflineContext extends Context {\n  constructor() {\n    super({\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    this._currentTime = 0;\n    this.isOffline = true;\n    this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  now() {\n    return this._currentTime;\n  }\n  /**\n   * Same as this.now()\n   */\n\n\n  get currentTime() {\n    return this._currentTime;\n  }\n  /**\n   * Render just the clock portion of the audio context.\n   */\n\n\n  _renderClock(asynchronous) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let index = 0;\n\n      while (this._duration - this._currentTime >= 0) {\n        // invoke all the callbacks on that time\n        this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n        this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n        index++;\n        const yieldEvery = Math.floor(this.sampleRate / 128);\n\n        if (asynchronous && index % yieldEvery === 0) {\n          yield new Promise(done => setTimeout(done, 1));\n        }\n      }\n    });\n  }\n  /**\n   * Render the output of the OfflineContext\n   * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n   */\n\n\n  render(asynchronous = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.workletsAreReady();\n      yield this._renderClock(asynchronous);\n      const buffer = yield this._context.startRendering();\n      return new ToneAudioBuffer(buffer);\n    });\n  }\n  /**\n   * Close the context\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n\n}","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\n\nconst dummyContext = new DummyContext();\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\n\nlet globalContext = dummyContext;\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\n\nexport function getContext() {\n  if (globalContext === dummyContext && hasAudioContext) {\n    setContext(new Context());\n  }\n\n  return globalContext;\n}\n/**\n * Set the default audio context\n * @category Core\n */\n\nexport function setContext(context) {\n  if (isAudioContext(context)) {\n    globalContext = new Context(context);\n  } else if (isOfflineAudioContext(context)) {\n    globalContext = new OfflineContext(context);\n  } else {\n    globalContext = context;\n  }\n}\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\n\nexport function start() {\n  return globalContext.resume();\n}\n/**\n * Log Tone.js + version in the console.\n */\n\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n  let prefix = \"v\";\n\n  if (version === \"dev\") {\n    prefix = \"\";\n  }\n\n  const printString = ` * Tone.js ${prefix}${version} * `; // eslint-disable-next-line no-console\n\n  console.log(`%c${printString}`, \"background: #000; color: #fff\");\n}","import { __awaiter } from \"tslib\";\nimport { BaseContext } from \"./BaseContext\";\nexport class DummyContext extends BaseContext {\n  constructor() {\n    super(...arguments);\n    this.lookAhead = 0;\n    this.latencyHint = 0;\n    this.isOffline = false;\n  } //---------------------------\n  // BASE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAnalyser() {\n    return {};\n  }\n\n  createOscillator() {\n    return {};\n  }\n\n  createBufferSource() {\n    return {};\n  }\n\n  createBiquadFilter() {\n    return {};\n  }\n\n  createBuffer(_numberOfChannels, _length, _sampleRate) {\n    return {};\n  }\n\n  createChannelMerger(_numberOfInputs) {\n    return {};\n  }\n\n  createChannelSplitter(_numberOfOutputs) {\n    return {};\n  }\n\n  createConstantSource() {\n    return {};\n  }\n\n  createConvolver() {\n    return {};\n  }\n\n  createDelay(_maxDelayTime) {\n    return {};\n  }\n\n  createDynamicsCompressor() {\n    return {};\n  }\n\n  createGain() {\n    return {};\n  }\n\n  createIIRFilter(_feedForward, _feedback) {\n    return {};\n  }\n\n  createPanner() {\n    return {};\n  }\n\n  createPeriodicWave(_real, _imag, _constraints) {\n    return {};\n  }\n\n  createStereoPanner() {\n    return {};\n  }\n\n  createWaveShaper() {\n    return {};\n  }\n\n  createMediaStreamSource(_stream) {\n    return {};\n  }\n\n  createMediaStreamDestination() {\n    return {};\n  }\n\n  decodeAudioData(_audioData) {\n    return Promise.resolve({});\n  } //---------------------------\n  // TONE AUDIO CONTEXT METHODS\n  //---------------------------\n\n\n  createAudioWorkletNode(_name, _options) {\n    return {};\n  }\n\n  get rawContext() {\n    return {};\n  }\n\n  addAudioWorkletModule(_url, _name) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve();\n    });\n  }\n\n  resume() {\n    return Promise.resolve();\n  }\n\n  setTimeout(_fn, _timeout) {\n    return 0;\n  }\n\n  clearTimeout(_id) {\n    return this;\n  }\n\n  setInterval(_fn, _interval) {\n    return 0;\n  }\n\n  clearInterval(_id) {\n    return this;\n  }\n\n  getConstant(_val) {\n    return {};\n  }\n\n  get currentTime() {\n    return 0;\n  }\n\n  get state() {\n    return {};\n  }\n\n  get sampleRate() {\n    return 0;\n  }\n\n  get listener() {\n    return {};\n  }\n\n  get transport() {\n    return {};\n  }\n\n  get draw() {\n    return {};\n  }\n\n  set draw(_d) {}\n\n  get destination() {\n    return {};\n  }\n\n  set destination(_d) {}\n\n  now() {\n    return 0;\n  }\n\n  immediate() {\n    return 0;\n  }\n\n}","/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent) {\n  const piFactor = 0.5 * Math.PI;\n  return Math.sin(percent * piFactor);\n}\n/**\n * Convert decibels into gain.\n */\n\nexport function dbToGain(db) {\n  return Math.pow(10, db / 20);\n}\n/**\n * Convert gain to decibels.\n */\n\nexport function gainToDb(gain) {\n  return 20 * (Math.log(gain) / Math.LN10);\n}\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\n\nexport function intervalToFrequencyRatio(interval) {\n  return Math.pow(2, interval / 12);\n}\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\n\nlet A4 = 440;\nexport function getA4() {\n  return A4;\n}\nexport function setA4(freq) {\n  A4 = freq;\n}\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\n\nexport function ftom(frequency) {\n  return Math.round(ftomf(frequency));\n}\n/**\n * Convert a frequency to a floating point midi value\n */\n\nexport function ftomf(frequency) {\n  return 69 + 12 * Math.log2(frequency / A4);\n}\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\n\nexport function mtof(midi) {\n  return A4 * Math.pow(2, (midi - 69) / 12);\n}","import { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\n\nexport class TimeBaseClass extends Tone {\n  /**\n   * @param context The context associated with the time value. Used to compute\n   * Transport and context-relative timing.\n   * @param  value  The time value as a number, string or object\n   * @param  units  Unit values\n   */\n  constructor(context, value, units) {\n    super();\n    /**\n     * The default units\n     */\n\n    this.defaultUnits = \"s\";\n    this._val = value;\n    this._units = units;\n    this.context = context;\n    this._expressions = this._getExpressions();\n  }\n  /**\n   * All of the time encoding expressions\n   */\n\n\n  _getExpressions() {\n    return {\n      hz: {\n        method: value => {\n          return this._frequencyToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)hz$/i\n      },\n      i: {\n        method: value => {\n          return this._ticksToUnits(parseInt(value, 10));\n        },\n        regexp: /^(\\d+)i$/i\n      },\n      m: {\n        method: value => {\n          return this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n        },\n        regexp: /^(\\d+)m$/i\n      },\n      n: {\n        method: (value, dot) => {\n          const numericValue = parseInt(value, 10);\n          const scalar = dot === \".\" ? 1.5 : 1;\n\n          if (numericValue === 1) {\n            return this._beatsToUnits(this._getTimeSignature()) * scalar;\n          } else {\n            return this._beatsToUnits(4 / numericValue) * scalar;\n          }\n        },\n        regexp: /^(\\d+)n(\\.?)$/i\n      },\n      number: {\n        method: value => {\n          return this._expressions[this.defaultUnits].method.call(this, value);\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)$/\n      },\n      s: {\n        method: value => {\n          return this._secondsToUnits(parseFloat(value));\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?)s$/\n      },\n      samples: {\n        method: value => {\n          return parseInt(value, 10) / this.context.sampleRate;\n        },\n        regexp: /^(\\d+)samples$/\n      },\n      t: {\n        method: value => {\n          const numericValue = parseInt(value, 10);\n          return this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n        },\n        regexp: /^(\\d+)t$/i\n      },\n      tr: {\n        method: (m, q, s) => {\n          let total = 0;\n\n          if (m && m !== \"0\") {\n            total += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total += this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total += this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        },\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/\n      }\n    };\n  } //-------------------------------------\n  // \tVALUE OF\n  //-------------------------------------\n\n  /**\n   * Evaluate the time value. Returns the time in seconds.\n   */\n\n\n  valueOf() {\n    if (this._val instanceof TimeBaseClass) {\n      this.fromType(this._val);\n    }\n\n    if (isUndef(this._val)) {\n      return this._noArg();\n    } else if (isString(this._val) && isUndef(this._units)) {\n      for (const units in this._expressions) {\n        if (this._expressions[units].regexp.test(this._val.trim())) {\n          this._units = units;\n          break;\n        }\n      }\n    } else if (isObject(this._val)) {\n      let total = 0;\n\n      for (const typeName in this._val) {\n        if (isDefined(this._val[typeName])) {\n          const quantity = this._val[typeName]; // @ts-ignore\n\n          const time = new this.constructor(this.context, typeName).valueOf() * quantity;\n          total += time;\n        }\n      }\n\n      return total;\n    }\n\n    if (isDefined(this._units)) {\n      const expr = this._expressions[this._units];\n\n      const matching = this._val.toString().trim().match(expr.regexp);\n\n      if (matching) {\n        return expr.method.apply(this, matching.slice(1));\n      } else {\n        return expr.method.call(this, this._val);\n      }\n    } else if (isString(this._val)) {\n      return parseFloat(this._val);\n    } else {\n      return this._val;\n    }\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return 1 / freq;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 60 / this._getBpm() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return seconds;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks * this._beatsToUnits(1) / this._getPPQ();\n  }\n  /**\n   * With no arguments, return 'now'\n   */\n\n\n  _noArg() {\n    return this._now();\n  } //-------------------------------------\n  // \tTEMPO CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the bpm\n   */\n\n\n  _getBpm() {\n    return this.context.transport.bpm.value;\n  }\n  /**\n   * Return the timeSignature\n   */\n\n\n  _getTimeSignature() {\n    return this.context.transport.timeSignature;\n  }\n  /**\n   * Return the PPQ or 192 if Transport is not available\n   */\n\n\n  _getPPQ() {\n    return this.context.transport.PPQ;\n  } //-------------------------------------\n  // \tCONVERSION INTERFACE\n  //-------------------------------------\n\n  /**\n   * Coerce a time type into this units type.\n   * @param type Any time type units\n   */\n\n\n  fromType(type) {\n    this._units = undefined;\n\n    switch (this.defaultUnits) {\n      case \"s\":\n        this._val = type.toSeconds();\n        break;\n\n      case \"i\":\n        this._val = type.toTicks();\n        break;\n\n      case \"hz\":\n        this._val = type.toFrequency();\n        break;\n\n      case \"midi\":\n        this._val = type.toMidi();\n        break;\n    }\n\n    return this;\n  }\n  /**\n   * Return the value in hertz\n   */\n\n\n  toFrequency() {\n    return 1 / this.toSeconds();\n  }\n  /**\n   * Return the time in samples\n   */\n\n\n  toSamples() {\n    return this.toSeconds() * this.context.sampleRate;\n  }\n  /**\n   * Return the time in milliseconds.\n   */\n\n\n  toMilliseconds() {\n    return this.toSeconds() * 1000;\n  }\n\n}","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\n\nexport class TimeClass extends TimeBaseClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"TimeClass\";\n  }\n\n  _getExpressions() {\n    return Object.assign(super._getExpressions(), {\n      now: {\n        method: capture => {\n          return this._now() + new this.constructor(this.context, capture).valueOf();\n        },\n        regexp: /^\\+(.+)/\n      },\n      quantize: {\n        method: capture => {\n          const quantTo = new TimeClass(this.context, capture).valueOf();\n          return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n        },\n        regexp: /^@(.+)/\n      }\n    });\n  }\n  /**\n   * Quantize the time by the given subdivision. Optionally add a\n   * percentage which will move the time value towards the ideal\n   * quantized value by that percentage.\n   * @param  subdiv    The subdivision to quantize to\n   * @param  percent  Move the time value towards the quantized value by a percentage.\n   * @example\n   * Tone.Time(21).quantize(2); // returns 22\n   * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n   */\n\n\n  quantize(subdiv, percent = 1) {\n    const subdivision = new this.constructor(this.context, subdiv).valueOf();\n    const value = this.valueOf();\n    const multiple = Math.round(value / subdivision);\n    const ideal = multiple * subdivision;\n    const diff = ideal - value;\n    return value + diff * percent;\n  } //-------------------------------------\n  // CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Convert a Time to Notation. The notation values are will be the\n   * closest representation between 1m to 128th note.\n   * @return {Notation}\n   * @example\n   * // if the Transport is at 120bpm:\n   * Tone.Time(2).toNotation(); // returns \"1m\"\n   */\n\n\n  toNotation() {\n    const time = this.toSeconds();\n    const testNotations = [\"1m\"];\n\n    for (let power = 1; power < 9; power++) {\n      const subdiv = Math.pow(2, power);\n      testNotations.push(subdiv + \"n.\");\n      testNotations.push(subdiv + \"n\");\n      testNotations.push(subdiv + \"t\");\n    }\n\n    testNotations.push(\"0\"); // find the closets notation representation\n\n    let closest = testNotations[0];\n    let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n    testNotations.forEach(notation => {\n      const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\n      if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n        closest = notation;\n        closestSeconds = notationSeconds;\n      }\n    });\n    return closest;\n  }\n  /**\n   * Return the time encoded as Bars:Beats:Sixteenths.\n   */\n\n\n  toBarsBeatsSixteenths() {\n    const quarterTime = this._beatsToUnits(1);\n\n    let quarters = this.valueOf() / quarterTime;\n    quarters = parseFloat(quarters.toFixed(4));\n    const measures = Math.floor(quarters / this._getTimeSignature());\n    let sixteenths = quarters % 1 * 4;\n    quarters = Math.floor(quarters) % this._getTimeSignature();\n    const sixteenthString = sixteenths.toString();\n\n    if (sixteenthString.length > 3) {\n      // the additional parseFloat removes insignificant trailing zeroes\n      sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n    }\n\n    const progress = [measures, quarters, sixteenths];\n    return progress.join(\":\");\n  }\n  /**\n   * Return the time in ticks.\n   */\n\n\n  toTicks() {\n    const quarterTime = this._beatsToUnits(1);\n\n    const quarters = this.valueOf() / quarterTime;\n    return Math.round(quarters * this._getPPQ());\n  }\n  /**\n   * Return the time in seconds.\n   */\n\n\n  toSeconds() {\n    return this.valueOf();\n  }\n  /**\n   * Return the value as a midi note.\n   */\n\n\n  toMidi() {\n    return ftom(this.toFrequency());\n  }\n\n  _now() {\n    return this.context.now();\n  }\n\n}\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n */\n\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\n\nexport class FrequencyClass extends TimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"Frequency\";\n    this.defaultUnits = \"hz\";\n  }\n  /**\n   * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n   * to generate all the other pitch values from notes. A4's values in Hertz.\n   */\n\n\n  static get A4() {\n    return getA4();\n  }\n\n  static set A4(freq) {\n    setA4(freq);\n  } //-------------------------------------\n  // \tAUGMENT BASE EXPRESSIONS\n  //-------------------------------------\n\n\n  _getExpressions() {\n    return Object.assign({}, super._getExpressions(), {\n      midi: {\n        regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\n        method(value) {\n          if (this.defaultUnits === \"midi\") {\n            return value;\n          } else {\n            return FrequencyClass.mtof(value);\n          }\n        }\n\n      },\n      note: {\n        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\n        method(pitch, octave) {\n          const index = noteToScaleIndex[pitch.toLowerCase()];\n          const noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\n          if (this.defaultUnits === \"midi\") {\n            return noteNumber;\n          } else {\n            return FrequencyClass.mtof(noteNumber);\n          }\n        }\n\n      },\n      tr: {\n        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\n        method(m, q, s) {\n          let total = 1;\n\n          if (m && m !== \"0\") {\n            total *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n          }\n\n          if (q && q !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(q));\n          }\n\n          if (s && s !== \"0\") {\n            total *= this._beatsToUnits(parseFloat(s) / 4);\n          }\n\n          return total;\n        }\n\n      }\n    });\n  } //-------------------------------------\n  // \tEXPRESSIONS\n  //-------------------------------------\n\n  /**\n   * Transposes the frequency by the given number of semitones.\n   * @return  A new transposed frequency\n   * @example\n   * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n   */\n\n\n  transpose(interval) {\n    return new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n  }\n  /**\n   * Takes an array of semitone intervals and returns\n   * an array of frequencies transposed by those intervals.\n   * @return  Returns an array of Frequencies\n   * @example\n   * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n   */\n\n\n  harmonize(intervals) {\n    return intervals.map(interval => {\n      return this.transpose(interval);\n    });\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS\n  //-------------------------------------\n\n  /**\n   * Return the value of the frequency as a MIDI note\n   * @example\n   * Tone.Frequency(\"C4\").toMidi(); // 60\n   */\n\n\n  toMidi() {\n    return ftom(this.valueOf());\n  }\n  /**\n   * Return the value of the frequency in Scientific Pitch Notation\n   * @example\n   * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n   */\n\n\n  toNote() {\n    const freq = this.toFrequency();\n    const log = Math.log2(freq / FrequencyClass.A4);\n    let noteNumber = Math.round(12 * log) + 57;\n    const octave = Math.floor(noteNumber / 12);\n\n    if (octave < 0) {\n      noteNumber += -12 * octave;\n    }\n\n    const noteName = scaleIndexToNote[noteNumber % 12];\n    return noteName + octave.toString();\n  }\n  /**\n   * Return the duration of one cycle in seconds.\n   */\n\n\n  toSeconds() {\n    return 1 / super.toSeconds();\n  }\n  /**\n   * Return the duration of one cycle in ticks\n   */\n\n\n  toTicks() {\n    const quarterTime = this._beatsToUnits(1);\n\n    const quarters = this.valueOf() / quarterTime;\n    return Math.floor(quarters * this._getPPQ());\n  } //-------------------------------------\n  // \tUNIT CONVERSIONS HELPERS\n  //-------------------------------------\n\n  /**\n   * With no arguments, return 0\n   */\n\n\n  _noArg() {\n    return 0;\n  }\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return freq;\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return 1 / (ticks * 60 / (this._getBpm() * this._getPPQ()));\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return 1 / super._beatsToUnits(beats);\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return 1 / seconds;\n  }\n  /**\n   * Convert a MIDI note to frequency value.\n   * @param  midi The midi number to convert.\n   * @return The corresponding frequency value\n   */\n\n\n  static mtof(midi) {\n    return mtof(midi);\n  }\n  /**\n   * Convert a frequency value to a MIDI note.\n   * @param frequency The value to frequency value to convert.\n   */\n\n\n  static ftom(frequency) {\n    return ftom(frequency);\n  }\n\n} //-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index.\n * @hidden\n */\n\nconst noteToScaleIndex = {\n  cbb: -2,\n  cb: -1,\n  c: 0,\n  \"c#\": 1,\n  cx: 2,\n  dbb: 0,\n  db: 1,\n  d: 2,\n  \"d#\": 3,\n  dx: 4,\n  ebb: 2,\n  eb: 3,\n  e: 4,\n  \"e#\": 5,\n  ex: 6,\n  fbb: 3,\n  fb: 4,\n  f: 5,\n  \"f#\": 6,\n  fx: 7,\n  gbb: 5,\n  gb: 6,\n  g: 7,\n  \"g#\": 8,\n  gx: 9,\n  abb: 7,\n  ab: 8,\n  a: 9,\n  \"a#\": 10,\n  ax: 11,\n  bbb: 9,\n  bb: 10,\n  b: 11,\n  \"b#\": 12,\n  bx: 13\n};\n/**\n * scale index to note (sharps)\n * @hidden\n */\n\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\n\nexport function Frequency(value, units) {\n  return new FrequencyClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { TimeClass } from \"./Time\";\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\n\nexport class TransportTimeClass extends TimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"TransportTime\";\n  }\n  /**\n   * Return the current time in whichever context is relevant\n   */\n\n\n  _now() {\n    return this.context.transport.seconds;\n  }\n\n}\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\n\nexport function TransportTime(value, units) {\n  return new TransportTimeClass(getContext(), value, units);\n}","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\n/**\n * The Base class for all nodes that have an AudioContext.\n */\n\nexport class ToneWithContext extends Tone {\n  constructor() {\n    super();\n    const options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\n    if (this.defaultContext) {\n      this.context = this.defaultContext;\n    } else {\n      this.context = options.context;\n    }\n  }\n\n  static getDefaults() {\n    return {\n      context: getContext()\n    };\n  }\n  /**\n   * Return the current time of the Context clock plus the lookAhead.\n   * @example\n   * setInterval(() => {\n   * \tconsole.log(Tone.now());\n   * }, 100)\n   */\n\n\n  now() {\n    return this.context.currentTime + this.context.lookAhead;\n  }\n  /**\n   * Return the current time of the Context clock without any lookAhead.\n   * @example\n   * setInterval(() => {\n   * \tconsole.log(Tone.immediate());\n   * }, 100)\n   */\n\n\n  immediate() {\n    return this.context.currentTime;\n  }\n  /**\n   * The duration in seconds of one sample.\n   * @example\n   * console.log(Tone.Transport.sampleTime);\n   */\n\n\n  get sampleTime() {\n    return 1 / this.context.sampleRate;\n  }\n  /**\n   * The number of seconds of 1 processing block (128 samples)\n   * @example\n   * console.log(Tone.Destination.blockTime);\n   */\n\n\n  get blockTime() {\n    return 128 / this.context.sampleRate;\n  }\n  /**\n   * Convert the incoming time to seconds\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toSeconds(\"4n\"));\n   */\n\n\n  toSeconds(time) {\n    return new TimeClass(this.context, time).toSeconds();\n  }\n  /**\n   * Convert the input to a frequency number\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toFrequency(\"4n\"));\n   */\n\n\n  toFrequency(freq) {\n    return new FrequencyClass(this.context, freq).toFrequency();\n  }\n  /**\n   * Convert the input time into ticks\n   * @example\n   * const gain = new Tone.Gain();\n   * console.log(gain.toTicks(\"4n\"));\n   */\n\n\n  toTicks(time) {\n    return new TransportTimeClass(this.context, time).toTicks();\n  } //-------------------------------------\n  // \tGET/SET\n  //-------------------------------------\n\n  /**\n   * Get a subset of the properties which are in the partial props\n   */\n\n\n  _getPartialProperties(props) {\n    const options = this.get(); // remove attributes from the prop that are not in the partial\n\n    Object.keys(options).forEach(name => {\n      if (isUndef(props[name])) {\n        delete options[name];\n      }\n    });\n    return options;\n  }\n  /**\n   * Get the object's attributes.\n   * @example\n   * const osc = new Tone.Oscillator();\n   * console.log(osc.get());\n   */\n\n\n  get() {\n    const defaults = getDefaultsFromInstance(this);\n    Object.keys(defaults).forEach(attribute => {\n      if (Reflect.has(this, attribute)) {\n        const member = this[attribute];\n\n        if (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n          defaults[attribute] = member.value;\n        } else if (member instanceof ToneWithContext) {\n          defaults[attribute] = member._getPartialProperties(defaults[attribute]); // otherwise make sure it's a serializable type\n        } else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n          defaults[attribute] = member;\n        } else {\n          // remove all undefined and unserializable attributes\n          delete defaults[attribute];\n        }\n      }\n    });\n    return defaults;\n  }\n  /**\n   * Set multiple properties at once with an object.\n   * @example\n   * const filter = new Tone.Filter();\n   * // set values using an object\n   * filter.set({\n   * \tfrequency: 300,\n   * \ttype: \"highpass\"\n   * });\n   */\n\n\n  set(props) {\n    Object.keys(props).forEach(attribute => {\n      if (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n        if (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n          // small optimization\n          if (this[attribute].value !== props[attribute]) {\n            this[attribute].value = props[attribute];\n          }\n        } else if (this[attribute] instanceof ToneWithContext) {\n          this[attribute].set(props[attribute]);\n        } else {\n          this[attribute] = props[attribute];\n        }\n      }\n    });\n    return this;\n  }\n\n}","import { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\n\nexport class StateTimeline extends Timeline {\n  constructor(initial = \"stopped\") {\n    super();\n    this.name = \"StateTimeline\";\n    this._initial = initial;\n    this.setStateAtTime(this._initial, 0);\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n\n\n  getValueAtTime(time) {\n    const event = this.get(time);\n\n    if (event !== null) {\n      return event.state;\n    } else {\n      return this._initial;\n    }\n  }\n  /**\n   * Add a state to the timeline.\n   * @param  state The name of the state to set.\n   * @param  time  The time to query.\n   * @param options Any additional options that are needed in the timeline.\n   */\n\n\n  setStateAtTime(state, time, options) {\n    assertRange(time, 0);\n    this.add(Object.assign({}, options, {\n      state,\n      time\n    }));\n    return this;\n  }\n  /**\n   * Return the event before the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check before\n   * @return  The event with the given state before the time\n   */\n\n\n  getLastState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    for (let i = index; i >= 0; i--) {\n      const event = this._timeline[i];\n\n      if (event.state === state) {\n        return event;\n      }\n    }\n  }\n  /**\n   * Return the event after the time with the given state\n   * @param  state The state to look for\n   * @param  time  When to check from\n   * @return  The event with the given state after the time\n   */\n\n\n  getNextState(state, time) {\n    // time = this.toSeconds(time);\n    const index = this._search(time);\n\n    if (index !== -1) {\n      for (let i = index; i < this._timeline.length; i++) {\n        const event = this._timeline[i];\n\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n  }\n\n}","import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\n\nexport class Param extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    this.name = \"Param\";\n    this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    this._minOutput = 1e-7;\n    const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (this._swappable) {\n      this.input = this.context.createGain(); // initialize\n\n      this._param = options.param;\n      this.input.connect(this._param);\n    } else {\n      this._param = this.input = options.param;\n    }\n\n    this._events = new Timeline(1000);\n    this._initialValue = this._param.defaultValue;\n    this.units = options.units;\n    this.convert = options.convert;\n    this._minValue = options.minValue;\n    this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n      this.setValueAtTime(options.value, 0);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      convert: true,\n      units: \"number\"\n    });\n  }\n\n  get value() {\n    const now = this.now();\n    return this.getValueAtTime(now);\n  }\n\n  set value(value) {\n    this.cancelScheduledValues(this.now());\n    this.setValueAtTime(value, this.now());\n  }\n\n  get minValue() {\n    // if it's not the default minValue, return it\n    if (isDefined(this._minValue)) {\n      return this._minValue;\n    } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n      return 0;\n    } else if (this.units === \"audioRange\") {\n      return -1;\n    } else if (this.units === \"decibels\") {\n      return -Infinity;\n    } else {\n      return this._param.minValue;\n    }\n  }\n\n  get maxValue() {\n    if (isDefined(this._maxValue)) {\n      return this._maxValue;\n    } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n      return 1;\n    } else {\n      return this._param.maxValue;\n    }\n  }\n  /**\n   * Type guard based on the unit name\n   */\n\n\n  _is(arg, type) {\n    return this.units === type;\n  }\n  /**\n   * Make sure the value is always in the defined range\n   */\n\n\n  _assertRange(value) {\n    if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n      assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n    }\n\n    return value;\n  }\n  /**\n   * Convert the given value from the type specified by Param.units\n   * into the destination value (such as Gain or Frequency).\n   */\n\n\n  _fromType(val) {\n    if (this.convert && !this.overridden) {\n      if (this._is(val, \"time\")) {\n        return this.toSeconds(val);\n      } else if (this._is(val, \"decibels\")) {\n        return dbToGain(val);\n      } else if (this._is(val, \"frequency\")) {\n        return this.toFrequency(val);\n      } else {\n        return val;\n      }\n    } else if (this.overridden) {\n      // if it's overridden, should only schedule 0s\n      return 0;\n    } else {\n      return val;\n    }\n  }\n  /**\n   * Convert the parameters value into the units specified by Param.units.\n   */\n\n\n  _toType(val) {\n    if (this.convert && this.units === \"decibels\") {\n      return gainToDb(val);\n    } else {\n      return val;\n    }\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // all docs are generated from ParamInterface.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n\n    const numericValue = this._fromType(value);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n    this._assertRange(numericValue);\n\n    this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: numericValue\n    });\n\n    this._param.setValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    const computedTime = Math.max(this.toSeconds(time), 0);\n\n    const after = this._events.getAfter(computedTime);\n\n    const before = this._events.get(computedTime);\n\n    let value = this._initialValue; // if it was set by\n\n    if (before === null) {\n      value = this._initialValue;\n    } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n      const previous = this._events.getBefore(before.time);\n\n      let previousVal;\n\n      if (previous === null) {\n        previousVal = this._initialValue;\n      } else {\n        previousVal = previous.value;\n      }\n\n      if (before.type === \"setTargetAtTime\") {\n        value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n      }\n    } else if (after === null) {\n      value = before.value;\n    } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n      let beforeValue = before.value;\n\n      if (before.type === \"setTargetAtTime\") {\n        const previous = this._events.getBefore(before.time);\n\n        if (previous === null) {\n          beforeValue = this._initialValue;\n        } else {\n          beforeValue = previous.value;\n        }\n      }\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      } else {\n        value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n      }\n    } else {\n      value = before.value;\n    }\n\n    return this._toType(value);\n  }\n\n  setRampPoint(time) {\n    time = this.toSeconds(time);\n    let currentVal = this.getValueAtTime(time);\n    this.cancelAndHoldAtTime(time);\n\n    if (this._fromType(currentVal) === 0) {\n      currentVal = this._toType(this._minOutput);\n    }\n\n    this.setValueAtTime(currentVal, time);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, endTime) {\n    const numericValue = this._fromType(value);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\n    this._assertRange(numericValue);\n\n    this._events.add({\n      time: computedTime,\n      type: \"linearRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n    this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, endTime) {\n    let numericValue = this._fromType(value);\n\n    numericValue = Math.max(this._minOutput, numericValue);\n\n    this._assertRange(numericValue);\n\n    const computedTime = this.toSeconds(endTime);\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`); // store the event\n\n    this._events.add({\n      time: computedTime,\n      type: \"exponentialRampToValueAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n    this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    startTime = this.toSeconds(startTime);\n    this.setRampPoint(startTime);\n    this.exponentialApproachValueAtTime(value, startTime, rampTime);\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    time = this.toSeconds(time);\n    rampTime = this.toSeconds(rampTime);\n    const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n    this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n    this.cancelAndHoldAtTime(time + rampTime * 0.9);\n    this.linearRampToValueAtTime(value, time + rampTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n    assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n    const computedTime = this.toSeconds(startTime);\n\n    this._assertRange(numericValue);\n\n    assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\n    this._events.add({\n      constant: timeConstant,\n      time: computedTime,\n      type: \"setTargetAtTime\",\n      value: numericValue\n    });\n\n    this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n    this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n    duration = this.toSeconds(duration);\n    startTime = this.toSeconds(startTime);\n    const startingValue = this._fromType(values[0]) * scaling;\n    this.setValueAtTime(this._toType(startingValue), startTime);\n    const segTime = duration / (values.length - 1);\n\n    for (let i = 1; i < values.length; i++) {\n      const numericValue = this._fromType(values[i]) * scaling;\n      this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n    }\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    const computedTime = this.toSeconds(time);\n    assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\n    this._events.cancel(computedTime);\n\n    this._param.cancelScheduledValues(computedTime);\n\n    this.log(this.units, \"cancelScheduledValues\", computedTime);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n    assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n    this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n    // and that even is not a \"set\"\n\n    const before = this._events.get(computedTime);\n\n    const after = this._events.getAfter(computedTime);\n\n    if (before && EQ(before.time, computedTime)) {\n      // remove everything after\n      if (after) {\n        this._param.cancelScheduledValues(after.time);\n\n        this._events.cancel(after.time);\n      } else {\n        this._param.cancelAndHoldAtTime(computedTime);\n\n        this._events.cancel(computedTime + this.sampleTime);\n      }\n    } else if (after) {\n      this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n      this._events.cancel(after.time);\n\n      if (after.type === \"linearRampToValueAtTime\") {\n        this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      } else if (after.type === \"exponentialRampToValueAtTime\") {\n        this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n      }\n    } // set the value at the given time\n\n\n    this._events.add({\n      time: computedTime,\n      type: \"setValueAtTime\",\n      value: valueAtTime\n    });\n\n    this._param.setValueAtTime(valueAtTime, computedTime);\n\n    return this;\n  }\n\n  rampTo(value, rampTime = 0.1, startTime) {\n    if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n      this.exponentialRampTo(value, rampTime, startTime);\n    } else {\n      this.linearRampTo(value, rampTime, startTime);\n    }\n\n    return this;\n  }\n  /**\n   * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n   * The applied values will start at the context's current time and schedule\n   * all of the events which are scheduled on this Param onto the passed in param.\n   */\n\n\n  apply(param) {\n    const now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n    param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n    const previousEvent = this._events.get(now);\n\n    if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n      // approx it until the next event with linear ramps\n      const nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n      const endTime = nextEvent ? nextEvent.time : now + 2;\n      const subdivisions = (endTime - now) / 10;\n\n      for (let i = now; i < endTime; i += subdivisions) {\n        param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n      }\n    }\n\n    this._events.forEachAfter(this.context.currentTime, event => {\n      if (event.type === \"cancelScheduledValues\") {\n        param.cancelScheduledValues(event.time);\n      } else if (event.type === \"setTargetAtTime\") {\n        param.setTargetAtTime(event.value, event.time, event.constant);\n      } else {\n        param[event.type](event.value, event.time);\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Replace the Param's internal AudioParam. Will apply scheduled curves\n   * onto the parameter and replace the connections.\n   */\n\n\n  setParam(param) {\n    assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n    const input = this.input;\n    input.disconnect(this._param);\n    this.apply(param);\n    this._param = param;\n    input.connect(this._param);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    return this;\n  }\n\n  get defaultValue() {\n    return this._toType(this._param.defaultValue);\n  } //-------------------------------------\n  // \tAUTOMATION CURVE CALCULATIONS\n  // \tMIT License, copyright (c) 2014 Jordan Santell\n  //-------------------------------------\n  // Calculates the the value along the curve produced by setTargetAtTime\n\n\n  _exponentialApproach(t0, v0, v1, timeConstant, t) {\n    return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n  } // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n\n  _linearInterpolate(t0, v0, t1, v1, t) {\n    return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n  } // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n\n  _exponentialInterpolate(t0, v0, t1, v1, t) {\n    return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n  }\n\n}","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport class ToneAudioNode extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    /**\n     * The name of the class\n     */\n\n    this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    this._internalChannels = [];\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  get numberOfInputs() {\n    if (isDefined(this.input)) {\n      if (isAudioParam(this.input) || this.input instanceof Param) {\n        return 1;\n      } else {\n        return this.input.numberOfInputs;\n      }\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The number of outputs of the AudioNode.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfOutputs);\n   */\n\n\n  get numberOfOutputs() {\n    if (isDefined(this.output)) {\n      return this.output.numberOfOutputs;\n    } else {\n      return 0;\n    }\n  } //-------------------------------------\n  // AUDIO PROPERTIES\n  //-------------------------------------\n\n  /**\n   * Used to decide which nodes to get/set properties on\n   */\n\n\n  _isAudioNode(node) {\n    return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n  }\n  /**\n   * Get all of the audio nodes (either internal or input/output) which together\n   * make up how the class node responds to channel input/output\n   */\n\n\n  _getInternalNodes() {\n    const nodeList = this._internalChannels.slice(0);\n\n    if (this._isAudioNode(this.input)) {\n      nodeList.push(this.input);\n    }\n\n    if (this._isAudioNode(this.output)) {\n      if (this.input !== this.output) {\n        nodeList.push(this.output);\n      }\n    }\n\n    return nodeList;\n  }\n  /**\n   * Set the audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   * @param options\n   */\n\n\n  _setChannelProperties(options) {\n    const nodeList = this._getInternalNodes();\n\n    nodeList.forEach(node => {\n      node.channelCount = options.channelCount;\n      node.channelCountMode = options.channelCountMode;\n      node.channelInterpretation = options.channelInterpretation;\n    });\n  }\n  /**\n   * Get the current audio options for this node such as channelInterpretation\n   * channelCount, etc.\n   */\n\n\n  _getChannelProperties() {\n    const nodeList = this._getInternalNodes();\n\n    assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n    // they should all be the same\n\n    const node = nodeList[0];\n    return {\n      channelCount: node.channelCount,\n      channelCountMode: node.channelCountMode,\n      channelInterpretation: node.channelInterpretation\n    };\n  }\n  /**\n   * channelCount is the number of channels used when up-mixing and down-mixing\n   * connections to any inputs to the node. The default value is 2 except for\n   * specific nodes where its value is specially determined.\n   */\n\n\n  get channelCount() {\n    return this._getChannelProperties().channelCount;\n  }\n\n  set channelCount(channelCount) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCount\n    }));\n  }\n  /**\n   * channelCountMode determines how channels will be counted when up-mixing and\n   * down-mixing connections to any inputs to the node.\n   * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n   * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n   * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n   * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n   */\n\n\n  get channelCountMode() {\n    return this._getChannelProperties().channelCountMode;\n  }\n\n  set channelCountMode(channelCountMode) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelCountMode\n    }));\n  }\n  /**\n   * channelInterpretation determines how individual channels will be treated\n   * when up-mixing and down-mixing connections to any inputs to the node.\n   * The default value is \"speakers\".\n   */\n\n\n  get channelInterpretation() {\n    return this._getChannelProperties().channelInterpretation;\n  }\n\n  set channelInterpretation(channelInterpretation) {\n    const props = this._getChannelProperties(); // merge it with the other properties\n\n\n    this._setChannelProperties(Object.assign(props, {\n      channelInterpretation\n    }));\n  } //-------------------------------------\n  // CONNECTIONS\n  //-------------------------------------\n\n  /**\n   * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n   * @param destination The output to connect to\n   * @param outputNum The output to connect from\n   * @param inputNum The input to connect to\n   */\n\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    connect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * @example\n   * const osc = new Tone.Oscillator().start();\n   * osc.toDestination();\n   */\n\n\n  toDestination() {\n    this.connect(this.context.destination);\n    return this;\n  }\n  /**\n   * Connect the output to the context's destination node.\n   * See [[toDestination]]\n   * @deprecated\n   */\n\n\n  toMaster() {\n    warn(\"toMaster() has been renamed toDestination()\");\n    return this.toDestination();\n  }\n  /**\n   * disconnect the output\n   */\n\n\n  disconnect(destination, outputNum = 0, inputNum = 0) {\n    disconnect(this, destination, outputNum, inputNum);\n    return this;\n  }\n  /**\n   * Connect the output of this node to the rest of the nodes in series.\n   * @example\n   * const osc = new Tone.Oscillator().start();\n   * const filter = new Tone.Filter();\n   * const volume = new Tone.Volume(-8);\n   * // connect a node to the filter, volume and then to the master output\n   * osc.chain(filter, volume, Tone.Destination);\n   */\n\n\n  chain(...nodes) {\n    connectSeries(this, ...nodes);\n    return this;\n  }\n  /**\n   * connect the output of this node to the rest of the nodes in parallel.\n   */\n\n\n  fan(...nodes) {\n    nodes.forEach(node => this.connect(node));\n    return this;\n  }\n  /**\n   * Dispose and disconnect\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (isDefined(this.input)) {\n      if (this.input instanceof ToneAudioNode) {\n        this.input.dispose();\n      } else if (isAudioNode(this.input)) {\n        this.input.disconnect();\n      }\n    }\n\n    if (isDefined(this.output)) {\n      if (this.output instanceof ToneAudioNode) {\n        this.output.dispose();\n      } else if (isAudioNode(this.output)) {\n        this.output.disconnect();\n      }\n    }\n\n    this._internalChannels = [];\n    return this;\n  }\n\n} //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries(...nodes) {\n  const first = nodes.shift();\n  nodes.reduce((prev, current) => {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @offline 0.7 1\n * @example\n * const gainNode = new Tone.Gain(0).toDestination();\n * const osc = new Tone.Oscillator().connect(gainNode);\n * gainNode.gain.rampTo(1, 0.1);\n * gainNode.gain.rampTo(0, 0.4, 0.2);\n */\n\nexport class Gain extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n    this.name = \"Gain\";\n    /**\n     * The wrapped GainNode.\n     */\n\n    this._gainNode = this.context.createGain(); // input = output\n\n    this.input = this._gainNode;\n    this.output = this._gainNode;\n    const options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n    this.gain = new Param({\n      context: this.context,\n      convert: options.convert,\n      param: this._gainNode.gain,\n      units: options.units,\n      value: options.gain,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n    readOnly(this, \"gain\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      convert: true,\n      gain: 1,\n      units: \"gain\"\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.disconnect();\n\n    this.gain.dispose();\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Base class for fire-and-forget nodes\n */\n\nexport class OneShotSource extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * The callback to invoke after the\n     * source is done playing.\n     */\n\n    this.onended = noOp;\n    /**\n     * The start time\n     */\n\n    this._startTime = -1;\n    /**\n     * The stop time\n     */\n\n    this._stopTime = -1;\n    /**\n     * The id of the timeout\n     */\n\n    this._timeout = -1;\n    /**\n     * The public output node\n     */\n\n    this.output = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The output gain node.\n     */\n\n    this._gainNode = this.output;\n    /**\n     * Get the playback state at the given time\n     */\n\n    this.getStateAtTime = function (time) {\n      const computedTime = this.toSeconds(time);\n\n      if (this._startTime !== -1 && computedTime >= this._startTime && (this._stopTime === -1 || computedTime <= this._stopTime)) {\n        return \"started\";\n      } else {\n        return \"stopped\";\n      }\n    };\n\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n    this._curve = options.curve;\n    this.onended = options.onended;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      curve: \"linear\",\n      fadeIn: 0,\n      fadeOut: 0,\n      onended: noOp\n    });\n  }\n  /**\n   * Start the source at the given time\n   * @param  time When to start the source\n   */\n\n\n  _startGain(time, gain = 1) {\n    assert(this._startTime === -1, \"Source cannot be started more than once\"); // apply a fade in envelope\n\n    const fadeInTime = this.toSeconds(this._fadeIn); // record the start time\n\n    this._startTime = time + fadeInTime;\n    this._startTime = Math.max(this._startTime, this.context.currentTime); // schedule the envelope\n\n    if (fadeInTime > 0) {\n      this._gainNode.gain.setValueAtTime(0, time);\n\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n      } else {\n        this._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n      }\n    } else {\n      this._gainNode.gain.setValueAtTime(gain, time);\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source node at the given time.\n   * @param time When to stop the source\n   */\n\n\n  stop(time) {\n    this.log(\"stop\", time);\n\n    this._stopGain(this.toSeconds(time));\n\n    return this;\n  }\n  /**\n   * Stop the source at the given time\n   * @param  time When to stop the source\n   */\n\n\n  _stopGain(time) {\n    assert(this._startTime !== -1, \"'start' must be called before 'stop'\"); // cancel the previous stop\n\n    this.cancelStop(); // the fadeOut time\n\n    const fadeOutTime = this.toSeconds(this._fadeOut); // schedule the stop callback\n\n    this._stopTime = this.toSeconds(time) + fadeOutTime;\n    this._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\n    if (fadeOutTime > 0) {\n      // start the fade out curve at the given time\n      if (this._curve === \"linear\") {\n        this._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n      } else {\n        this._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n      }\n    } else {\n      // stop any ongoing ramps, and set the value to 0\n      this._gainNode.gain.cancelAndHoldAtTime(time);\n\n      this._gainNode.gain.setValueAtTime(0, time);\n    }\n\n    this.context.clearTimeout(this._timeout);\n    this._timeout = this.context.setTimeout(() => {\n      // allow additional time for the exponential curve to fully decay\n      const additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\n      this._stopSource(this.now() + additionalTail);\n\n      this._onended();\n    }, this._stopTime - this.context.currentTime);\n    return this;\n  }\n  /**\n   * Invoke the onended callback\n   */\n\n\n  _onended() {\n    if (this.onended !== noOp) {\n      this.onended(this); // overwrite onended to make sure it only is called once\n\n      this.onended = noOp; // dispose when it's ended to free up for garbage collection only in the online context\n\n      if (!this.context.isOffline) {\n        setTimeout(() => this.dispose(), 1000);\n      }\n    }\n  }\n  /**\n   * Get the playback state at the current time\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Cancel a scheduled stop event\n   */\n\n\n  cancelStop() {\n    this.log(\"cancelStop\");\n    assert(this._startTime !== -1, \"Source is not started\"); // cancel the stop envelope\n\n    this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\n    this.context.clearTimeout(this._timeout);\n    this._stopTime = -1;\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.disconnect();\n\n    return this;\n  }\n\n}","import { connect } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource } from \"../source/OneShotSource\";\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\n\nexport class ToneConstantSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n    this.name = \"ToneConstantSource\";\n    /**\n     * The signal generator\n     */\n\n    this._source = this.context.createConstantSource();\n    const options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n    connect(this._source, this._gainNode);\n    this.offset = new Param({\n      context: this.context,\n      convert: options.convert,\n      param: this._source.offset,\n      units: options.units,\n      value: options.offset,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      convert: true,\n      offset: 1,\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the source node at the given time\n   * @param  time When to start the source\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._source.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._source.stop(time);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._source.disconnect();\n\n    this.offset.dispose();\n    return this;\n  }\n\n}","import { Param } from \"../core/context/Param\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\n\nexport class Signal extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    this.name = \"Signal\";\n    /**\n     * Indicates if the value should be overridden on connection.\n     */\n\n    this.override = true;\n    const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    this.output = this._constantSource = new ToneConstantSource({\n      context: this.context,\n      convert: options.convert,\n      offset: options.value,\n      units: options.units,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n\n    this._constantSource.start(0);\n\n    this.input = this._param = this._constantSource.offset;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      convert: true,\n      units: \"number\",\n      value: 0\n    });\n  }\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    // start it only when connected to something\n    connectSignal(this, destination, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._param.dispose();\n\n    this._constantSource.dispose();\n\n    return this;\n  } //-------------------------------------\n  // ABSTRACT PARAM INTERFACE\n  // just a proxy for the ConstantSourceNode's offset AudioParam\n  // all docs are generated from AbstractParam.ts\n  //-------------------------------------\n\n\n  setValueAtTime(value, time) {\n    this._param.setValueAtTime(value, time);\n\n    return this;\n  }\n\n  getValueAtTime(time) {\n    return this._param.getValueAtTime(time);\n  }\n\n  setRampPoint(time) {\n    this._param.setRampPoint(time);\n\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    this._param.linearRampToValueAtTime(value, time);\n\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    this._param.exponentialRampToValueAtTime(value, time);\n\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    this._param.exponentialRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    this._param.linearRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    this._param.targetRampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  exponentialApproachValueAtTime(value, time, rampTime) {\n    this._param.exponentialApproachValueAtTime(value, time, rampTime);\n\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    this._param.setTargetAtTime(value, startTime, timeConstant);\n\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling) {\n    this._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\n    return this;\n  }\n\n  cancelScheduledValues(time) {\n    this._param.cancelScheduledValues(time);\n\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    this._param.cancelAndHoldAtTime(time);\n\n    return this;\n  }\n\n  rampTo(value, rampTime, startTime) {\n    this._param.rampTo(value, rampTime, startTime);\n\n    return this;\n  }\n\n  get value() {\n    return this._param.value;\n  }\n\n  set value(value) {\n    this._param.value = value;\n  }\n\n  get convert() {\n    return this._param.convert;\n  }\n\n  set convert(convert) {\n    this._param.convert = convert;\n  }\n\n  get units() {\n    return this._param.units;\n  }\n\n  get overridden() {\n    return this._param.overridden;\n  }\n\n  set overridden(overridden) {\n    this._param.overridden = overridden;\n  }\n\n  get maxValue() {\n    return this._param.maxValue;\n  }\n\n  get minValue() {\n    return this._param.minValue;\n  }\n  /**\n   * See [[Param.apply]].\n   */\n\n\n  apply(param) {\n    this._param.apply(param);\n\n    return this;\n  }\n\n}\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\n\nexport function connectSignal(signal, destination, outputNum, inputNum) {\n  if (destination instanceof Param || isAudioParam(destination) || destination instanceof Signal && destination.override) {\n    // cancel changes\n    destination.cancelScheduledValues(0); // reset the value\n\n    destination.setValueAtTime(0, 0); // mark the value as overridden\n\n    if (destination instanceof Signal) {\n      destination.overridden = true;\n    }\n  }\n\n  connect(signal, destination, outputNum, inputNum);\n}","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\n\nexport class TickParam extends Param {\n  constructor() {\n    super(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n\n    this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n\n    this._multiplier = 1;\n    const options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]); // set the multiplier\n\n    this._multiplier = options.multiplier; // clear the ticks from the beginning\n\n    this._events.cancel(0); // set an initial event\n\n\n    this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: this._fromType(options.value)\n    });\n\n    this.setValueAtTime(options.value, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign(Param.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n\n  setTargetAtTime(value, time, constant) {\n    // approximate it with multiple linear ramps\n    time = this.toSeconds(time);\n    this.setRampPoint(time);\n\n    const computedValue = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time);\n\n    const segments = Math.round(Math.max(1 / constant, 1));\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = constant * i + time;\n\n      const rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.setValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = this.toSeconds(time);\n    super.linearRampToValueAtTime(value, time);\n\n    const event = this._events.get(computedTime);\n\n    const previousEvent = this._events.previousEvent(event);\n\n    const ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n    event.ticks = Math.max(ticksUntilTime, 0);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    // aproximate it with multiple linear ramps\n    time = this.toSeconds(time);\n\n    const computedVal = this._fromType(value); // start from previously scheduled value\n\n\n    const prevEvent = this._events.get(time); // approx 10 segments per second\n\n\n    const segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n    const segmentDur = (time - prevEvent.time) / segments;\n\n    for (let i = 0; i <= segments; i++) {\n      const segTime = segmentDur * i + prevEvent.time;\n\n      const rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\n      this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  event The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  _getTicksUntilEvent(event, time) {\n    if (event === null) {\n      event = {\n        ticks: 0,\n        time: 0,\n        type: \"setValueAtTime\",\n        value: 0\n      };\n    } else if (isUndef(event.ticks)) {\n      const previousEvent = this._events.previousEvent(event);\n\n      event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n    }\n\n    const val0 = this._fromType(this.getValueAtTime(event.time));\n\n    let val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value\n\n\n    const onTheLineEvent = this._events.get(time);\n\n    if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n      val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n    }\n\n    return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n  }\n  /**\n   * Returns the tick value at the time. Takes into account\n   * any automation curves scheduled on the signal.\n   * @param  time The time to get the tick count at\n   * @return The number of ticks which have elapsed at the time given any automations.\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const event = this._events.get(computedTime);\n\n    return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n  }\n  /**\n   * Return the elapsed time of the number of ticks from the given time\n   * @param ticks The number of ticks to calculate\n   * @param  time The time to get the next tick from\n   * @return The duration of the number of ticks from the given time in seconds\n   */\n\n\n  getDurationOfTicks(ticks, time) {\n    const computedTime = this.toSeconds(time);\n    const currentTick = this.getTicksAtTime(time);\n    return this.getTimeOfTick(currentTick + ticks) - computedTime;\n  }\n  /**\n   * Given a tick, returns the time that tick occurs at.\n   * @return The time that the tick occurs.\n   */\n\n\n  getTimeOfTick(tick) {\n    const before = this._events.get(tick, \"ticks\");\n\n    const after = this._events.getAfter(tick, \"ticks\");\n\n    if (before && before.ticks === tick) {\n      return before.time;\n    } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n      const val0 = this._fromType(this.getValueAtTime(before.time));\n\n      const val1 = this._fromType(this.getValueAtTime(after.time));\n\n      const delta = (val1 - val0) / (after.time - before.time);\n      const k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n      const sol1 = (-val0 + k) / delta;\n      const sol2 = (-val0 - k) / delta;\n      return (sol1 > 0 ? sol1 : sol2) + before.time;\n    } else if (before) {\n      if (before.value === 0) {\n        return Infinity;\n      } else {\n        return before.time + (tick - before.ticks) / before.value;\n      }\n    } else {\n      return tick / this._initialValue;\n    }\n  }\n  /**\n   * Convert some number of ticks their the duration in seconds accounting\n   * for any automation curves starting at the given time.\n   * @param  ticks The number of ticks to convert to seconds.\n   * @param  when  When along the automation timeline to convert the ticks.\n   * @return The duration in seconds of the ticks.\n   */\n\n\n  ticksToTime(ticks, when) {\n    return this.getDurationOfTicks(ticks, when);\n  }\n  /**\n   * The inverse of [[ticksToTime]]. Convert a duration in\n   * seconds to the corresponding number of ticks accounting for any\n   * automation curves starting at the given time.\n   * @param  duration The time interval to convert to ticks.\n   * @param  when When along the automation timeline to convert the ticks.\n   * @return The duration in ticks.\n   */\n\n\n  timeToTicks(duration, when) {\n    const computedTime = this.toSeconds(when);\n    const computedDuration = this.toSeconds(duration);\n    const startTicks = this.getTicksAtTime(computedTime);\n    const endTicks = this.getTicksAtTime(computedTime + computedDuration);\n    return endTicks - startTicks;\n  }\n  /**\n   * Convert from the type when the unit value is BPM\n   */\n\n\n  _fromType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return 1 / (60 / val / this.multiplier);\n    } else {\n      return super._fromType(val);\n    }\n  }\n  /**\n   * Special case of type conversion where the units === \"bpm\"\n   */\n\n\n  _toType(val) {\n    if (this.units === \"bpm\" && this.multiplier) {\n      return val / this.multiplier * 60;\n    } else {\n      return super._toType(val);\n    }\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n\n\n  get multiplier() {\n    return this._multiplier;\n  }\n\n  set multiplier(m) {\n    // get and reset the current value with the new multiplier\n    // might be necessary to clear all the previous values\n    const currentVal = this.value;\n    this._multiplier = m;\n    this.cancelScheduledValues(0);\n    this.setValueAtTime(currentVal, 0);\n  }\n\n}","import { Signal } from \"../../signal/Signal\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\n\nexport class TickSignal extends Signal {\n  constructor() {\n    super(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n    this.name = \"TickSignal\";\n    const options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n    this.input = this._param = new TickParam({\n      context: this.context,\n      convert: options.convert,\n      multiplier: options.multiplier,\n      param: this._constantSource.offset,\n      units: options.units,\n      value: options.value\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      multiplier: 1,\n      units: \"hertz\",\n      value: 1\n    });\n  }\n\n  ticksToTime(ticks, when) {\n    return this._param.ticksToTime(ticks, when);\n  }\n\n  timeToTicks(duration, when) {\n    return this._param.timeToTicks(duration, when);\n  }\n\n  getTimeOfTick(tick) {\n    return this._param.getTimeOfTick(tick);\n  }\n\n  getDurationOfTicks(ticks, time) {\n    return this._param.getDurationOfTicks(ticks, time);\n  }\n\n  getTicksAtTime(time) {\n    return this._param.getTicksAtTime(time);\n  }\n  /**\n   * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n   */\n\n\n  get multiplier() {\n    return this._param.multiplier;\n  }\n\n  set multiplier(m) {\n    this._param.multiplier = m;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._param.dispose();\n\n    return this;\n  }\n\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport class TickSource extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    this._tickOffset = new Timeline();\n    const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new TickSignal({\n      context: this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\"); // set the initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    this.setTicksAtTime(0, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign({\n      frequency: 1,\n      units: \"hertz\"\n    }, ToneWithContext.getDefaults());\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this.getStateAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset The number of ticks to start the source at\n   */\n\n\n  start(time, offset) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (isDefined(offset)) {\n        this.setTicksAtTime(offset, computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time); // cancel the previous stop\n\n    if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n      const event = this._state.get(computedTime);\n\n      if (event && event.time > 0) {\n        this._tickOffset.cancel(event.time);\n\n        this._state.cancel(event.time);\n      }\n    }\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this.setTicksAtTime(0, computedTime);\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n   * @param time When to clear the events after\n   */\n\n\n  cancel(time) {\n    time = this.toSeconds(time);\n\n    this._state.cancel(time);\n\n    this._tickOffset.cancel(time);\n\n    return this;\n  }\n  /**\n   * Get the elapsed ticks at the given time\n   * @param  time  When to get the tick value\n   * @return The number of ticks\n   */\n\n\n  getTicksAtTime(time) {\n    const computedTime = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time: computedTime\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedTicks = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedTicks = offsetEvent.ticks;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedTicks;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked. Returns -1 when stopped.\n   */\n\n\n  get ticks() {\n    return this.getTicksAtTime(this.now());\n  }\n\n  set ticks(t) {\n    this.setTicksAtTime(t, this.now());\n  }\n  /**\n   * The time since ticks=0 that the TickSource has been running. Accounts\n   * for tempo curves\n   */\n\n\n  get seconds() {\n    return this.getSecondsAtTime(this.now());\n  }\n\n  set seconds(s) {\n    const now = this.now();\n    const ticks = this.frequency.timeToTicks(s, now);\n    this.setTicksAtTime(ticks, now);\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    time = this.toSeconds(time);\n\n    const stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n    const tmpEvent = {\n      state: \"paused\",\n      time\n    };\n\n    this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n    let lastState = stopEvent;\n    let elapsedSeconds = 0; // iterate through all the events since the last stop\n\n    this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n      let periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n      const offsetEvent = this._tickOffset.get(e.time);\n\n      if (offsetEvent && offsetEvent.time >= lastState.time) {\n        elapsedSeconds = offsetEvent.seconds;\n        periodStartTime = offsetEvent.time;\n      }\n\n      if (lastState.state === \"started\" && e.state !== \"started\") {\n        elapsedSeconds += e.time - periodStartTime;\n      }\n\n      lastState = e;\n    }); // remove the temporary event\n\n\n    this._state.remove(tmpEvent); // return the ticks\n\n\n    return elapsedSeconds;\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    time = this.toSeconds(time);\n\n    this._tickOffset.cancel(time);\n\n    this._tickOffset.add({\n      seconds: this.frequency.getDurationOfTicks(ticks, time),\n      ticks,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   */\n\n\n  getStateAtTime(time) {\n    time = this.toSeconds(time);\n    return this._state.getValueAtTime(time);\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    const offset = this._tickOffset.get(before);\n\n    const event = this._state.get(before);\n\n    const startTime = Math.max(offset.time, event.time);\n    const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n    return this.frequency.getTimeOfTick(absoluteTicks);\n  }\n  /**\n   * Invoke the callback event at all scheduled ticks between the\n   * start time and the end time\n   * @param  startTime  The beginning of the search range\n   * @param  endTime    The end of the search range\n   * @param  callback   The callback to invoke with each tick\n   */\n\n\n  forEachTickBetween(startTime, endTime, callback) {\n    // only iterate through the sections where it is \"started\"\n    let lastStateEvent = this._state.get(startTime);\n\n    this._state.forEachBetween(startTime, endTime, event => {\n      if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n        this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n      }\n\n      lastStateEvent = event;\n    });\n\n    let error = null;\n\n    if (lastStateEvent && lastStateEvent.state === \"started\") {\n      const maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n      const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n      const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n      const diff = startTicks - ticksAtStart;\n      let offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n      offset = EQ(offset, 1) ? 0 : offset;\n      let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n      while (nextTickTime < endTime) {\n        try {\n          callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n        } catch (e) {\n          error = e;\n          break;\n        }\n\n        nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n      }\n    }\n\n    if (error) {\n      throw error;\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._state.dispose();\n\n    this._tickOffset.dispose();\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport class Clock extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    this._boundLoop = this._loop.bind(this);\n    const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    this.callback = options.callback;\n    this._tickSource = new TickSource({\n      context: this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    this._lastUpdate = 0;\n    this.frequency = this._tickSource.frequency;\n    readOnly(this, \"frequency\"); // add an initial state\n\n    this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    this.context.on(\"tick\", this._boundLoop);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      frequency: 1,\n      units: \"hertz\"\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n   */\n\n\n  get state() {\n    return this._state.getValueAtTime(this.now());\n  }\n  /**\n   * Start the clock at the given time. Optionally pass in an offset\n   * of where to start the tick counter from.\n   * @param  time    The time the clock should start\n   * @param offset  Where the tick counter starts counting from.\n   */\n\n\n  start(time, offset) {\n    // make sure the context is running\n    assertContextRunning(this.context); // start the loop\n\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    if (this._state.getValueAtTime(computedTime) !== \"started\") {\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this._tickSource.start(computedTime, offset);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"start\", computedTime, offset);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Stop the clock. Stopping the clock resets the tick counter to 0.\n   * @param time The time when the clock should stop.\n   * @example\n   * const clock = new Tone.Clock(time => {\n   * \tconsole.log(time);\n   * }, 1);\n   * clock.start();\n   * // stop the clock after 10 seconds\n   * clock.stop(\"+10\");\n   */\n\n\n  stop(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"stop\", computedTime);\n\n    this._state.cancel(computedTime);\n\n    this._state.setStateAtTime(\"stopped\", computedTime);\n\n    this._tickSource.stop(computedTime);\n\n    if (computedTime < this._lastUpdate) {\n      this.emit(\"stop\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Pause the clock. Pausing does not reset the tick counter.\n   * @param time The time when the clock should stop.\n   */\n\n\n  pause(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      this._state.setStateAtTime(\"paused\", computedTime);\n\n      this._tickSource.pause(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"pause\", computedTime);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of times the callback was invoked. Starts counting at 0\n   * and increments after the callback was invoked.\n   */\n\n\n  get ticks() {\n    return Math.ceil(this.getTicksAtTime(this.now()));\n  }\n\n  set ticks(t) {\n    this._tickSource.ticks = t;\n  }\n  /**\n   * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n   */\n\n\n  get seconds() {\n    return this._tickSource.seconds;\n  }\n\n  set seconds(s) {\n    this._tickSource.seconds = s;\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._tickSource.getSecondsAtTime(time);\n  }\n  /**\n   * Set the clock's ticks at the given time.\n   * @param  ticks The tick value to set\n   * @param  time  When to set the tick value\n   */\n\n\n  setTicksAtTime(ticks, time) {\n    this._tickSource.setTicksAtTime(ticks, time);\n\n    return this;\n  }\n  /**\n   * Get the time of the given tick. The second argument\n   * is when to test before. Since ticks can be set (with setTicksAtTime)\n   * there may be multiple times for a given tick value.\n   * @param  tick The tick number.\n   * @param  before When to measure the tick value from.\n   * @return The time of the tick\n   */\n\n\n  getTimeOfTick(tick, before = this.now()) {\n    return this._tickSource.getTimeOfTick(tick, before);\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return this._tickSource.getTicksAtTime(time);\n  }\n  /**\n   * Get the time of the next tick\n   * @param  offset The tick number.\n   */\n\n\n  nextTickTime(offset, when) {\n    const computedTime = this.toSeconds(when);\n    const currentTick = this.getTicksAtTime(computedTime);\n    return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n  }\n  /**\n   * The scheduling loop.\n   */\n\n\n  _loop() {\n    const startTime = this._lastUpdate;\n    const endTime = this.now();\n    this._lastUpdate = endTime;\n    this.log(\"loop\", startTime, endTime);\n\n    if (startTime !== endTime) {\n      // the state change events\n      this._state.forEachBetween(startTime, endTime, e => {\n        switch (e.state) {\n          case \"started\":\n            const offset = this._tickSource.getTicksAtTime(e.time);\n\n            this.emit(\"start\", e.time, offset);\n            break;\n\n          case \"stopped\":\n            if (e.time !== 0) {\n              this.emit(\"stop\", e.time);\n            }\n\n            break;\n\n          case \"paused\":\n            this.emit(\"pause\", e.time);\n            break;\n        }\n      }); // the tick callbacks\n\n\n      this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n        this.callback(time, ticks);\n      });\n    }\n  }\n  /**\n   * Returns the scheduled state at the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   * @example\n   * const clock = new Tone.Clock();\n   * clock.start(\"+0.1\");\n   * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n   */\n\n\n  getStateAtTime(time) {\n    const computedTime = this.toSeconds(time);\n    return this._state.getValueAtTime(computedTime);\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.context.off(\"tick\", this._boundLoop);\n\n    this._tickSource.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Clock);","import { Timeline } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\n\nexport class TimelineValue extends Tone {\n  /**\n   * @param initialValue The value to return if there is no scheduled values\n   */\n  constructor(initialValue) {\n    super();\n    this.name = \"TimelineValue\";\n    /**\n     * The timeline which stores the values\n     */\n\n    this._timeline = new Timeline({\n      memory: 10\n    });\n    this._initialValue = initialValue;\n  }\n  /**\n   * Set the value at the given time\n   */\n\n\n  set(value, time) {\n    this._timeline.add({\n      value,\n      time\n    });\n\n    return this;\n  }\n  /**\n   * Get the value at the given time\n   */\n\n\n  get(time) {\n    const event = this._timeline.get(time);\n\n    if (event) {\n      return event.value;\n    } else {\n      return this._initialValue;\n    }\n  }\n\n}","import { getContext } from \"../Global\";\nimport { TransportTimeClass } from \"./TransportTime\";\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\n\nexport class TicksClass extends TransportTimeClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"Ticks\";\n    this.defaultUnits = \"i\";\n  }\n  /**\n   * Get the current time in the given units\n   */\n\n\n  _now() {\n    return this.context.transport.ticks;\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return this._getPPQ() * beats;\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ticks;\n  }\n  /**\n   * Return the time in ticks\n   */\n\n\n  toTicks() {\n    return this.valueOf();\n  }\n  /**\n   * Return the time in seconds\n   */\n\n\n  toSeconds() {\n    return this.valueOf() / this._getPPQ() * (60 / this._getBpm());\n  }\n\n}\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\n\nexport function Ticks(value, units) {\n  return new TicksClass(getContext(), value, units);\n}","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\n\nexport class IntervalTimeline extends Tone {\n  constructor() {\n    super(...arguments);\n    this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n\n    this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n\n    this._length = 0;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n\n\n  add(event) {\n    assert(isDefined(event.time), \"Events must have a time property\");\n    assert(isDefined(event.duration), \"Events must have a duration parameter\");\n    event.time = event.time.valueOf();\n    let node = new IntervalNode(event.time, event.time + event.duration, event);\n\n    if (this._root === null) {\n      this._root = node;\n    } else {\n      this._root.insert(node);\n    }\n\n    this._length++; // Restructure tree to be balanced\n\n    while (node !== null) {\n      node.updateHeight();\n      node.updateMax();\n\n      this._rebalance(node);\n\n      node = node.parent;\n    }\n\n    return this;\n  }\n  /**\n   * Remove an event from the timeline.\n   * @param  event  The event to remove from the timeline\n   */\n\n\n  remove(event) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(event.time, results);\n\n      for (const node of results) {\n        if (node.event === event) {\n          this._removeNode(node);\n\n          this._length--;\n          break;\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * The number of items in the timeline.\n   * @readOnly\n   */\n\n\n  get length() {\n    return this._length;\n  }\n  /**\n   * Remove events whose time time is after the given time\n   * @param  after  The time to query.\n   */\n\n\n  cancel(after) {\n    this.forEachFrom(after, event => this.remove(event));\n    return this;\n  }\n  /**\n   * Set the root node as the given node\n   */\n\n\n  _setRoot(node) {\n    this._root = node;\n\n    if (this._root !== null) {\n      this._root.parent = null;\n    }\n  }\n  /**\n   * Replace the references to the node in the node's parent\n   * with the replacement node.\n   */\n\n\n  _replaceNodeInParent(node, replacement) {\n    if (node.parent !== null) {\n      if (node.isLeftChild()) {\n        node.parent.left = replacement;\n      } else {\n        node.parent.right = replacement;\n      }\n\n      this._rebalance(node.parent);\n    } else {\n      this._setRoot(replacement);\n    }\n  }\n  /**\n   * Remove the node from the tree and replace it with\n   * a successor which follows the schema.\n   */\n\n\n  _removeNode(node) {\n    if (node.left === null && node.right === null) {\n      this._replaceNodeInParent(node, null);\n    } else if (node.right === null) {\n      this._replaceNodeInParent(node, node.left);\n    } else if (node.left === null) {\n      this._replaceNodeInParent(node, node.right);\n    } else {\n      const balance = node.getBalance();\n      let replacement;\n      let temp = null;\n\n      if (balance > 0) {\n        if (node.left.right === null) {\n          replacement = node.left;\n          replacement.right = node.right;\n          temp = replacement;\n        } else {\n          replacement = node.left.right;\n\n          while (replacement.right !== null) {\n            replacement = replacement.right;\n          }\n\n          if (replacement.parent) {\n            replacement.parent.right = replacement.left;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n      } else if (node.right.left === null) {\n        replacement = node.right;\n        replacement.left = node.left;\n        temp = replacement;\n      } else {\n        replacement = node.right.left;\n\n        while (replacement.left !== null) {\n          replacement = replacement.left;\n        }\n\n        if (replacement.parent) {\n          replacement.parent.left = replacement.right;\n          temp = replacement.parent;\n          replacement.left = node.left;\n          replacement.right = node.right;\n        }\n      }\n\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n      } else {\n        this._setRoot(replacement);\n      }\n\n      if (temp) {\n        this._rebalance(temp);\n      }\n    }\n\n    node.dispose();\n  }\n  /**\n   * Rotate the tree to the left\n   */\n\n\n  _rotateLeft(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.right the new root of this sub tree (instead of node)\n\n    const pivotNode = node.right;\n\n    if (pivotNode) {\n      node.right = pivotNode.left;\n      pivotNode.left = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Rotate the tree to the right\n   */\n\n\n  _rotateRight(node) {\n    const parent = node.parent;\n    const isLeftChild = node.isLeftChild(); // Make node.left the new root of this sub tree (instead of node)\n\n    const pivotNode = node.left;\n\n    if (pivotNode) {\n      node.left = pivotNode.right;\n      pivotNode.right = node;\n    }\n\n    if (parent !== null) {\n      if (isLeftChild) {\n        parent.left = pivotNode;\n      } else {\n        parent.right = pivotNode;\n      }\n    } else {\n      this._setRoot(pivotNode);\n    }\n  }\n  /**\n   * Balance the BST\n   */\n\n\n  _rebalance(node) {\n    const balance = node.getBalance();\n\n    if (balance > 1 && node.left) {\n      if (node.left.getBalance() < 0) {\n        this._rotateLeft(node.left);\n      } else {\n        this._rotateRight(node);\n      }\n    } else if (balance < -1 && node.right) {\n      if (node.right.getBalance() > 0) {\n        this._rotateRight(node.right);\n      } else {\n        this._rotateLeft(node);\n      }\n    }\n  }\n  /**\n   * Get an event whose time and duration span the give time. Will\n   * return the match whose \"time\" value is closest to the given time.\n   * @return  The event which spans the desired time\n   */\n\n\n  get(time) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      if (results.length > 0) {\n        let max = results[0];\n\n        for (let i = 1; i < results.length; i++) {\n          if (results[i].low > max.low) {\n            max = results[i];\n          }\n        }\n\n        return max.event;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Iterate over everything in the timeline.\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEach(callback) {\n    if (this._root !== null) {\n      const allNodes = [];\n\n      this._root.traverse(node => allNodes.push(node));\n\n      allNodes.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the given time\n   * overlaps with the time and duration time of the event.\n   * @param  time The time to check if items are overlapping\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachAtTime(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.search(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Iterate over everything in the array in which the time is greater\n   * than or equal to the given time.\n   * @param  time The time to check if items are before\n   * @param  callback The callback to invoke with every item\n   */\n\n\n  forEachFrom(time, callback) {\n    if (this._root !== null) {\n      const results = [];\n\n      this._root.searchAfter(time, results);\n\n      results.forEach(node => {\n        if (node.event) {\n          callback(node.event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._root !== null) {\n      this._root.traverse(node => node.dispose());\n    }\n\n    this._root = null;\n    return this;\n  }\n\n} //-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n\nclass IntervalNode {\n  constructor(low, high, event) {\n    // the nodes to the left\n    this._left = null; // the nodes to the right\n\n    this._right = null; // the parent node\n\n    this.parent = null; // the number of child nodes\n\n    this.height = 0;\n    this.event = event; // the low value\n\n    this.low = low; // the high value\n\n    this.high = high; // the high value for this and all child nodes\n\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n\n\n  insert(node) {\n    if (node.low <= this.low) {\n      if (this.left === null) {\n        this.left = node;\n      } else {\n        this.left.insert(node);\n      }\n    } else if (this.right === null) {\n      this.right = node;\n    } else {\n      this.right.insert(node);\n    }\n  }\n  /**\n   * Search the tree for nodes which overlap\n   * with the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  search(point, results) {\n    // If p is to the right of the rightmost point of any interval\n    // in this node and all children, there won't be any matches.\n    if (point > this.max) {\n      return;\n    } // Search left children\n\n\n    if (this.left !== null) {\n      this.left.search(point, results);\n    } // Check this node\n\n\n    if (this.low <= point && this.high > point) {\n      results.push(this);\n    } // If p is to the left of the time of this interval,\n    // then it can't be in any child to the right.\n\n\n    if (this.low > point) {\n      return;\n    } // Search right children\n\n\n    if (this.right !== null) {\n      this.right.search(point, results);\n    }\n  }\n  /**\n   * Search the tree for nodes which are less\n   * than the given point\n   * @param  point  The point to query\n   * @param  results  The array to put the results\n   */\n\n\n  searchAfter(point, results) {\n    // Check this node\n    if (this.low >= point) {\n      results.push(this);\n\n      if (this.left !== null) {\n        this.left.searchAfter(point, results);\n      }\n    } // search the right side\n\n\n    if (this.right !== null) {\n      this.right.searchAfter(point, results);\n    }\n  }\n  /**\n   * Invoke the callback on this element and both it's branches\n   * @param  {Function}  callback\n   */\n\n\n  traverse(callback) {\n    callback(this);\n\n    if (this.left !== null) {\n      this.left.traverse(callback);\n    }\n\n    if (this.right !== null) {\n      this.right.traverse(callback);\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateHeight() {\n    if (this.left !== null && this.right !== null) {\n      this.height = Math.max(this.left.height, this.right.height) + 1;\n    } else if (this.right !== null) {\n      this.height = this.right.height + 1;\n    } else if (this.left !== null) {\n      this.height = this.left.height + 1;\n    } else {\n      this.height = 0;\n    }\n  }\n  /**\n   * Update the height of the node\n   */\n\n\n  updateMax() {\n    this.max = this.high;\n\n    if (this.left !== null) {\n      this.max = Math.max(this.max, this.left.max);\n    }\n\n    if (this.right !== null) {\n      this.max = Math.max(this.max, this.right.max);\n    }\n  }\n  /**\n   * The balance is how the leafs are distributed on the node\n   * @return  Negative numbers are balanced to the right\n   */\n\n\n  getBalance() {\n    let balance = 0;\n\n    if (this.left !== null && this.right !== null) {\n      balance = this.left.height - this.right.height;\n    } else if (this.left !== null) {\n      balance = this.left.height + 1;\n    } else if (this.right !== null) {\n      balance = -(this.right.height + 1);\n    }\n\n    return balance;\n  }\n  /**\n   * @returns true if this node is the left child of its parent\n   */\n\n\n  isLeftChild() {\n    return this.parent !== null && this.parent.left === this;\n  }\n  /**\n   * get/set the left node\n   */\n\n\n  get left() {\n    return this._left;\n  }\n\n  set left(node) {\n    this._left = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * get/set the right node\n   */\n\n\n  get right() {\n    return this._right;\n  }\n\n  set right(node) {\n    this._right = node;\n\n    if (node !== null) {\n      node.parent = this;\n    }\n\n    this.updateHeight();\n    this.updateMax();\n  }\n  /**\n   * null out references.\n   */\n\n\n  dispose() {\n    this.parent = null;\n    this._left = null;\n    this._right = null;\n    this.event = null;\n  }\n\n}","import { noOp } from \"../util/Interface\";\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\n\nexport class TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    /**\n     * The unique id of the event\n     */\n    this.id = TransportEvent._eventId++;\n    const options = Object.assign(TransportEvent.getDefaults(), opts);\n    this.transport = transport;\n    this.callback = options.callback;\n    this._once = options.once;\n    this.time = options.time;\n  }\n\n  static getDefaults() {\n    return {\n      callback: noOp,\n      once: false,\n      time: 0\n    };\n  }\n  /**\n   * Invoke the event callback.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    if (this.callback) {\n      this.callback(time);\n\n      if (this._once) {\n        this.transport.clear(this.id);\n      }\n    }\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    this.callback = undefined;\n    return this;\n  }\n\n}\n/**\n * Current ID counter\n */\n\nTransportEvent._eventId = 0;","import { TicksClass } from \"../type/Ticks\";\nimport { TransportEvent } from \"./TransportEvent\";\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\n\nexport class TransportRepeatEvent extends TransportEvent {\n  /**\n   * @param transport The transport object which the event belongs to\n   */\n  constructor(transport, opts) {\n    super(transport, opts);\n    /**\n     * The ID of the current timeline event\n     */\n\n    this._currentId = -1;\n    /**\n     * The ID of the next timeline event\n     */\n\n    this._nextId = -1;\n    /**\n     * The time of the next event\n     */\n\n    this._nextTick = this.time;\n    /**\n     * a reference to the bound start method\n     */\n\n    this._boundRestart = this._restart.bind(this);\n    const options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n    this.duration = new TicksClass(transport.context, options.duration).valueOf();\n    this._interval = new TicksClass(transport.context, options.interval).valueOf();\n    this._nextTick = options.time;\n    this.transport.on(\"start\", this._boundRestart);\n    this.transport.on(\"loopStart\", this._boundRestart);\n    this.context = this.transport.context;\n\n    this._restart();\n  }\n\n  static getDefaults() {\n    return Object.assign({}, TransportEvent.getDefaults(), {\n      duration: Infinity,\n      interval: 1,\n      once: false\n    });\n  }\n  /**\n   * Invoke the callback. Returns the tick time which\n   * the next event should be scheduled at.\n   * @param  time  The AudioContext time in seconds of the event\n   */\n\n\n  invoke(time) {\n    // create more events if necessary\n    this._createEvents(time); // call the super class\n\n\n    super.invoke(time);\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _createEvents(time) {\n    // schedule the next event\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n      this._nextTick += this._interval;\n      this._currentId = this._nextId;\n      this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    }\n  }\n  /**\n   * Push more events onto the timeline to keep up with the position of the timeline\n   */\n\n\n  _restart(time) {\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this._nextTick = this.time;\n    const ticks = this.transport.getTicksAtTime(time);\n\n    if (ticks > this.time) {\n      this._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n    }\n\n    this._currentId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n    this._nextTick += this._interval;\n    this._nextId = this.transport.scheduleOnce(this.invoke.bind(this), new TicksClass(this.context, this._nextTick).toSeconds());\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.transport.clear(this._currentId);\n    this.transport.clear(this._nextId);\n    this.transport.off(\"start\", this._boundRestart);\n    this.transport.off(\"loopStart\", this._boundRestart);\n    return this;\n  }\n\n}","import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Transport extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Transport.getDefaults(), arguments));\n    this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    this._swingAmount = 0;\n    const options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    this._ppq = options.ppq;\n    this._clock = new Clock({\n      callback: this._processTick.bind(this),\n      context: this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    this._bindClockEvents();\n\n    this.bpm = this._clock.frequency;\n    this._clock.frequency.multiplier = options.ppq;\n    this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(this, \"bpm\");\n    this._timeSignature = options.timeSignature; // SWING\n\n    this._swingTicks = options.ppq / 2; // 8n\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      bpm: 120,\n      loopEnd: \"4m\",\n      loopStart: 0,\n      ppq: 192,\n      swing: 0,\n      swingSubdivision: \"8n\",\n      timeSignature: 4\n    });\n  } //-------------------------------------\n  // \tTICKS\n  //-------------------------------------\n\n  /**\n   * called on every tick\n   * @param  tickTime clock relative tick time\n   */\n\n\n  _processTick(tickTime, ticks) {\n    // handle swing\n    if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n    ticks % (this._swingTicks * 2) !== 0) {\n      // add some swing\n      const progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n      const amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n      tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n    } // do the loop test\n\n\n    if (this._loop.get(tickTime)) {\n      if (ticks >= this._loopEnd) {\n        this.emit(\"loopEnd\", tickTime);\n\n        this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n        ticks = this._loopStart;\n        this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n        this.emit(\"loop\", tickTime);\n      }\n    } // invoke the timeline events scheduled on this tick\n\n\n    this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n  } //-------------------------------------\n  // \tSCHEDULABLE EVENTS\n  //-------------------------------------\n\n  /**\n   * Schedule an event along the timeline.\n   * @param callback The callback to be invoked at the time.\n   * @param time The time to invoke the callback at.\n   * @return The id of the event which can be used for canceling the event.\n   * @example\n   * // schedule an event on the 16th measure\n   * Tone.Transport.schedule((time) => {\n   * \t// invoked on measure 16\n   * \tconsole.log(\"measure 16!\");\n   * }, \"16:0:0\");\n   */\n\n\n  schedule(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Schedule a repeated event along the timeline. The event will fire\n   * at the `interval` starting at the `startTime` and for the specified\n   * `duration`.\n   * @param  callback   The callback to invoke.\n   * @param  interval   The duration between successive callbacks. Must be a positive number.\n   * @param  startTime  When along the timeline the events should start being invoked.\n   * @param  duration How long the event should repeat.\n   * @return  The ID of the scheduled event. Use this to cancel the event.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // a callback invoked every eighth note after the first measure\n   * Tone.Transport.scheduleRepeat((time) => {\n   * \tosc.start(time).stop(time + 0.1);\n   * }, \"8n\", \"1m\");\n   */\n\n\n  scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n    const event = new TransportRepeatEvent(this, {\n      callback,\n      duration: new TimeClass(this.context, duration).toTicks(),\n      interval: new TimeClass(this.context, interval).toTicks(),\n      time: new TransportTimeClass(this.context, startTime).toTicks()\n    }); // kick it off if the Transport is started\n    // @ts-ignore\n\n    return this._addEvent(event, this._repeatedEvents);\n  }\n  /**\n   * Schedule an event that will be removed after it is invoked.\n   * @param callback The callback to invoke once.\n   * @param time The time the callback should be invoked.\n   * @returns The ID of the scheduled event.\n   */\n\n\n  scheduleOnce(callback, time) {\n    const event = new TransportEvent(this, {\n      callback,\n      once: true,\n      time: new TransportTimeClass(this.context, time).toTicks()\n    });\n    return this._addEvent(event, this._timeline);\n  }\n  /**\n   * Clear the passed in event id from the timeline\n   * @param eventId The id of the event.\n   */\n\n\n  clear(eventId) {\n    if (this._scheduledEvents.hasOwnProperty(eventId)) {\n      const item = this._scheduledEvents[eventId.toString()];\n\n      item.timeline.remove(item.event);\n      item.event.dispose();\n      delete this._scheduledEvents[eventId.toString()];\n    }\n\n    return this;\n  }\n  /**\n   * Add an event to the correct timeline. Keep track of the\n   * timeline it was added to.\n   * @returns the event id which was just added\n   */\n\n\n  _addEvent(event, timeline) {\n    this._scheduledEvents[event.id.toString()] = {\n      event,\n      timeline\n    };\n    timeline.add(event);\n    return event.id;\n  }\n  /**\n   * Remove scheduled events from the timeline after\n   * the given time. Repeated events will be removed\n   * if their startTime is after the given time\n   * @param after Clear all events after this time.\n   */\n\n\n  cancel(after = 0) {\n    const computedAfter = this.toTicks(after);\n\n    this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\n    return this;\n  } //-------------------------------------\n  // \tSTART/STOP/PAUSE\n  //-------------------------------------\n\n  /**\n   * Bind start/stop/pause events from the clock and emit them.\n   */\n\n\n  _bindClockEvents() {\n    this._clock.on(\"start\", (time, offset) => {\n      offset = new TicksClass(this.context, offset).toSeconds();\n      this.emit(\"start\", time, offset);\n    });\n\n    this._clock.on(\"stop\", time => {\n      this.emit(\"stop\", time);\n    });\n\n    this._clock.on(\"pause\", time => {\n      this.emit(\"pause\", time);\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n   */\n\n\n  get state() {\n    return this._clock.getStateAtTime(this.now());\n  }\n  /**\n   * Start the transport and all sources synced to the transport.\n   * @param  time The time when the transport should start.\n   * @param  offset The timeline offset to start the transport.\n   * @example\n   * // start the transport in one second starting at beginning of the 5th measure.\n   * Tone.Transport.start(\"+1\", \"4:0:0\");\n   */\n\n\n  start(time, offset) {\n    let offsetTicks;\n\n    if (isDefined(offset)) {\n      offsetTicks = this.toTicks(offset);\n    } // start the clock\n\n\n    this._clock.start(time, offsetTicks);\n\n    return this;\n  }\n  /**\n   * Stop the transport and all sources synced to the transport.\n   * @param time The time when the transport should stop.\n   * @example\n   * Tone.Transport.stop();\n   */\n\n\n  stop(time) {\n    this._clock.stop(time);\n\n    return this;\n  }\n  /**\n   * Pause the transport and all sources synced to the transport.\n   */\n\n\n  pause(time) {\n    this._clock.pause(time);\n\n    return this;\n  }\n  /**\n   * Toggle the current state of the transport. If it is\n   * started, it will stop it, otherwise it will start the Transport.\n   * @param  time The time of the event\n   */\n\n\n  toggle(time) {\n    time = this.toSeconds(time);\n\n    if (this._clock.getStateAtTime(time) !== \"started\") {\n      this.start(time);\n    } else {\n      this.stop(time);\n    }\n\n    return this;\n  } //-------------------------------------\n  // \tSETTERS/GETTERS\n  //-------------------------------------\n\n  /**\n   * The time signature as just the numerator over 4.\n   * For example 4/4 would be just 4 and 6/8 would be 3.\n   * @example\n   * // common time\n   * Tone.Transport.timeSignature = 4;\n   * // 7/8\n   * Tone.Transport.timeSignature = [7, 8];\n   * // this will be reduced to a single number\n   * Tone.Transport.timeSignature; // returns 3.5\n   */\n\n\n  get timeSignature() {\n    return this._timeSignature;\n  }\n\n  set timeSignature(timeSig) {\n    if (isArray(timeSig)) {\n      timeSig = timeSig[0] / timeSig[1] * 4;\n    }\n\n    this._timeSignature = timeSig;\n  }\n  /**\n   * When the Transport.loop = true, this is the starting position of the loop.\n   */\n\n\n  get loopStart() {\n    return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n  }\n\n  set loopStart(startPosition) {\n    this._loopStart = this.toTicks(startPosition);\n  }\n  /**\n   * When the Transport.loop = true, this is the ending position of the loop.\n   */\n\n\n  get loopEnd() {\n    return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n  }\n\n  set loopEnd(endPosition) {\n    this._loopEnd = this.toTicks(endPosition);\n  }\n  /**\n   * If the transport loops or not.\n   */\n\n\n  get loop() {\n    return this._loop.get(this.now());\n  }\n\n  set loop(loop) {\n    this._loop.set(loop, this.now());\n  }\n  /**\n   * Set the loop start and stop at the same time.\n   * @example\n   * // loop over the first measure\n   * Tone.Transport.setLoopPoints(0, \"1m\");\n   * Tone.Transport.loop = true;\n   */\n\n\n  setLoopPoints(startPosition, endPosition) {\n    this.loopStart = startPosition;\n    this.loopEnd = endPosition;\n    return this;\n  }\n  /**\n   * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n   */\n\n\n  get swing() {\n    return this._swingAmount;\n  }\n\n  set swing(amount) {\n    // scale the values to a normal range\n    this._swingAmount = amount;\n  }\n  /**\n   * Set the subdivision which the swing will be applied to.\n   * The default value is an 8th note. Value must be less\n   * than a quarter note.\n   */\n\n\n  get swingSubdivision() {\n    return new TicksClass(this.context, this._swingTicks).toNotation();\n  }\n\n  set swingSubdivision(subdivision) {\n    this._swingTicks = this.toTicks(subdivision);\n  }\n  /**\n   * The Transport's position in Bars:Beats:Sixteenths.\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get position() {\n    const now = this.now();\n\n    const ticks = this._clock.getTicksAtTime(now);\n\n    return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n  }\n\n  set position(progress) {\n    const ticks = this.toTicks(progress);\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's position in seconds\n   * Setting the value will jump to that position right away.\n   */\n\n\n  get seconds() {\n    return this._clock.seconds;\n  }\n\n  set seconds(s) {\n    const now = this.now();\n\n    const ticks = this._clock.frequency.timeToTicks(s, now);\n\n    this.ticks = ticks;\n  }\n  /**\n   * The Transport's loop position as a normalized value. Always\n   * returns 0 if the transport if loop is not true.\n   */\n\n\n  get progress() {\n    if (this.loop) {\n      const now = this.now();\n\n      const ticks = this._clock.getTicksAtTime(now);\n\n      return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The transports current tick position.\n   */\n\n\n  get ticks() {\n    return this._clock.ticks;\n  }\n\n  set ticks(t) {\n    if (this._clock.ticks !== t) {\n      const now = this.now(); // stop everything synced to the transport\n\n      if (this.state === \"started\") {\n        const ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n        const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\n        this.emit(\"stop\", time);\n\n        this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n        this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n      } else {\n        this._clock.setTicksAtTime(t, now);\n      }\n    }\n  }\n  /**\n   * Get the clock's ticks at the given time.\n   * @param  time  When to get the tick value\n   * @return The tick value at the given time.\n   */\n\n\n  getTicksAtTime(time) {\n    return Math.round(this._clock.getTicksAtTime(time));\n  }\n  /**\n   * Return the elapsed seconds at the given time.\n   * @param  time  When to get the elapsed seconds\n   * @return  The number of elapsed seconds\n   */\n\n\n  getSecondsAtTime(time) {\n    return this._clock.getSecondsAtTime(time);\n  }\n  /**\n   * Pulses Per Quarter note. This is the smallest resolution\n   * the Transport timing supports. This should be set once\n   * on initialization and not set again. Changing this value\n   * after other objects have been created can cause problems.\n   */\n\n\n  get PPQ() {\n    return this._clock.frequency.multiplier;\n  }\n\n  set PPQ(ppq) {\n    this._clock.frequency.multiplier = ppq;\n  } //-------------------------------------\n  // \tSYNCING\n  //-------------------------------------\n\n  /**\n   * Returns the time aligned to the next subdivision\n   * of the Transport. If the Transport is not started,\n   * it will return 0.\n   * Note: this will not work precisely during tempo ramps.\n   * @param  subdivision  The subdivision to quantize to\n   * @return  The context time of the next subdivision.\n   * @example\n   * // the transport must be started, otherwise returns 0\n   * Tone.Transport.start();\n   * Tone.Transport.nextSubdivision(\"4n\");\n   */\n\n\n  nextSubdivision(subdivision) {\n    subdivision = this.toTicks(subdivision);\n\n    if (this.state !== \"started\") {\n      // if the transport's not started, return 0\n      return 0;\n    } else {\n      const now = this.now(); // the remainder of the current ticks and the subdivision\n\n      const transportPos = this.getTicksAtTime(now);\n      const remainingTicks = subdivision - transportPos % subdivision;\n      return this._clock.nextTickTime(remainingTicks, now);\n    }\n  }\n  /**\n   * Attaches the signal to the tempo control signal so that\n   * any changes in the tempo will change the signal in the same\n   * ratio.\n   *\n   * @param signal\n   * @param ratio Optionally pass in the ratio between the two signals.\n   * \t\t\tOtherwise it will be computed based on their current values.\n   */\n\n\n  syncSignal(signal, ratio) {\n    if (!ratio) {\n      // get the sync ratio\n      const now = this.now();\n\n      if (signal.getValueAtTime(now) !== 0) {\n        const bpm = this.bpm.getValueAtTime(now);\n        const computedFreq = 1 / (60 / bpm / this.PPQ);\n        ratio = signal.getValueAtTime(now) / computedFreq;\n      } else {\n        ratio = 0;\n      }\n    }\n\n    const ratioSignal = new Gain(ratio); // @ts-ignore\n\n    this.bpm.connect(ratioSignal); // @ts-ignore\n\n    ratioSignal.connect(signal._param);\n\n    this._syncedSignals.push({\n      initial: signal.value,\n      ratio: ratioSignal,\n      signal\n    });\n\n    signal.value = 0;\n    return this;\n  }\n  /**\n   * Unsyncs a previously synced signal from the transport's control.\n   * See Transport.syncSignal.\n   */\n\n\n  unsyncSignal(signal) {\n    for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n      const syncedSignal = this._syncedSignals[i];\n\n      if (syncedSignal.signal === signal) {\n        syncedSignal.ratio.dispose();\n        syncedSignal.signal.value = syncedSignal.initial;\n\n        this._syncedSignals.splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._clock.dispose();\n\n    writable(this, \"bpm\");\n\n    this._timeline.dispose();\n\n    this._repeatedEvents.dispose();\n\n    return this;\n  }\n\n}\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.transport = new Transport({\n    context\n  });\n});\nonContextClose(context => {\n  context.transport.dispose();\n});","import { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n * @offline 0.5 1\n * @example\n * const delay = new Tone.Delay(0.1).toDestination();\n * // connect the signal to both the delay and the destination\n * const pulse = new Tone.PulseOscillator().fan(delay, Tone.Destination);\n * // start and stop the pulse\n * pulse.start(0).stop(0.01);\n */\n\nexport class Delay extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n    this.name = \"Delay\";\n    const options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n    const maxDelayInSeconds = this.toSeconds(options.maxDelay);\n    this._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n    this._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n    this.delayTime = new Param({\n      context: this.context,\n      param: this._delayNode.delayTime,\n      units: \"time\",\n      value: options.delayTime,\n      minValue: 0,\n      maxValue: this.maxDelay\n    });\n    readOnly(this, \"delayTime\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      delayTime: 0,\n      maxDelay: 1\n    });\n  }\n  /**\n   * The maximum delay time. This cannot be changed after\n   * the value is passed into the constructor.\n   */\n\n\n  get maxDelay() {\n    return this._maxDelay;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._delayNode.disconnect();\n\n    this.delayTime.dispose();\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\n\nexport class Volume extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"Volume\";\n    const options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n    this.input = this.output = new Gain({\n      context: this.context,\n      gain: options.volume,\n      units: \"decibels\"\n    });\n    this.volume = this.output.gain;\n    readOnly(this, \"volume\");\n    this._unmutedVolume = options.volume; // set the mute initially\n\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const vol = new Tone.Volume(-12).toDestination();\n   * const osc = new Tone.Oscillator().connect(vol).start();\n   * // mute the output\n   * vol.mute = true;\n   */\n\n\n  get mute() {\n    return this.volume.value === -Infinity;\n  }\n\n  set mute(mute) {\n    if (!this.mute && mute) {\n      this._unmutedVolume = this.volume.value; // maybe it should ramp here?\n\n      this.volume.value = -Infinity;\n    } else if (this.mute && !mute) {\n      this.volume.value = this._unmutedVolume;\n    }\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.volume.dispose();\n    return this;\n  }\n\n}","import { Volume } from \"../../component/channel/Volume\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { connectSeries, ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\n\nexport class Destination extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Destination.getDefaults(), arguments));\n    this.name = \"Destination\";\n    this.input = new Volume({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The volume of the master output.\n     */\n\n    this.volume = this.input.volume;\n    const options = optionsFromArguments(Destination.getDefaults(), arguments);\n    connectSeries(this.input, this.output, this.context.rawContext.destination);\n    this.mute = options.mute;\n    this._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const oscillator = new Tone.Oscillator().start().toDestination();\n   * setTimeout(() => {\n   * \t// mute the output\n   * \tTone.Destination.mute = true;\n   * }, 1000);\n   */\n\n\n  get mute() {\n    return this.input.mute;\n  }\n\n  set mute(mute) {\n    this.input.mute = mute;\n  }\n  /**\n   * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n   * chained in the master effects chain.\n   * @param args All arguments will be connected in a row and the Master will be routed through it.\n   * @example\n   * // route all audio through a filter and compressor\n   * const lowpass = new Tone.Filter(800, \"lowpass\");\n   * const compressor = new Tone.Compressor(-18);\n   * Tone.Destination.chain(lowpass, compressor);\n   */\n\n\n  chain(...args) {\n    this.input.disconnect();\n    args.unshift(this.input);\n    args.push(this.output);\n    connectSeries(...args);\n    return this;\n  }\n  /**\n   * The maximum number of channels the system can output\n   * @example\n   * console.log(Tone.Destination.maxChannelCount);\n   */\n\n\n  get maxChannelCount() {\n    return this.context.rawContext.destination.maxChannelCount;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.volume.dispose();\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.destination = new Destination({\n    context\n  });\n});\nonContextClose(context => {\n  context.destination.dispose();\n});","import { __awaiter } from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\n\nexport function Offline(callback, duration, channels = 2, sampleRate = getContext().sampleRate) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // set the OfflineAudioContext based on the current context\n    const originalContext = getContext();\n    const context = new OfflineContext(channels, duration, sampleRate);\n    setContext(context); // invoke the callback/scheduling\n\n    yield callback(context); // then render the audio\n\n    const bufferPromise = context.render(); // return the original AudioContext\n\n    setContext(originalContext); // await the rendering\n\n    const buffer = yield bufferPromise; // return the audio\n\n    return new ToneAudioBuffer(buffer);\n  });\n}","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\nimport { assert } from \"../util/Debug\";\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tC1: \"https://tonejs.github.io/examples/audio/casio/C1.mp3\",\n * \tC2: \"https://tonejs.github.io/examples/audio/casio/C2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t C1: \"C1.mp3\",\n * \t\t C2: \"C2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/examples/audio/casio/\"\n * });\n * @category Core\n */\n\nexport class ToneAudioBuffers extends Tone {\n  constructor() {\n    super();\n    this.name = \"ToneAudioBuffers\";\n    /**\n     * All of the buffers\n     */\n\n    this._buffers = new Map();\n    /**\n     * Keep track of the number of loaded buffers\n     */\n\n    this._loadingCount = 0;\n    const options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    this.baseUrl = options.baseUrl; // add each one\n\n    Object.keys(options.urls).forEach(name => {\n      this._loadingCount++;\n      const url = options.urls[name];\n      this.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n    });\n  }\n\n  static getDefaults() {\n    return {\n      baseUrl: \"\",\n      onerror: noOp,\n      onload: noOp,\n      urls: {}\n    };\n  }\n  /**\n   * True if the buffers object has a buffer by that name.\n   * @param  name  The key or index of the buffer.\n   */\n\n\n  has(name) {\n    return this._buffers.has(name.toString());\n  }\n  /**\n   * Get a buffer by name. If an array was loaded,\n   * then use the array index.\n   * @param  name  The key or index of the buffer.\n   */\n\n\n  get(name) {\n    assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n    return this._buffers.get(name.toString());\n  }\n  /**\n   * A buffer was loaded. decrement the counter.\n   */\n\n\n  _bufferLoaded(callback) {\n    this._loadingCount--;\n\n    if (this._loadingCount === 0 && callback) {\n      callback();\n    }\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n  }\n  /**\n   * Add a buffer by name and url to the Buffers\n   * @param  name      A unique name to give the buffer\n   * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   * @param  onerror  Invoked if the buffer can't be loaded\n   */\n\n\n  add(name, url, callback = noOp, onerror = noOp) {\n    if (isString(url)) {\n      this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n    } else {\n      this._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n    }\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.forEach(buffer => buffer.dispose());\n\n    this._buffers.clear();\n\n    return this;\n  }\n\n}","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass } from \"./Frequency\";\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @category Unit\n */\n\nexport class MidiClass extends FrequencyClass {\n  constructor() {\n    super(...arguments);\n    this.name = \"MidiClass\";\n    this.defaultUnits = \"midi\";\n  }\n  /**\n   * Returns the value of a frequency in the current units\n   */\n\n\n  _frequencyToUnits(freq) {\n    return ftom(super._frequencyToUnits(freq));\n  }\n  /**\n   * Returns the value of a tick in the current time units\n   */\n\n\n  _ticksToUnits(ticks) {\n    return ftom(super._ticksToUnits(ticks));\n  }\n  /**\n   * Return the value of the beats in the current units\n   */\n\n\n  _beatsToUnits(beats) {\n    return ftom(super._beatsToUnits(beats));\n  }\n  /**\n   * Returns the value of a second in the current units\n   */\n\n\n  _secondsToUnits(seconds) {\n    return ftom(super._secondsToUnits(seconds));\n  }\n  /**\n   * Return the value of the frequency as a MIDI note\n   * @example\n   * Tone.Midi(60).toMidi(); // 60\n   */\n\n\n  toMidi() {\n    return this.valueOf();\n  }\n  /**\n   * Return the value of the frequency as a MIDI note\n   * @example\n   * Tone.Midi(60).toFrequency(); // 261.6255653005986\n   */\n\n\n  toFrequency() {\n    return mtof(this.toMidi());\n  }\n  /**\n   * Transposes the frequency by the given number of semitones.\n   * @return A new transposed MidiClass\n   * @example\n   * Tone.Midi(\"A4\").transpose(3); // \"C5\"\n   */\n\n\n  transpose(interval) {\n    return new MidiClass(this.context, this.toMidi() + interval);\n  }\n\n}\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\n\nexport function Midi(value, units) {\n  return new MidiClass(getContext(), value, units);\n}","import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { Timeline } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\n\nexport class Draw extends ToneWithContext {\n  constructor() {\n    super(...arguments);\n    this.name = \"Draw\";\n    /**\n     * The duration after which events are not invoked.\n     */\n\n    this.expiration = 0.25;\n    /**\n     * The amount of time before the scheduled time\n     * that the callback can be invoked. Default is\n     * half the time of an animation frame (0.008 seconds).\n     */\n\n    this.anticipation = 0.008;\n    /**\n     * All of the events.\n     */\n\n    this._events = new Timeline();\n    /**\n     * The draw loop\n     */\n\n    this._boundDrawLoop = this._drawLoop.bind(this);\n    /**\n     * The animation frame id\n     */\n\n    this._animationFrame = -1;\n  }\n  /**\n   * Schedule a function at the given time to be invoked\n   * on the nearest animation frame.\n   * @param  callback  Callback is invoked at the given time.\n   * @param  time      The time relative to the AudioContext time to invoke the callback.\n   * @example\n   * Tone.Transport.scheduleRepeat(time => {\n   * \tTone.Draw.schedule(() => console.log(time), time);\n   * }, 1);\n   * Tone.Transport.start();\n   */\n\n\n  schedule(callback, time) {\n    this._events.add({\n      callback,\n      time: this.toSeconds(time)\n    }); // start the draw loop on the first event\n\n\n    if (this._events.length === 1) {\n      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel events scheduled after the given time\n   * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n   */\n\n\n  cancel(after) {\n    this._events.cancel(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * The draw loop\n   */\n\n\n  _drawLoop() {\n    const now = this.context.currentTime;\n\n    while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n      const event = this._events.shift();\n\n      if (event && now - event.time <= this.expiration) {\n        event.callback();\n      }\n    }\n\n    if (this._events.length > 0) {\n      this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._events.dispose();\n\n    cancelAnimationFrame(this._animationFrame);\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.draw = new Draw({\n    context\n  });\n});\nonContextClose(context => {\n  context.draw.dispose();\n});","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport class Source extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    /**\n     * Sources have no inputs\n     */\n\n    this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    this._syncedStart = noOp;\n    this._syncedStop = noOp;\n    this._state.memory = 100;\n    this._state.increasing = true;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.onstop = options.onstop;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      onstop: noOp,\n      volume: 0\n    });\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n   * \tplayer.start();\n   * \tconsole.log(player.state);\n   * }).toDestination();\n   */\n\n\n  get state() {\n    if (this._synced) {\n      if (this.context.transport.state === \"started\") {\n        return this._state.getValueAtTime(this.context.transport.seconds);\n      } else {\n        return \"stopped\";\n      }\n    } else {\n      return this._state.getValueAtTime(this.now());\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * // mute the output\n   * osc.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * Ensure that the scheduled time is not before the current time.\n   * Should only be used when scheduled unsynced.\n   */\n\n\n  _clampToCurrentTime(time) {\n    if (this._synced) {\n      return time;\n    } else {\n      return Math.max(time, this.context.currentTime);\n    }\n  }\n  /**\n   * Start the source at the specified time. If no time is given,\n   * start the source now.\n   * @param  time When the source should be started.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n   */\n\n\n  start(time, offset, duration) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n    if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n      // time should be strictly greater than the previous start time\n      assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      this.log(\"restart\", computedTime);\n      this.restart(computedTime, offset, duration);\n    } else {\n      this.log(\"start\", computedTime);\n\n      this._state.setStateAtTime(\"started\", computedTime);\n\n      if (this._synced) {\n        // add the offset time to the event\n        const event = this._state.get(computedTime);\n\n        if (event) {\n          event.offset = this.toSeconds(defaultArg(offset, 0));\n          event.duration = duration ? this.toSeconds(duration) : undefined;\n        }\n\n        const sched = this.context.transport.schedule(t => {\n          this._start(t, offset, duration);\n        }, computedTime);\n\n        this._scheduled.push(sched); // if it's already started\n\n\n        if (this.context.transport.state === \"started\") {\n          this._syncedStart(this.now(), this.context.transport.seconds);\n        }\n      } else {\n        this._start(computedTime, offset, duration);\n      }\n\n      assertContextRunning(this.context);\n    }\n\n    return this;\n  }\n  /**\n   * Stop the source at the specified time. If no time is given,\n   * stop the source now.\n   * @param  time When the source should be stopped.\n   * @example\n   * const source = new Tone.Oscillator().toDestination();\n   * source.start();\n   * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n   */\n\n\n  stop(time) {\n    let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n    computedTime = this._clampToCurrentTime(computedTime);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n      this.log(\"stop\", computedTime);\n\n      if (!this._synced) {\n        this._stop(computedTime);\n      } else {\n        const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n        this._scheduled.push(sched);\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n    }\n\n    return this;\n  }\n  /**\n   * Restart the source.\n   */\n\n\n  restart(time, offset, duration) {\n    time = this.toSeconds(time);\n\n    if (this._state.getValueAtTime(time) === \"started\") {\n      this._state.cancel(time);\n\n      this._restart(time, offset, duration);\n    }\n\n    return this;\n  }\n  /**\n   * Sync the source to the Transport so that all subsequent\n   * calls to `start` and `stop` are synced to the TransportTime\n   * instead of the AudioContext time.\n   *\n   * @example\n   * const osc = new Tone.Oscillator().toDestination();\n   * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n   * osc.sync().start(0).stop(0.3);\n   * // start the transport.\n   * Tone.Transport.start();\n   * // set it to loop once a second\n   * Tone.Transport.loop = true;\n   * Tone.Transport.loopEnd = 1;\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncedStart = (time, offset) => {\n        if (offset > 0) {\n          // get the playback state at that time\n          const stateEvent = this._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n          if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n            // get the offset\n            const startOffset = offset - this.toSeconds(stateEvent.time);\n            let duration;\n\n            if (stateEvent.duration) {\n              duration = this.toSeconds(stateEvent.duration) - startOffset;\n            }\n\n            this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n          }\n        }\n      };\n\n      this._syncedStop = time => {\n        const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\n        if (this._state.getValueAtTime(seconds) === \"started\") {\n          this._stop(time);\n        }\n      };\n\n      this.context.transport.on(\"start\", this._syncedStart);\n      this.context.transport.on(\"loopStart\", this._syncedStart);\n      this.context.transport.on(\"stop\", this._syncedStop);\n      this.context.transport.on(\"pause\", this._syncedStop);\n      this.context.transport.on(\"loopEnd\", this._syncedStop);\n    }\n\n    return this;\n  }\n  /**\n   * Unsync the source to the Transport. See Source.sync\n   */\n\n\n  unsync() {\n    if (this._synced) {\n      this.context.transport.off(\"stop\", this._syncedStop);\n      this.context.transport.off(\"pause\", this._syncedStop);\n      this.context.transport.off(\"loopEnd\", this._syncedStop);\n      this.context.transport.off(\"start\", this._syncedStart);\n      this.context.transport.off(\"loopStart\", this._syncedStart);\n    }\n\n    this._synced = false; // clear all of the scheduled ids\n\n    this._scheduled.forEach(id => this.context.transport.clear(id));\n\n    this._scheduled = [];\n\n    this._state.cancel(0);\n\n    return this;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.onstop = noOp;\n    this.unsync();\n\n    this._volume.dispose();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\n\nexport class ToneBufferSource extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n\n    this._source = this.context.createBufferSource();\n    this._internalChannels = [this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n\n    this._sourceStarted = false;\n    this._sourceStopped = false;\n    const options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(this._source, this._gainNode);\n\n    this._source.onended = () => this._stopSource();\n    /**\n     * The playbackRate of the buffer\n     */\n\n\n    this.playbackRate = new Param({\n      context: this.context,\n      param: this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    }); // set some values initially\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n    this._internalChannels.push(this._source);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      url: new ToneAudioBuffer(),\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1\n    });\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(t) {\n    this._fadeIn = t;\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(t) {\n    this._fadeOut = t;\n  }\n  /**\n   * The curve applied to the fades, either \"linear\" or \"exponential\"\n   */\n\n\n  get curve() {\n    return this._curve;\n  }\n\n  set curve(t) {\n    this._curve = t;\n  }\n  /**\n   * Start the buffer\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   * @param  gain  The gain to play the buffer back at.\n   */\n\n\n  start(time, offset, duration, gain = 1) {\n    assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n    const computedTime = this.toSeconds(time); // apply the gain envelope\n\n    this._startGain(computedTime, gain); // if it's a loop the default offset is the loopstart point\n\n\n    if (this.loop) {\n      offset = defaultArg(offset, this.loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // make sure the offset is not less than 0\n\n\n    let computedOffset = Math.max(this.toSeconds(offset), 0); // start the buffer source\n\n    if (this.loop) {\n      // modify the offset if it's greater than the loop time\n      const loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      const loopStart = this.toSeconds(this.loopStart);\n      const loopDuration = loopEnd - loopStart; // move the offset back\n\n      if (GTE(computedOffset, loopEnd)) {\n        computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n      } // when the offset is very close to the duration, set it to 0\n\n\n      if (EQ(computedOffset, this.buffer.duration)) {\n        computedOffset = 0;\n      }\n    } // this.buffer.loaded would have return false if the AudioBuffer was undefined\n\n\n    this._source.buffer = this.buffer.get();\n    this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\n    if (LT(computedOffset, this.buffer.duration)) {\n      this._sourceStarted = true;\n\n      this._source.start(computedTime, computedOffset);\n    } // if a duration is given, schedule a stop\n\n\n    if (isDefined(duration)) {\n      let computedDur = this.toSeconds(duration); // make sure it's never negative\n\n      computedDur = Math.max(computedDur, 0);\n      this.stop(computedTime + computedDur);\n    }\n\n    return this;\n  }\n\n  _stopSource(time) {\n    if (!this._sourceStopped && this._sourceStarted) {\n      this._sourceStopped = true;\n\n      this._source.stop(this.toSeconds(time));\n\n      this._onended();\n    }\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n\n\n  get loopStart() {\n    return this._source.loopStart;\n  }\n\n  set loopStart(loopStart) {\n    this._source.loopStart = this.toSeconds(loopStart);\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n\n\n  get loopEnd() {\n    return this._source.loopEnd;\n  }\n\n  set loopEnd(loopEnd) {\n    this._source.loopEnd = this.toSeconds(loopEnd);\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n\n\n  get loop() {\n    return this._source.loop;\n  }\n\n  set loop(loop) {\n    this._source.loop = loop;\n\n    if (this._sourceStarted) {\n      this.cancelStop();\n    }\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this._source.onended = null;\n\n    this._source.disconnect();\n\n    this._buffer.dispose();\n\n    this.playbackRate.dispose();\n    return this;\n  }\n\n}","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport class Noise extends Source {\n  constructor() {\n    super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    this._source = null;\n    const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    this._playbackRate = options.playbackRate;\n    this.type = options.type;\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      fadeIn: 0,\n      fadeOut: 0,\n      playbackRate: 1,\n      type: \"white\"\n    });\n  }\n  /**\n   * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n   * @example\n   * const noise = new Tone.Noise().toDestination().start();\n   * noise.type = \"brown\";\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n    if (this._type !== type) {\n      this._type = type; // if it's playing, stop and restart it\n\n      if (this.state === \"started\") {\n        const now = this.now();\n\n        this._stop(now);\n\n        this._start(now);\n      }\n    }\n  }\n  /**\n   * The playback rate of the noise. Affects\n   * the \"frequency\" of the noise.\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n\n    if (this._source) {\n      this._source.playbackRate.value = rate;\n    }\n  }\n  /**\n   * internal start method\n   */\n\n\n  _start(time) {\n    const buffer = _noiseBuffers[this._type];\n    this._source = new ToneBufferSource({\n      url: buffer,\n      context: this.context,\n      fadeIn: this._fadeIn,\n      fadeOut: this._fadeOut,\n      loop: true,\n      onended: () => this.onstop(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output);\n\n    this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n  }\n  /**\n   * internal stop method\n   */\n\n\n  _stop(time) {\n    if (this._source) {\n      this._source.stop(this.toSeconds(time));\n\n      this._source = null;\n    }\n  }\n  /**\n   * The fadeIn time of the amplitude envelope.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(time) {\n    this._fadeIn = time;\n\n    if (this._source) {\n      this._source.fadeIn = this._fadeIn;\n    }\n  }\n  /**\n   * The fadeOut time of the amplitude envelope.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(time) {\n    this._fadeOut = time;\n\n    if (this._source) {\n      this._source.fadeOut = this._fadeOut;\n    }\n  }\n\n  _restart(time) {\n    // TODO could be optimized by cancelling the buffer source 'stop'\n    this._stop(time);\n\n    this._start(time);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this._source) {\n      this._source.disconnect();\n    }\n\n    return this;\n  }\n\n} //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nconst _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nconst _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let lastOut = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        let b0, b1, b2, b3, b4, b5, b6;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          const white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      const buffer = [];\n\n      for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        const channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (let i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const mic = new Tone.UserMedia();\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"UserMedia\";\n    const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n\n\n  open(labelOrId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n      if (this.state === \"started\") {\n        this.close();\n      }\n\n      const devices = yield UserMedia.enumerateDevices();\n\n      if (isNumber(labelOrId)) {\n        this._device = devices[labelOrId];\n      } else {\n        this._device = devices.find(device => {\n          return device.label === labelOrId || device.deviceId === labelOrId;\n        }); // didn't find a matching device\n\n        if (!this._device && devices.length > 0) {\n          this._device = devices[0];\n        }\n\n        assert(isDefined(this._device), `No matching device ${labelOrId}`);\n      } // do getUserMedia\n\n\n      const constraints = {\n        audio: {\n          echoCancellation: false,\n          sampleRate: this.context.sampleRate,\n          noiseSuppression: false,\n          mozNoiseSuppression: false\n        }\n      };\n\n      if (this._device) {\n        // @ts-ignore\n        constraints.audio.deviceId = this._device.deviceId;\n      }\n\n      const stream = yield navigator.mediaDevices.getUserMedia(constraints); // start a new source only if the previous one is closed\n\n      if (!this._stream) {\n        this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n        const mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n        connect(mediaStreamNode, this.output);\n        this._mediaStream = mediaStreamNode;\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Close the media stream\n   */\n\n\n  close() {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n\n      this._stream = undefined; // remove the old media stream\n\n      this._mediaStream.disconnect();\n\n      this._mediaStream = undefined;\n    }\n\n    this._device = undefined;\n    return this;\n  }\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * Tone.UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n\n\n  static enumerateDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allDevices = yield navigator.mediaDevices.enumerateDevices();\n      return allDevices.filter(device => {\n        return device.kind === \"audioinput\";\n      });\n    });\n  }\n  /**\n   * Returns the playback state of the source, \"started\" when the microphone is open\n   * and \"stopped\" when the mic is closed.\n   */\n\n\n  get state() {\n    return this._stream && this._stream.active ? \"started\" : \"stopped\";\n  }\n  /**\n   * Returns an identifier for the represented device that is\n   * persisted across sessions. It is un-guessable by other applications and\n   * unique to the origin of the calling application. It is reset when the\n   * user clears cookies (for Private Browsing, a different identifier is\n   * used that is not persisted across sessions). Returns undefined when the\n   * device is not open.\n   */\n\n\n  get deviceId() {\n    if (this._device) {\n      return this._device.deviceId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a group identifier. Two devices have the\n   * same group identifier if they belong to the same physical device.\n   * Returns null  when the device is not open.\n   */\n\n\n  get groupId() {\n    if (this._device) {\n      return this._device.groupId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a label describing this device (for example \"Built-in Microphone\").\n   * Returns undefined when the device is not open or label is not available\n   * because of permissions.\n   */\n\n\n  get label() {\n    if (this._device) {\n      return this._device.label;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const mic = new Tone.UserMedia();\n   * mic.open().then(() => {\n   * \t// promise resolves when input is available\n   * });\n   * // mute the output\n   * mic.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n    this.close();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n  /**\n   * If getUserMedia is supported by the browser.\n   */\n\n\n  static get supported() {\n    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\n\nexport function generateWaveform(instance, length) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const duration = length / instance.context.sampleRate;\n    const context = new OfflineContext(1, duration, instance.context.sampleRate);\n    const clone = new instance.constructor(Object.assign(instance.get(), {\n      // should do 2 iterations\n      frequency: 2 / duration,\n      // zero out the detune\n      detune: 0,\n      context\n    })).toDestination();\n    clone.start(0);\n    const buffer = yield context.render();\n    return buffer.getChannelData(0);\n  });\n}","import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\n\nexport class ToneOscillatorNode extends OneShotSource {\n  constructor() {\n    super(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"ToneOscillatorNode\";\n    /**\n     * The oscillator\n     */\n\n    this._oscillator = this.context.createOscillator();\n    this._internalChannels = [this._oscillator];\n    const options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    connect(this._oscillator, this._gainNode);\n    this.type = options.type;\n    this.frequency = new Param({\n      context: this.context,\n      param: this._oscillator.frequency,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Param({\n      context: this.context,\n      param: this._oscillator.detune,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(OneShotSource.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      type: \"sine\"\n    });\n  }\n  /**\n   * Start the oscillator node at the given time\n   * @param  time When to start the oscillator\n   */\n\n\n  start(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"start\", computedTime);\n\n    this._startGain(computedTime);\n\n    this._oscillator.start(computedTime);\n\n    return this;\n  }\n\n  _stopSource(time) {\n    this._oscillator.stop(time);\n  }\n  /**\n   * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n   * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n   */\n\n\n  setPeriodicWave(periodicWave) {\n    this._oscillator.setPeriodicWave(periodicWave);\n\n    return this;\n  }\n  /**\n   * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    if (this.state === \"started\") {\n      this.stop();\n    }\n\n    this._oscillator.disconnect();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nexport class Oscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    this._oscillator = null;\n    const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(this, \"frequency\");\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, \"detune\");\n    this._partials = options.partials;\n    this._partialCount = options.partialCount;\n    this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      this._type = this.baseType + options.partialCount.toString();\n    }\n\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      partialCount: 0,\n      partials: [],\n      phase: 0,\n      type: \"sine\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    const computedTime = this.toSeconds(time); // new oscillator with previous values\n\n    const oscillator = new ToneOscillatorNode({\n      context: this.context,\n      onended: () => this.onstop(this)\n    });\n    this._oscillator = oscillator;\n\n    if (this._wave) {\n      this._oscillator.setPeriodicWave(this._wave);\n    } else {\n      this._oscillator.type = this._type;\n    } // connect the control signal to the oscillator frequency & detune\n\n\n    this._oscillator.connect(this.output);\n\n    this.frequency.connect(this._oscillator.frequency);\n    this.detune.connect(this._oscillator.detune); // start the oscillator\n\n    this._oscillator.start(computedTime);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    if (this._oscillator) {\n      this._oscillator.stop(computedTime);\n    }\n  }\n  /**\n   * Restart the oscillator. Does not stop the oscillator, but instead\n   * just cancels any scheduled 'stop' from being invoked.\n   */\n\n\n  _restart(time) {\n    const computedTime = this.toSeconds(time);\n    this.log(\"restart\", computedTime);\n\n    if (this._oscillator) {\n      this._oscillator.cancelStop();\n    }\n\n    this._state.cancel(computedTime);\n\n    return this;\n  }\n  /**\n   * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n   * will also affect the oscillators frequency.\n   * @example\n   * const osc = new Tone.Oscillator().toDestination().start();\n   * osc.frequency.value = 440;\n   * // the ratio between the bpm and the frequency will be maintained\n   * osc.syncFrequency();\n   * // double the tempo\n   * Tone.Transport.bpm.value *= 2;\n   * // the frequency of the oscillator is doubled to 880\n   */\n\n\n  syncFrequency() {\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the oscillator's frequency from the Transport.\n   * See Oscillator.syncFrequency\n   */\n\n\n  unsyncFrequency() {\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Get a cached periodic wave. Avoids having to recompute\n   * the oscillator values when they have already been computed\n   * with the same values.\n   */\n\n\n  _getCachedPeriodicWave() {\n    if (this._type === \"custom\") {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.phase === this._phase && deepEquals(description.partials, this._partials);\n      });\n\n      return oscProps;\n    } else {\n      const oscProps = Oscillator._periodicWaveCache.find(description => {\n        return description.type === this._type && description.phase === this._phase;\n      });\n\n      this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n      return oscProps;\n    }\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n    const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n    if (this._phase === 0 && isBasicType) {\n      this._wave = undefined;\n      this._partialCount = 0; // just go with the basic approach\n\n      if (this._oscillator !== null) {\n        // already tested that it's a basic type\n        this._oscillator.type = type;\n      }\n    } else {\n      // first check if the value is cached\n      const cache = this._getCachedPeriodicWave();\n\n      if (isDefined(cache)) {\n        const {\n          partials,\n          wave\n        } = cache;\n        this._wave = wave;\n        this._partials = partials;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        }\n      } else {\n        const [real, imag] = this._getRealImaginary(type, this._phase);\n\n        const periodicWave = this.context.createPeriodicWave(real, imag);\n        this._wave = periodicWave;\n\n        if (this._oscillator !== null) {\n          this._oscillator.setPeriodicWave(this._wave);\n        } // set the cache\n\n\n        Oscillator._periodicWaveCache.push({\n          imag,\n          partialCount: this._partialCount,\n          partials: this._partials,\n          phase: this._phase,\n          real,\n          type: this._type,\n          wave: this._wave\n        });\n\n        if (Oscillator._periodicWaveCache.length > 100) {\n          Oscillator._periodicWaveCache.shift();\n        }\n      }\n    }\n  }\n\n  get baseType() {\n    return this._type.replace(this.partialCount.toString(), \"\");\n  }\n\n  set baseType(baseType) {\n    if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n      this.type = baseType + this.partialCount;\n    } else {\n      this.type = baseType;\n    }\n  }\n\n  get partialCount() {\n    return this._partialCount;\n  }\n\n  set partialCount(p) {\n    assertRange(p, 0);\n    let type = this._type;\n    const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n    if (partial) {\n      type = partial[1];\n    }\n\n    if (this._type !== \"custom\") {\n      if (p === 0) {\n        this.type = type;\n      } else {\n        this.type = type + p.toString();\n      }\n    } else {\n      // extend or shorten the partials array\n      const fullPartials = new Float32Array(p); // copy over the partials array\n\n      this._partials.forEach((v, i) => fullPartials[i] = v);\n\n      this._partials = Array.from(fullPartials);\n      this.type = this._type;\n    }\n  }\n  /**\n   * Returns the real and imaginary components based\n   * on the oscillator type.\n   * @returns [real: Float32Array, imaginary: Float32Array]\n   */\n\n\n  _getRealImaginary(type, phase) {\n    const fftSize = 4096;\n    let periodicWaveSize = fftSize / 2;\n    const real = new Float32Array(periodicWaveSize);\n    const imag = new Float32Array(periodicWaveSize);\n    let partialCount = 1;\n\n    if (type === \"custom\") {\n      partialCount = this._partials.length + 1;\n      this._partialCount = this._partials.length;\n      periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n      if (this._partials.length === 0) {\n        return [real, imag];\n      }\n    } else {\n      const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n      if (partial) {\n        partialCount = parseInt(partial[2], 10) + 1;\n        this._partialCount = parseInt(partial[2], 10);\n        type = partial[1];\n        partialCount = Math.max(partialCount, 2);\n        periodicWaveSize = partialCount;\n      } else {\n        this._partialCount = 0;\n      }\n\n      this._partials = [];\n    }\n\n    for (let n = 1; n < periodicWaveSize; ++n) {\n      const piFactor = 2 / (n * Math.PI);\n      let b;\n\n      switch (type) {\n        case \"sine\":\n          b = n <= partialCount ? 1 : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"square\":\n          b = n & 1 ? 2 * piFactor : 0;\n          this._partials[n - 1] = b;\n          break;\n\n        case \"sawtooth\":\n          b = piFactor * (n & 1 ? 1 : -1);\n          this._partials[n - 1] = b;\n          break;\n\n        case \"triangle\":\n          if (n & 1) {\n            b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n          } else {\n            b = 0;\n          }\n\n          this._partials[n - 1] = b;\n          break;\n\n        case \"custom\":\n          b = this._partials[n - 1];\n          break;\n\n        default:\n          throw new TypeError(\"Oscillator: invalid type: \" + type);\n      }\n\n      if (b !== 0) {\n        real[n] = -b * Math.sin(phase * n);\n        imag[n] = b * Math.cos(phase * n);\n      } else {\n        real[n] = 0;\n        imag[n] = 0;\n      }\n    }\n\n    return [real, imag];\n  }\n  /**\n   * Compute the inverse FFT for a given phase.\n   */\n\n\n  _inverseFFT(real, imag, phase) {\n    let sum = 0;\n    const len = real.length;\n\n    for (let i = 0; i < len; i++) {\n      sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n    }\n\n    return sum;\n  }\n  /**\n   * Returns the initial value of the oscillator when stopped.\n   * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n   */\n\n\n  getInitialValue() {\n    const [real, imag] = this._getRealImaginary(this._type, 0);\n\n    let maxValue = 0;\n    const twoPi = Math.PI * 2;\n    const testPositions = 32; // check for peaks in 16 places\n\n    for (let i = 0; i < testPositions; i++) {\n      maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n    }\n\n    return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n  }\n\n  get partials() {\n    return this._partials.slice(0, this.partialCount);\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this.type = \"custom\";\n    }\n  }\n\n  get phase() {\n    return this._phase * (180 / Math.PI);\n  }\n\n  set phase(phase) {\n    this._phase = phase * Math.PI / 180; // reset the type\n\n    this.type = this._type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._oscillator !== null) {\n      this._oscillator.dispose();\n    }\n\n    this._wave = undefined;\n    this.frequency.dispose();\n    this.detune.dispose();\n    return this;\n  }\n\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\n\nOscillator._periodicWaveCache = [];","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\n\nexport class SignalOperator extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n  }\n\n  connect(destination, outputNum = 0, inputNum = 0) {\n    connectSignal(this, destination, outputNum, inputNum);\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\n\nexport class WaveShaper extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n\n    this._shaper = this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n\n    this.input = this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n\n    this.output = this._shaper;\n    const options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      this.setMap(options.mapping, options.length);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      length: 1024\n    });\n  }\n  /**\n   * Uses a mapping function to set the value of the curve.\n   * @param mapping The function used to define the values.\n   *                The mapping function take two arguments:\n   *                the first is the value at the current position\n   *                which goes from -1 to 1 over the number of elements\n   *                in the curve array. The second argument is the array position.\n   * @example\n   * const shaper = new Tone.WaveShaper();\n   * // map the input signal from [-1, 1] to [0, 10]\n   * shaper.setMap((val, index) => (val + 1) * 5);\n   */\n\n\n  setMap(mapping, length = 1024) {\n    const array = new Float32Array(length);\n\n    for (let i = 0, len = length; i < len; i++) {\n      const normalized = i / (len - 1) * 2 - 1;\n      array[i] = mapping(normalized, i);\n    }\n\n    this.curve = array;\n    return this;\n  }\n  /**\n   * The array to set as the waveshaper curve. For linear curves\n   * array length does not make much difference, but for complex curves\n   * longer arrays will provide smoother interpolation.\n   */\n\n\n  get curve() {\n    return this._shaper.curve;\n  }\n\n  set curve(mapping) {\n    this._shaper.curve = mapping;\n  }\n  /**\n   * Specifies what type of oversampling (if any) should be used when\n   * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    const isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n    assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n    this._shaper.oversample = oversampling;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.disconnect();\n\n    return this;\n  }\n\n}","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n * @category Signal\n */\n\nexport class AudioToGain extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"AudioToGain\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._norm = new WaveShaper({\n      context: this.context,\n      mapping: x => (x + 1) / 2\n    });\n    /**\n     * The AudioRange input [-1, 1]\n     */\n\n    this.input = this._norm;\n    /**\n     * The GainRange output [0, 1]\n     */\n\n    this.output = this._norm;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._norm.dispose();\n\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal } from \"./Signal\";\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\n\nexport class Multiply extends Signal {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n    this.name = \"Multiply\";\n    /**\n     * Indicates if the value should be overridden on connection\n     */\n\n    this.override = false;\n    const options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n    this._mult = this.input = this.output = new Gain({\n      context: this.context,\n      minValue: options.minValue,\n      maxValue: options.maxValue\n    });\n    this.factor = this._param = this._mult.gain;\n    this.factor.setValueAtTime(options.value, 0);\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      value: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._mult.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @offline 0.2 1\n * @example\n * const amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * @category Source\n */\n\nexport class AMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"AMOscillator\";\n    /**\n     * convert the -1,1 output to 0,1\n     */\n\n    this._modulationScale = new AudioToGain({\n      context: this.context\n    });\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context\n    });\n    const options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.frequency = this._carrier.frequency, this.detune = this._carrier.detune;\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    }); // connections\n\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\n    this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\n    this._carrier.chain(this._modulationNode, this.output);\n\n    readOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n  }\n  /**\n   * The type of the carrier oscillator\n   */\n\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this._modulationScale.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @offline 0.1 1\n * @example\n * const fmOsc = new Tone.FMOscillator({\n * \tfrequency: 200,\n * \ttype: \"square\",\n * \tmodulationType: \"triangle\",\n * \tharmonicity: 0.2,\n * \tmodulationIndex: 3\n * }).toDestination().start();\n * @category Source\n */\n\nexport class FMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    this.name = \"FMOscillator\";\n    /**\n     * the node where the modulation happens\n     */\n\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    const options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    this._carrier = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: 0,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: options.type\n    });\n    this.detune = this._carrier.detune;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this._modulator = new Oscillator({\n      context: this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.modulationIndex\n    }); // connections\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n\n    this.detune.connect(this._modulator.detune);\n    readOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      harmonicity: 1,\n      modulationIndex: 2,\n      modulationType: \"square\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._modulator.start(time);\n\n    this._carrier.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    this._modulator.stop(time);\n\n    this._carrier.stop(time);\n  }\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._carrier.restart(time);\n\n    return this;\n  }\n\n  get type() {\n    return this._carrier.type;\n  }\n\n  set type(type) {\n    this._carrier.type = type;\n  }\n\n  get baseType() {\n    return this._carrier.baseType;\n  }\n\n  set baseType(baseType) {\n    this._carrier.baseType = baseType;\n  }\n\n  get partialCount() {\n    return this._carrier.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._carrier.partialCount = partialCount;\n  }\n  /**\n   * The type of the modulator oscillator\n   */\n\n\n  get modulationType() {\n    return this._modulator.type;\n  }\n\n  set modulationType(type) {\n    this._modulator.type = type;\n  }\n\n  get phase() {\n    return this._carrier.phase;\n  }\n\n  set phase(phase) {\n    this._carrier.phase = phase;\n    this._modulator.phase = phase;\n  }\n\n  get partials() {\n    return this._carrier.partials;\n  }\n\n  set partials(partials) {\n    this._carrier.partials = partials;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.harmonicity.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this._modulationNode.dispose();\n\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @offline 0.1 1\n * @example\n * const pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * @category Source\n */\n\nexport class PulseOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n    this.name = \"PulseOscillator\";\n    /**\n     * gate the width amount\n     */\n\n    this._widthGate = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * Threshold the signal to turn it into a square\n     */\n\n    this._thresh = new WaveShaper({\n      context: this.context,\n      mapping: val => val <= 0 ? -1 : 1\n    });\n    const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n    this.width = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: options.width\n    });\n    this._triangle = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase,\n      type: \"triangle\"\n    });\n    this.frequency = this._triangle.frequency;\n    this.detune = this._triangle.detune; // connections\n\n    this._triangle.chain(this._thresh, this.output);\n\n    this.width.chain(this._widthGate, this._thresh);\n    readOnly(this, [\"width\", \"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      phase: 0,\n      type: \"pulse\",\n      width: 0.2\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._triangle.start(time);\n\n    this._widthGate.gain.setValueAtTime(1, time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._triangle.stop(time); // the width is still connected to the output.\n    // that needs to be stopped also\n\n\n    this._widthGate.gain.cancelScheduledValues(time);\n\n    this._widthGate.gain.setValueAtTime(0, time);\n  }\n\n  _restart(time) {\n    this._triangle.restart(time);\n\n    this._widthGate.gain.cancelScheduledValues(time);\n\n    this._widthGate.gain.setValueAtTime(1, time);\n  }\n  /**\n   * The phase of the oscillator in degrees.\n   */\n\n\n  get phase() {\n    return this._triangle.phase;\n  }\n\n  set phase(phase) {\n    this._triangle.phase = phase;\n  }\n  /**\n   * The type of the oscillator. Always returns \"pulse\".\n   */\n\n\n  get type() {\n    return \"pulse\";\n  }\n  /**\n   * The baseType of the oscillator. Always returns \"pulse\".\n   */\n\n\n  get baseType() {\n    return \"pulse\";\n  }\n  /**\n   * The partials of the waveform. Cannot set partials for this waveform type\n   */\n\n\n  get partials() {\n    return [];\n  }\n  /**\n   * No partials for this waveform type.\n   */\n\n\n  get partialCount() {\n    return 0;\n  }\n  /**\n   * *Internal use* The carrier oscillator type is fed through the\n   * waveshaper node to create the pulse. Using different carrier oscillators\n   * changes oscillator's behavior.\n   */\n\n\n  set carrierType(type) {\n    this._triangle.type = type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up method.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._triangle.dispose();\n\n    this.width.dispose();\n\n    this._widthGate.dispose();\n\n    this._thresh.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\n\nexport class FatOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n\n    this._oscillators = [];\n    const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this._spread = options.spread;\n    this._type = options.type;\n    this._phase = options.phase;\n    this._partials = options.partials;\n    this._partialCount = options.partialCount; // set the count initially\n\n    this.count = options.count;\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      count: 3,\n      spread: 20,\n      type: \"sawtooth\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.start(time));\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.stop(time));\n  }\n\n  _restart(time) {\n    this._forEach(osc => osc.restart(time));\n  }\n  /**\n   * Iterate over all of the oscillators\n   */\n\n\n  _forEach(iterator) {\n    for (let i = 0; i < this._oscillators.length; i++) {\n      iterator(this._oscillators[i], i);\n    }\n  }\n  /**\n   * The type of the oscillator\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n\n    this._forEach(osc => osc.type = type);\n  }\n  /**\n   * The detune spread between the oscillators. If \"count\" is\n   * set to 3 oscillators and the \"spread\" is set to 40,\n   * the three oscillators would be detuned like this: [-20, 0, 20]\n   * for a total detune spread of 40 cents.\n   * @example\n   * const fatOsc = new Tone.FatOscillator().toDestination().start();\n   * fatOsc.spread = 70;\n   */\n\n\n  get spread() {\n    return this._spread;\n  }\n\n  set spread(spread) {\n    this._spread = spread;\n\n    if (this._oscillators.length > 1) {\n      const start = -spread / 2;\n      const step = spread / (this._oscillators.length - 1);\n\n      this._forEach((osc, i) => osc.detune.value = start + step * i);\n    }\n  }\n  /**\n   * The number of detuned oscillators. Must be an integer greater than 1.\n   * @example\n   * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n   * // use 4 sawtooth oscillators\n   * fatOsc.count = 4;\n   */\n\n\n  get count() {\n    return this._oscillators.length;\n  }\n\n  set count(count) {\n    assertRange(count, 1);\n\n    if (this._oscillators.length !== count) {\n      // dispose the previous oscillators\n      this._forEach(osc => osc.dispose());\n\n      this._oscillators = [];\n\n      for (let i = 0; i < count; i++) {\n        const osc = new Oscillator({\n          context: this.context,\n          volume: -6 - count * 1.1,\n          type: this._type,\n          phase: this._phase + i / count * 360,\n          partialCount: this._partialCount,\n          onstop: i === 0 ? () => this.onstop(this) : noOp\n        });\n\n        if (this.type === \"custom\") {\n          osc.partials = this._partials;\n        }\n\n        this.frequency.connect(osc.frequency);\n        this.detune.connect(osc.detune);\n        osc.detune.overridden = false;\n        osc.connect(this.output);\n        this._oscillators[i] = osc;\n      } // set the spread\n\n\n      this.spread = this._spread;\n\n      if (this.state === \"started\") {\n        this._forEach(osc => osc.start());\n      }\n    }\n  }\n\n  get phase() {\n    return this._phase;\n  }\n\n  set phase(phase) {\n    this._phase = phase;\n\n    this._forEach(osc => osc.phase = phase);\n  }\n\n  get baseType() {\n    return this._oscillators[0].baseType;\n  }\n\n  set baseType(baseType) {\n    this._forEach(osc => osc.baseType = baseType);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  get partials() {\n    return this._oscillators[0].partials;\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this._type = \"custom\";\n\n      this._forEach(osc => osc.partials = partials);\n    }\n  }\n\n  get partialCount() {\n    return this._oscillators[0].partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._partialCount = partialCount;\n\n    this._forEach(osc => osc.partialCount = partialCount);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._forEach(osc => osc.dispose());\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @offline 0.1 1\n * @example\n * const pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * @category Source\n */\n\nexport class PWMOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n    this.name = \"PWMOscillator\";\n    this.sourceType = \"pwm\";\n    /**\n     * Scale the oscillator so it doesn't go silent\n     * at the extreme values.\n     */\n\n    this._scale = new Multiply({\n      context: this.context,\n      value: 2\n    });\n    const options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n    this._pulse = new PulseOscillator({\n      context: this.context,\n      frequency: options.modulationFrequency\n    }); // change the pulse oscillator type\n\n    this._pulse.carrierType = \"sine\";\n    this.modulationFrequency = this._pulse.frequency;\n    this._modulator = new Oscillator({\n      context: this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: () => this.onstop(this),\n      phase: options.phase\n    });\n    this.frequency = this._modulator.frequency;\n    this.detune = this._modulator.detune; // connections\n\n    this._modulator.chain(this._scale, this._pulse.width);\n\n    this._pulse.connect(this.output);\n\n    readOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      detune: 0,\n      frequency: 440,\n      modulationFrequency: 0.4,\n      phase: 0,\n      type: \"pwm\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.start(time);\n\n    this._pulse.start(time);\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._modulator.stop(time);\n\n    this._pulse.stop(time);\n  }\n  /**\n   * restart the oscillator\n   */\n\n\n  _restart(time) {\n    this._modulator.restart(time);\n\n    this._pulse.restart(time);\n  }\n  /**\n   * The type of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get type() {\n    return \"pwm\";\n  }\n  /**\n   * The baseType of the oscillator. Always returns \"pwm\".\n   */\n\n\n  get baseType() {\n    return \"pwm\";\n  }\n  /**\n   * The partials of the waveform. Cannot set partials for this waveform type\n   */\n\n\n  get partials() {\n    return [];\n  }\n  /**\n   * No partials for this waveform type.\n   */\n\n\n  get partialCount() {\n    return 0;\n  }\n  /**\n   * The phase of the oscillator in degrees.\n   */\n\n\n  get phase() {\n    return this._modulator.phase;\n  }\n\n  set phase(phase) {\n    this._modulator.phase = phase;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._pulse.dispose();\n\n    this._scale.dispose();\n\n    this._modulator.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @offline 0.1 1\n * @example\n * const omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * @category Source\n */\n\nexport class OmniOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OmniOscillator\";\n    const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(this, [\"frequency\", \"detune\"]); // set the options\n\n    this.set(options);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    this._oscillator.start(time);\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _stop(time) {\n    this._oscillator.stop(time);\n  }\n\n  _restart(time) {\n    this._oscillator.restart(time);\n\n    return this;\n  }\n  /**\n   * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n   * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n   * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n   * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n   * when it's not.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n   * omniOsc.type = \"pwm\";\n   * // modulationFrequency is parameter which is available\n   * // only when the type is \"pwm\".\n   * omniOsc.modulationFrequency.value = 0.5;\n   */\n\n\n  get type() {\n    let prefix = \"\";\n\n    if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n      prefix = this._sourceType;\n    }\n\n    return prefix + this._oscillator.type;\n  }\n\n  set type(type) {\n    if (type.substr(0, 2) === \"fm\") {\n      this._createNewOscillator(\"fm\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 2) === \"am\") {\n      this._createNewOscillator(\"am\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(2);\n    } else if (type.substr(0, 3) === \"fat\") {\n      this._createNewOscillator(\"fat\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type.substr(3);\n    } else if (type === \"pwm\") {\n      this._createNewOscillator(\"pwm\");\n\n      this._oscillator = this._oscillator;\n    } else if (type === \"pulse\") {\n      this._createNewOscillator(\"pulse\");\n    } else {\n      this._createNewOscillator(\"oscillator\");\n\n      this._oscillator = this._oscillator;\n      this._oscillator.type = type;\n    }\n  }\n  /**\n   * The value is an empty array when the type is not \"custom\".\n   * This is not available on \"pwm\" and \"pulse\" oscillator types.\n   * See [[Oscillator.partials]]\n   */\n\n\n  get partials() {\n    return this._oscillator.partials;\n  }\n\n  set partials(partials) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partials = partials;\n    }\n  }\n\n  get partialCount() {\n    return this._oscillator.partialCount;\n  }\n\n  set partialCount(partialCount) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n      this._oscillator.partialCount = partialCount;\n    }\n  }\n\n  set(props) {\n    // make sure the type is set first\n    if (Reflect.has(props, \"type\") && props.type) {\n      this.type = props.type;\n    } // then set the rest\n\n\n    super.set(props);\n    return this;\n  }\n  /**\n   * connect the oscillator to the frequency and detune signals\n   */\n\n\n  _createNewOscillator(oscType) {\n    if (oscType !== this._sourceType) {\n      this._sourceType = oscType;\n      const OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change\n\n      const now = this.now();\n\n      if (this._oscillator) {\n        const oldOsc = this._oscillator;\n        oldOsc.stop(now); // dispose the old one\n\n        this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n      }\n\n      this._oscillator = new OscConstructor({\n        context: this.context\n      });\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n\n      this._oscillator.connect(this.output);\n\n      this._oscillator.onstop = () => this.onstop(this);\n\n      if (this.state === \"started\") {\n        this._oscillator.start(now);\n      }\n    }\n  }\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n  }\n  /**\n   * The source type of the oscillator.\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n   * console.log(omniOsc.sourceType); // 'fm'\n   */\n\n\n  get sourceType() {\n    return this._sourceType;\n  }\n\n  set sourceType(sType) {\n    // the basetype defaults to sine\n    let baseType = \"sine\";\n\n    if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n      baseType = this._oscillator.type;\n    } // set the type\n\n\n    if (sType === \"fm\") {\n      this.type = \"fm\" + baseType;\n    } else if (sType === \"am\") {\n      this.type = \"am\" + baseType;\n    } else if (sType === \"fat\") {\n      this.type = \"fat\" + baseType;\n    } else if (sType === \"oscillator\") {\n      this.type = baseType;\n    } else if (sType === \"pulse\") {\n      this.type = \"pulse\";\n    } else if (sType === \"pwm\") {\n      this.type = \"pwm\";\n    }\n  }\n\n  _getOscType(osc, sourceType) {\n    return osc instanceof OmniOscillatorSourceMap[sourceType];\n  }\n  /**\n   * The base type of the oscillator. See [[Oscillator.baseType]]\n   * @example\n   * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n   * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n   */\n\n\n  get baseType() {\n    return this._oscillator.baseType;\n  }\n\n  set baseType(baseType) {\n    if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n      this._oscillator.baseType = baseType;\n    }\n  }\n  /**\n   * The width of the oscillator when sourceType === \"pulse\".\n   * See [[PWMOscillator.width]]\n   */\n\n\n  get width() {\n    if (this._getOscType(this._oscillator, \"pulse\")) {\n      return this._oscillator.width;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The number of detuned oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get count() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.count;\n    } else {\n      return undefined;\n    }\n  }\n\n  set count(count) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n      this._oscillator.count = count;\n    }\n  }\n  /**\n   * The detune spread between the oscillators when sourceType === \"fat\".\n   * See [[FatOscillator.count]]\n   */\n\n\n  get spread() {\n    if (this._getOscType(this._oscillator, \"fat\")) {\n      return this._oscillator.spread;\n    } else {\n      return undefined;\n    }\n  }\n\n  set spread(spread) {\n    if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n      this._oscillator.spread = spread;\n    }\n  }\n  /**\n   * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get modulationType() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.modulationType;\n    } else {\n      return undefined;\n    }\n  }\n\n  set modulationType(mType) {\n    if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n      this._oscillator.modulationType = mType;\n    }\n  }\n  /**\n   * The modulation index when the sourceType === \"fm\"\n   * See [[FMOscillator]].\n   */\n\n\n  get modulationIndex() {\n    if (this._getOscType(this._oscillator, \"fm\")) {\n      return this._oscillator.modulationIndex;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n   * See [[AMOscillator]] or [[FMOscillator]]\n   */\n\n\n  get harmonicity() {\n    if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n      return this._oscillator.harmonicity;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n   * see [[PWMOscillator]]\n   * @min 0.1\n   * @max 5\n   */\n\n\n  get modulationFrequency() {\n    if (this._getOscType(this._oscillator, \"pwm\")) {\n      return this._oscillator.modulationFrequency;\n    } else {\n      return undefined;\n    }\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.detune.dispose();\n    this.frequency.dispose();\n\n    this._oscillator.dispose();\n\n    return this;\n  }\n\n}","import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal } from \"./Signal\";\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @offline 0.5 1\n * @example\n * const add = new Tone.Add(2).toDestination();\n * add.addend.setValueAtTime(1, 0.2);\n * const signal = new Tone.Signal(2);\n * // add a signal and a scalar\n * signal.connect(add);\n * signal.setValueAtTime(1, 0.1);\n * @category Signal\n */\n\nexport class Add extends Signal {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n    this.override = false;\n    this.name = \"Add\";\n    /**\n     * the summing node\n     */\n\n    this._sum = new Gain({\n      context: this.context\n    });\n    this.input = this._sum;\n    this.output = this._sum;\n    /**\n     * The value which is added to the input signal\n     */\n\n    this.addend = this._param;\n    connectSeries(this._constantSource, this._sum);\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      value: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._sum.dispose();\n\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Add } from \"./Add\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * const scale = new Tone.Scale(50, 100);\n * const signal = new Tone.Signal(0.5).connect(scale);\n * // the output of scale equals 75\n * @category Signal\n */\n\nexport class Scale extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"])));\n    this.name = \"Scale\";\n    const options = optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"]);\n    this._mult = this.input = new Multiply({\n      context: this.context,\n      value: options.max - options.min\n    });\n    this._add = this.output = new Add({\n      context: this.context,\n      value: options.min\n    });\n    this._min = options.min;\n    this._max = options.max;\n    this.input.connect(this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(SignalOperator.getDefaults(), {\n      max: 1,\n      min: 0\n    });\n  }\n  /**\n   * The minimum output value. This number is output when the value input value is 0.\n   */\n\n\n  get min() {\n    return this._min;\n  }\n\n  set min(min) {\n    this._min = min;\n\n    this._setRange();\n  }\n  /**\n   * The maximum output value. This number is output when the value input value is 1.\n   */\n\n\n  get max() {\n    return this._max;\n  }\n\n  set max(max) {\n    this._max = max;\n\n    this._setRange();\n  }\n  /**\n   * set the values\n   */\n\n\n  _setRange() {\n    this._add.value = this._min;\n    this._mult.value = this._max - this._min;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._add.dispose();\n\n    this._mult.dispose();\n\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\n\nexport class Zero extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n    this.name = \"Zero\";\n    /**\n     * The gain node which connects the constant source to the output\n     */\n\n    this._gain = new Gain({\n      context: this.context\n    });\n    /**\n     * Only outputs 0\n     */\n\n    this.output = this._gain;\n    /**\n     * no input node\n     */\n\n    this.input = undefined;\n    connect(this.context.getConstant(0), this._gain);\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    disconnect(this.context.getConstant(0), this._gain);\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @offline 0.5 1\n * @example\n * const lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * @category Source\n */\n\nexport class LFO extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n\n    this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n\n    this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n\n    this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n\n    this._fromType = Param.prototype._fromType; // @ts-ignore\n\n    this._toType = Param.prototype._toType; // @ts-ignore\n\n    this._is = Param.prototype._is; // @ts-ignore\n\n    this._clampValue = Param.prototype._clampValue;\n    const options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]); // @ts-ignore\n\n    this._oscillator = new Oscillator({\n      context: this.context,\n      frequency: options.frequency,\n      type: options.type\n    });\n    this.frequency = this._oscillator.frequency;\n    this._amplitudeGain = new Gain({\n      context: this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    this.amplitude = this._amplitudeGain.gain;\n    this._stoppedSignal = new Signal({\n      context: this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    this._zeros = new Zero({\n      context: this.context\n    });\n    this._a2g = new AudioToGain({\n      context: this.context\n    });\n    this._scaler = this.output = new Scale({\n      context: this.context,\n      max: options.max,\n      min: options.min\n    });\n    this.units = options.units;\n    this.min = options.min;\n    this.max = options.max; // connect it up\n\n    this._oscillator.chain(this._a2g, this._amplitudeGain, this._scaler);\n\n    this._zeros.connect(this._a2g);\n\n    this._stoppedSignal.connect(this._a2g);\n\n    readOnly(this, [\"amplitude\", \"frequency\"]);\n    this.phase = options.phase;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      amplitude: 1,\n      frequency: \"4n\",\n      max: 1,\n      min: 0,\n      phase: 0,\n      type: \"sine\",\n      units: \"number\"\n    });\n  }\n  /**\n   * Start the LFO.\n   * @param time The time the LFO will start\n   */\n\n\n  start(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(0, time);\n\n    this._oscillator.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the LFO.\n   * @param  time The time the LFO will stop\n   */\n\n\n  stop(time) {\n    time = this.toSeconds(time);\n\n    this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\n    this._oscillator.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the start/stop/pause to the transport\n   * and the frequency to the bpm of the transport\n   * @example\n   * const lfo = new Tone.LFO(\"8n\");\n   * lfo.sync().start(0);\n   * // the rate of the LFO will always be an eighth note, even as the tempo changes\n   */\n\n\n  sync() {\n    this._oscillator.sync();\n\n    this._oscillator.syncFrequency();\n\n    return this;\n  }\n  /**\n   * unsync the LFO from transport control\n   */\n\n\n  unsync() {\n    this._oscillator.unsync();\n\n    this._oscillator.unsyncFrequency();\n\n    return this;\n  }\n  /**\n   * The minimum output of the LFO.\n   */\n\n\n  get min() {\n    return this._toType(this._scaler.min);\n  }\n\n  set min(min) {\n    min = this._fromType(min);\n    this._scaler.min = min;\n  }\n  /**\n   * The maximum output of the LFO.\n   */\n\n\n  get max() {\n    return this._toType(this._scaler.max);\n  }\n\n  set max(max) {\n    max = this._fromType(max);\n    this._scaler.max = max;\n  }\n  /**\n   * The type of the oscillator: See [[Oscillator.type]]\n   */\n\n\n  get type() {\n    return this._oscillator.type;\n  }\n\n  set type(type) {\n    this._oscillator.type = type;\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The phase of the LFO.\n   */\n\n\n  get phase() {\n    return this._oscillator.phase;\n  }\n\n  set phase(phase) {\n    this._oscillator.phase = phase;\n    this._stoppedValue = this._oscillator.getInitialValue();\n    this._stoppedSignal.value = this._stoppedValue;\n  }\n  /**\n   * The output units of the LFO.\n   */\n\n\n  get units() {\n    return this._units;\n  }\n\n  set units(val) {\n    const currentMin = this.min;\n    const currentMax = this.max; // convert the min and the max\n\n    this._units = val;\n    this.min = currentMin;\n    this.max = currentMax;\n  }\n  /**\n   * Returns the playback state of the source, either \"started\" or \"stopped\".\n   */\n\n\n  get state() {\n    return this._oscillator.state;\n  }\n  /**\n   * @param node the destination to connect to\n   * @param outputNum the optional output number\n   * @param inputNum the input number\n   */\n\n\n  connect(node, outputNum, inputNum) {\n    if (node instanceof Param || node instanceof Signal) {\n      this.convert = node.convert;\n      this.units = node.units;\n    }\n\n    connectSignal(this, node, outputNum, inputNum);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._oscillator.dispose();\n\n    this._stoppedSignal.dispose();\n\n    this._zeros.dispose();\n\n    this._scaler.dispose();\n\n    this._a2g.dispose();\n\n    this._amplitudeGain.dispose();\n\n    this.amplitude.dispose();\n    return this;\n  }\n\n}","import { assertRange } from \"./Debug\";\n/**\n * Assert that the number is in the given range.\n */\n\nexport function range(min, max = Infinity) {\n  const valueMap = new WeakMap();\n  return function (target, propertyKey) {\n    Reflect.defineProperty(target, propertyKey, {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        return valueMap.get(this);\n      },\n      set: function (newValue) {\n        assertRange(newValue, min, max);\n        valueMap.set(this, newValue);\n      }\n    });\n  };\n}\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\n\nexport function timeRange(min, max = Infinity) {\n  const valueMap = new WeakMap();\n  return function (target, propertyKey) {\n    Reflect.defineProperty(target, propertyKey, {\n      configurable: true,\n      enumerable: true,\n      get: function () {\n        return valueMap.get(this);\n      },\n      set: function (newValue) {\n        assertRange(this.toSeconds(newValue), min, max);\n        valueMap.set(this, newValue);\n      }\n    });\n  };\n}","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\n\nexport class Player extends Source {\n  constructor() {\n    super(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"Player\";\n    /**\n     * All of the active buffer source nodes\n     */\n\n    this._activeSources = new Set();\n    const options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n    this._buffer = new ToneAudioBuffer({\n      onload: this._onload.bind(this, options.onload),\n      onerror: options.onerror,\n      reverse: options.reverse,\n      url: options.url\n    });\n    this.autostart = options.autostart;\n    this._loop = options.loop;\n    this._loopStart = options.loopStart;\n    this._loopEnd = options.loopEnd;\n    this._playbackRate = options.playbackRate;\n    this.fadeIn = options.fadeIn;\n    this.fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      autostart: false,\n      fadeIn: 0,\n      fadeOut: 0,\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      onload: noOp,\n      onerror: noOp,\n      playbackRate: 1,\n      reverse: false\n    });\n  }\n  /**\n   * Load the audio file as an audio buffer.\n   * Decodes the audio asynchronously and invokes\n   * the callback once the audio buffer loads.\n   * Note: this does not need to be called if a url\n   * was passed in to the constructor. Only use this\n   * if you want to manually load a new url.\n   * @param url The url of the buffer to load. Filetype support depends on the browser.\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._buffer.load(url);\n\n      this._onload();\n\n      return this;\n    });\n  }\n  /**\n   * Internal callback when the buffer is loaded.\n   */\n\n\n  _onload(callback = noOp) {\n    callback();\n\n    if (this.autostart) {\n      this.start();\n    }\n  }\n  /**\n   * Internal callback when the buffer is done playing.\n   */\n\n\n  _onSourceEnd(source) {\n    // invoke the onstop function\n    this.onstop(this); // delete the source from the active sources\n\n    this._activeSources.delete(source);\n\n    if (this._activeSources.size === 0 && !this._synced && this._state.getValueAtTime(this.now()) === \"started\") {\n      this._state.setStateAtTime(\"stopped\", this.now());\n    }\n  }\n  /**\n   * Play the buffer at the given startTime. Optionally add an offset\n   * and/or duration which will play the buffer from a position\n   * within the buffer for the given duration.\n   *\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n   */\n\n\n  start(time, offset, duration) {\n    super.start(time, offset, duration);\n    return this;\n  }\n  /**\n   * Internal start method\n   */\n\n\n  _start(startTime, offset, duration) {\n    // if it's a loop the default offset is the loopStart point\n    if (this._loop) {\n      offset = defaultArg(offset, this._loopStart);\n    } else {\n      // otherwise the default offset is 0\n      offset = defaultArg(offset, 0);\n    } // compute the values in seconds\n\n\n    let computedOffset = this.toSeconds(offset); // if it's synced, it should factor in the playback rate for computing the offset\n\n    if (this._synced) {\n      computedOffset *= this._playbackRate;\n    } // compute the duration which is either the passed in duration of the buffer.duration - offset\n\n\n    const origDuration = duration;\n    duration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n    let computedDuration = this.toSeconds(duration); // scale it by the playback rate\n\n    computedDuration = computedDuration / this._playbackRate; // get the start time\n\n    startTime = this.toSeconds(startTime); // make the source\n\n    const source = new ToneBufferSource({\n      url: this._buffer,\n      context: this.context,\n      fadeIn: this.fadeIn,\n      fadeOut: this.fadeOut,\n      loop: this._loop,\n      loopEnd: this._loopEnd,\n      loopStart: this._loopStart,\n      onended: this._onSourceEnd.bind(this),\n      playbackRate: this._playbackRate\n    }).connect(this.output); // set the looping properties\n\n    if (!this._loop && !this._synced) {\n      // cancel the previous stop\n      this._state.cancel(startTime + computedDuration); // if it's not looping, set the state change at the end of the sample\n\n\n      this._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n        implicitEnd: true\n      });\n    } // add it to the array of active sources\n\n\n    this._activeSources.add(source); // start it\n\n\n    if (this._loop && isUndef(origDuration)) {\n      source.start(startTime, computedOffset);\n    } else {\n      // subtract the fade out time\n      source.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n    }\n  }\n  /**\n   * Stop playback.\n   */\n\n\n  _stop(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(source => source.stop(computedTime));\n  }\n  /**\n   * Stop and then restart the player from the beginning (or offset)\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given,\n   * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n   */\n\n\n  restart(time, offset, duration) {\n    super.restart(time, offset, duration);\n    return this;\n  }\n\n  _restart(time, offset, duration) {\n    this._stop(time);\n\n    this._start(time, offset, duration);\n  }\n  /**\n   * Seek to a specific time in the player's buffer. If the\n   * source is no longer playing at that time, it will stop.\n   * @param offset The time to seek to.\n   * @param when The time for the seek event to occur.\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\", () => {\n   * \tplayer.start();\n   * \t// seek to the offset in 1 second from now\n   * \tplayer.seek(0.4, \"+1\");\n   * }).toDestination();\n   */\n\n\n  seek(offset, when) {\n    const computedTime = this.toSeconds(when);\n\n    if (this._state.getValueAtTime(computedTime) === \"started\") {\n      const computedOffset = this.toSeconds(offset); // if it's currently playing, stop it\n\n      this._stop(computedTime); // restart it at the given time\n\n\n      this._start(computedTime, computedOffset);\n    }\n\n    return this;\n  }\n  /**\n   * Set the loop start and end. Will only loop if loop is set to true.\n   * @param loopStart The loop start time\n   * @param loopEnd The loop end time\n   * @example\n   * const player = new Tone.Player(\"https://tonejs.github.io/examples/audio/FWDL.mp3\").toDestination();\n   * // loop between the given points\n   * player.setLoopPoints(0.2, 0.3);\n   * player.loop = true;\n   * player.autostart = true;\n   */\n\n\n  setLoopPoints(loopStart, loopEnd) {\n    this.loopStart = loopStart;\n    this.loopEnd = loopEnd;\n    return this;\n  }\n  /**\n   * If loop is true, the loop will start at this position.\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(loopStart) {\n    this._loopStart = loopStart;\n\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n    } // get the current source\n\n\n    this._activeSources.forEach(source => {\n      source.loopStart = loopStart;\n    });\n  }\n  /**\n   * If loop is true, the loop will end at this position.\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(loopEnd) {\n    this._loopEnd = loopEnd;\n\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n    } // get the current source\n\n\n    this._activeSources.forEach(source => {\n      source.loopEnd = loopEnd;\n    });\n  }\n  /**\n   * The audio buffer belonging to the player.\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n\n  set buffer(buffer) {\n    this._buffer.set(buffer);\n  }\n  /**\n   * If the buffer should loop once it's over.\n   */\n\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(loop) {\n    // if no change, do nothing\n    if (this._loop === loop) {\n      return;\n    }\n\n    this._loop = loop; // set the loop of all of the sources\n\n    this._activeSources.forEach(source => {\n      source.loop = loop;\n    });\n\n    if (loop) {\n      // remove the next stopEvent\n      const stopEvent = this._state.getNextState(\"stopped\", this.now());\n\n      if (stopEvent) {\n        this._state.cancel(stopEvent.time);\n      }\n    }\n  }\n  /**\n   * The playback speed. 1 is normal speed. This is not a signal because\n   * Safari and iOS currently don't support playbackRate as a signal.\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n    const now = this.now(); // cancel the stop event since it's at a different time now\n\n    const stopEvent = this._state.getNextState(\"stopped\", now);\n\n    if (stopEvent && stopEvent.implicitEnd) {\n      this._state.cancel(stopEvent.time);\n\n      this._activeSources.forEach(source => source.cancelStop());\n    } // set all the sources\n\n\n    this._activeSources.forEach(source => {\n      source.playbackRate.setValueAtTime(rate, now);\n    });\n  }\n  /**\n   * The direction the buffer should play in\n   */\n\n\n  get reverse() {\n    return this._buffer.reverse;\n  }\n\n  set reverse(rev) {\n    this._buffer.reverse = rev;\n  }\n  /**\n   * If the buffer is loaded\n   */\n\n\n  get loaded() {\n    return this._buffer.loaded;\n  }\n\n  dispose() {\n    super.dispose(); // disconnect all of the players\n\n    this._activeSources.forEach(source => source.dispose());\n\n    this._activeSources.clear();\n\n    this._buffer.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Player.prototype, \"fadeIn\", void 0);\n\n__decorate([timeRange(0)], Player.prototype, \"fadeOut\", void 0);","import { Volume } from \"../../component/channel/Volume\";\nimport { ToneAudioBuffers } from \"../../core/context/ToneAudioBuffers\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { assert } from \"../../core/util/Debug\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Source } from \"../Source\";\nimport { Player } from \"./Player\";\n/**\n * Players combines multiple [[Player]] objects.\n * @category Source\n */\n\nexport class Players extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\"));\n    this.name = \"Players\";\n    /**\n     * Players has no input.\n     */\n\n    this.input = undefined;\n    /**\n     * The container of all of the players\n     */\n\n    this._players = new Map();\n    const options = optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\");\n    /**\n     * The output volume node\n     */\n\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this._buffers = new ToneAudioBuffers({\n      urls: options.urls,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    }); // mute initially\n\n    this.mute = options.mute;\n    this._fadeIn = options.fadeIn;\n    this._fadeOut = options.fadeOut;\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      baseUrl: \"\",\n      fadeIn: 0,\n      fadeOut: 0,\n      mute: false,\n      onload: noOp,\n      onerror: noOp,\n      urls: {},\n      volume: 0\n    });\n  }\n  /**\n   * Mute the output.\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n  /**\n   * The fadeIn time of the envelope applied to the source.\n   */\n\n\n  get fadeIn() {\n    return this._fadeIn;\n  }\n\n  set fadeIn(fadeIn) {\n    this._fadeIn = fadeIn;\n\n    this._players.forEach(player => {\n      player.fadeIn = fadeIn;\n    });\n  }\n  /**\n   * The fadeOut time of the each of the sources.\n   */\n\n\n  get fadeOut() {\n    return this._fadeOut;\n  }\n\n  set fadeOut(fadeOut) {\n    this._fadeOut = fadeOut;\n\n    this._players.forEach(player => {\n      player.fadeOut = fadeOut;\n    });\n  }\n  /**\n   * The state of the players object. Returns \"started\" if any of the players are playing.\n   */\n\n\n  get state() {\n    const playing = Array.from(this._players).some(([_, player]) => player.state === \"started\");\n    return playing ? \"started\" : \"stopped\";\n  }\n  /**\n   * True if the buffers object has a buffer by that name.\n   * @param name  The key or index of the buffer.\n   */\n\n\n  has(name) {\n    return this._buffers.has(name);\n  }\n  /**\n   * Get a player by name.\n   * @param  name  The players name as defined in the constructor object or `add` method.\n   */\n\n\n  player(name) {\n    assert(this.has(name), `No Player with the name ${name} exists on this object`);\n\n    if (!this._players.has(name)) {\n      const player = new Player({\n        context: this.context,\n        fadeIn: this._fadeIn,\n        fadeOut: this._fadeOut,\n        url: this._buffers.get(name)\n      }).connect(this.output);\n\n      this._players.set(name, player);\n    }\n\n    return this._players.get(name);\n  }\n  /**\n   * If all the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Add a player by name and url to the Players\n   * @param  name A unique name to give the player\n   * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n   * @param callback  The callback to invoke when the url is loaded.\n   */\n\n\n  add(name, url, callback) {\n    assert(!this._buffers.has(name), \"A buffer with that name already exists on this object\");\n\n    this._buffers.add(name, url, callback);\n\n    return this;\n  }\n  /**\n   * Stop all of the players at the given time\n   * @param time The time to stop all of the players.\n   */\n\n\n  stopAll(time) {\n    this._players.forEach(player => player.stop(time));\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n\n    this._players.forEach(player => player.dispose());\n\n    this._buffers.dispose();\n\n    return this;\n  }\n\n}","import { Source } from \"../Source\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Clock } from \"../../core/clock/Clock\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\n\nexport class GrainPlayer extends Source {\n  constructor() {\n    super(optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"GrainPlayer\";\n    /**\n     * Internal loopStart value\n     */\n\n    this._loopStart = 0;\n    /**\n     * Internal loopStart value\n     */\n\n    this._loopEnd = 0;\n    /**\n     * All of the currently playing BufferSources\n     */\n\n    this._activeSources = [];\n    const options = optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]);\n    this.buffer = new ToneAudioBuffer({\n      onload: options.onload,\n      onerror: options.onerror,\n      reverse: options.reverse,\n      url: options.url\n    });\n    this._clock = new Clock({\n      context: this.context,\n      callback: this._tick.bind(this),\n      frequency: 1 / options.grainSize\n    });\n    this._playbackRate = options.playbackRate;\n    this._grainSize = options.grainSize;\n    this._overlap = options.overlap;\n    this.detune = options.detune; // setup\n\n    this.overlap = options.overlap;\n    this.loop = options.loop;\n    this.playbackRate = options.playbackRate;\n    this.grainSize = options.grainSize;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.reverse = options.reverse;\n\n    this._clock.on(\"stop\", this._onstop.bind(this));\n  }\n\n  static getDefaults() {\n    return Object.assign(Source.getDefaults(), {\n      onload: noOp,\n      onerror: noOp,\n      overlap: 0.1,\n      grainSize: 0.2,\n      playbackRate: 1,\n      detune: 0,\n      loop: false,\n      loopStart: 0,\n      loopEnd: 0,\n      reverse: false\n    });\n  }\n  /**\n   * Internal start method\n   */\n\n\n  _start(time, offset, duration) {\n    offset = defaultArg(offset, 0);\n    offset = this.toSeconds(offset);\n    time = this.toSeconds(time);\n\n    const grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\n    this._clock.start(time, offset / grainSize);\n\n    if (duration) {\n      this.stop(time + this.toSeconds(duration));\n    }\n  }\n  /**\n   * Stop and then restart the player from the beginning (or offset)\n   * @param  time When the player should start.\n   * @param  offset The offset from the beginning of the sample to start at.\n   * @param  duration How long the sample should play. If no duration is given,\n   * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n   */\n\n\n  restart(time, offset, duration) {\n    super.restart(time, offset, duration);\n    return this;\n  }\n\n  _restart(time, offset, duration) {\n    this._stop(time);\n\n    this._start(time, offset, duration);\n  }\n  /**\n   * Internal stop method\n   */\n\n\n  _stop(time) {\n    this._clock.stop(time);\n  }\n  /**\n   * Invoked when the clock is stopped\n   */\n\n\n  _onstop(time) {\n    // stop the players\n    this._activeSources.forEach(source => {\n      source.fadeOut = 0;\n      source.stop(time);\n    });\n\n    this.onstop(this);\n  }\n  /**\n   * Invoked on each clock tick. scheduled a new grain at this time.\n   */\n\n\n  _tick(time) {\n    // check if it should stop looping\n    const ticks = this._clock.getTicksAtTime(time);\n\n    const grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\n    const offset = ticks * grainSize;\n    this.log(\"offset\", offset);\n\n    if (!this.loop && offset > this.buffer.duration) {\n      this.stop(time);\n      return;\n    } // at the beginning of the file, the fade in should be 0\n\n\n    const fadeIn = offset < this._overlap ? 0 : this._overlap; // create a buffer source\n\n    const source = new ToneBufferSource({\n      context: this.context,\n      url: this.buffer,\n      fadeIn: fadeIn,\n      fadeOut: this._overlap,\n      loop: this.loop,\n      loopStart: this._loopStart,\n      loopEnd: this._loopEnd,\n      // compute the playbackRate based on the detune\n      playbackRate: intervalToFrequencyRatio(this.detune / 100)\n    }).connect(this.output);\n    source.start(time, this._grainSize * ticks);\n    source.stop(time + this._grainSize / this.playbackRate); // add it to the active sources\n\n    this._activeSources.push(source); // remove it when it's done\n\n\n    source.onended = () => {\n      const index = this._activeSources.indexOf(source);\n\n      if (index !== -1) {\n        this._activeSources.splice(index, 1);\n      }\n    };\n  }\n  /**\n   * The playback rate of the sample\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    assertRange(rate, 0.001);\n    this._playbackRate = rate;\n    this.grainSize = this._grainSize;\n  }\n  /**\n   * The loop start time.\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(time) {\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(time), 0, this.buffer.duration);\n    }\n\n    this._loopStart = this.toSeconds(time);\n  }\n  /**\n   * The loop end time.\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(time) {\n    if (this.buffer.loaded) {\n      assertRange(this.toSeconds(time), 0, this.buffer.duration);\n    }\n\n    this._loopEnd = this.toSeconds(time);\n  }\n  /**\n   * The direction the buffer should play in\n   */\n\n\n  get reverse() {\n    return this.buffer.reverse;\n  }\n\n  set reverse(rev) {\n    this.buffer.reverse = rev;\n  }\n  /**\n   * The size of each chunk of audio that the\n   * buffer is chopped into and played back at.\n   */\n\n\n  get grainSize() {\n    return this._grainSize;\n  }\n\n  set grainSize(size) {\n    this._grainSize = this.toSeconds(size);\n\n    this._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());\n  }\n  /**\n   * The duration of the cross-fade between successive grains.\n   */\n\n\n  get overlap() {\n    return this._overlap;\n  }\n\n  set overlap(time) {\n    this._overlap = this.toSeconds(time);\n  }\n  /**\n   * If all the buffer is loaded\n   */\n\n\n  get loaded() {\n    return this.buffer.loaded;\n  }\n\n  dispose() {\n    super.dispose();\n    this.buffer.dispose();\n\n    this._clock.dispose();\n\n    this._activeSources.forEach(source => source.dispose());\n\n    return this;\n  }\n\n}","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * Return the absolute value of an incoming signal.\n *\n * @offline 0.5 1\n * @example\n * const abs = new Tone.Abs().toDestination();\n * const signal = new Tone.Signal(1);\n * signal.rampTo(-1, 0.5);\n * signal.connect(abs);\n * @category Signal\n */\n\nexport class Abs extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"Abs\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._abs = new WaveShaper({\n      context: this.context,\n      mapping: val => {\n        if (Math.abs(val) < 0.001) {\n          return 0;\n        } else {\n          return Math.abs(val);\n        }\n      }\n    });\n    /**\n     * The AudioRange input [-1, 1]\n     */\n\n    this.input = this._abs;\n    /**\n     * The output range [0, 1]\n     */\n\n    this.output = this._abs;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._abs.dispose();\n\n    return this;\n  }\n\n}","import { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n * @category Signal\n */\n\nexport class GainToAudio extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"GainToAudio\";\n    /**\n     * The node which converts the audio ranges\n     */\n\n    this._norm = new WaveShaper({\n      context: this.context,\n      mapping: x => Math.abs(x) * 2 - 1\n    });\n    /**\n     * The NormalRange input [0, 1]\n     */\n\n    this.input = this._norm;\n    /**\n     * The AudioRange output [-1, 1]\n     */\n\n    this.output = this._norm;\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._norm.dispose();\n\n    return this;\n  }\n\n}","import { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * const neg = new Tone.Negate();\n * const sig = new Tone.Signal(-2).connect(neg);\n * // output of neg is positive 2.\n * @category Signal\n */\n\nexport class Negate extends SignalOperator {\n  constructor() {\n    super(...arguments);\n    this.name = \"Negate\";\n    /**\n     * negation is done by multiplying by -1\n     */\n\n    this._multiply = new Multiply({\n      context: this.context,\n      value: -1\n    });\n    /**\n     * The input and output are equal to the multiply node\n     */\n\n    this.input = this._multiply;\n    this.output = this._multiply;\n  }\n  /**\n   * clean up\n   * @returns {Negate} this\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._multiply.dispose();\n\n    return this;\n  }\n\n}","import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * // subtract a scalar from a signal\n * const sub = new Tone.Subtract(1);\n * const sig = new Tone.Signal(4).connect(sub);\n * // the output of sub is 3.\n * @example\n * // subtract two signals\n * const sub = new Tone.Subtract();\n * const sigA = new Tone.Signal(10);\n * const sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * // output of sub is 7.5\n * @category Signal\n */\n\nexport class Subtract extends Signal {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n    this.override = false;\n    this.name = \"Subtract\";\n    /**\n     * the summing node\n     */\n\n    this._sum = new Gain({\n      context: this.context\n    });\n    this.input = this._sum;\n    this.output = this._sum;\n    /**\n     * Negate the input of the second input before connecting it to the summing node.\n     */\n\n    this._neg = new Negate({\n      context: this.context\n    });\n    /**\n     * The value which is subtracted from the main signal\n     */\n\n    this.subtrahend = this._param;\n    connectSeries(this._constantSource, this._neg, this._sum);\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      value: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._neg.dispose();\n\n    this._sum.dispose();\n\n    return this;\n  }\n\n}","import { SignalOperator } from \"./SignalOperator\";\nimport { Multiply } from \"./Multiply\";\nimport { WaveShaper } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n/**\n * GreaterThanZero outputs 1 when the input is strictly greater than zero\n * @offline 0.1 1\n * @example\n * const gt0 = new Tone.GreaterThanZero().toDestination();\n * const sig = new Tone.Signal(0.5).connect(gt0);\n * sig.setValueAtTime(-1, 0.05);\n */\n\nexport class GreaterThanZero extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(GreaterThanZero.getDefaults(), arguments)));\n    this.name = \"GreaterThanZero\";\n    this._thresh = this.output = new WaveShaper({\n      context: this.context,\n      length: 127,\n      mapping: val => {\n        if (val <= 0) {\n          return 0;\n        } else {\n          return 1;\n        }\n      }\n    });\n    this._scale = this.input = new Multiply({\n      context: this.context,\n      value: 10000\n    }); // connections\n\n    this._scale.connect(this._thresh);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._scale.dispose();\n\n    this._thresh.dispose();\n\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Subtract } from \"./Subtract\";\nimport { Signal } from \"./Signal\";\nimport { GreaterThanZero } from \"./GreaterThanZero\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Output 1 if the signal is greater than the value, otherwise outputs 0.\n * can compare two signals or a signal and a number.\n *\n * @offline 0.1 1\n * @example\n * const gt = new Tone.GreaterThan(2).toDestination();\n * const sig = new Tone.Signal(4).connect(gt);\n */\n\nexport class GreaterThan extends Signal {\n  constructor() {\n    super(Object.assign(optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"])));\n    this.name = \"GreaterThan\";\n    this.override = false;\n    const options = optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"]);\n    this._subtract = this.input = new Subtract({\n      context: this.context,\n      value: options.value\n    });\n    this._gtz = this.output = new GreaterThanZero({\n      context: this.context\n    });\n    this.comparator = this._param = this._subtract.subtrahend;\n    readOnly(this, \"comparator\"); // connect\n\n    this._subtract.connect(this._gtz);\n  }\n\n  static getDefaults() {\n    return Object.assign(Signal.getDefaults(), {\n      value: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._gtz.dispose();\n\n    this._subtract.dispose();\n\n    this.comparator.dispose();\n    return this;\n  }\n\n}","import { WaveShaper } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * const pow = new Tone.Pow(2);\n * const sig = new Tone.Signal(0.5).connect(pow);\n * // output of pow is 0.25.\n * @category Signal\n */\n\nexport class Pow extends SignalOperator {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"])));\n    this.name = \"Pow\";\n    const options = optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"]);\n    this._exponentScaler = this.input = this.output = new WaveShaper({\n      context: this.context,\n      mapping: this._expFunc(options.value),\n      length: 8192\n    });\n    this._exponent = options.value;\n  }\n\n  static getDefaults() {\n    return Object.assign(SignalOperator.getDefaults(), {\n      value: 1\n    });\n  }\n  /**\n   * the function which maps the waveshaper\n   * @param exponent exponent value\n   */\n\n\n  _expFunc(exponent) {\n    return val => {\n      return Math.pow(Math.abs(val), exponent);\n    };\n  }\n  /**\n   * The value of the exponent.\n   */\n\n\n  get value() {\n    return this._exponent;\n  }\n\n  set value(exponent) {\n    this._exponent = exponent;\n\n    this._exponentScaler.setMap(this._expFunc(this._exponent));\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._exponentScaler.dispose();\n\n    return this;\n  }\n\n}","import { Scale } from \"./Scale\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Pow } from \"./Pow\";\n/**\n * Performs an exponential scaling on an input signal.\n * Scales a NormalRange value [0,1] exponentially\n * to the output range of outputMin to outputMax.\n * @example\n * const scaleExp = new Tone.ScaleExp(0, 100, 2);\n * const signal = new Tone.Signal(0.5).connect(scaleExp);\n */\n\nexport class ScaleExp extends Scale {\n  constructor() {\n    super(Object.assign(optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"])));\n    this.name = \"ScaleExp\";\n    const options = optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"]);\n    this.input = this._exp = new Pow({\n      context: this.context,\n      value: options.exponent\n    });\n\n    this._exp.connect(this._mult);\n  }\n\n  static getDefaults() {\n    return Object.assign(Scale.getDefaults(), {\n      exponent: 1\n    });\n  }\n  /**\n   * Instead of interpolating linearly between the [[min]] and\n   * [[max]] values, setting the exponent will interpolate between\n   * the two values with an exponential curve.\n   */\n\n\n  get exponent() {\n    return this._exp.value;\n  }\n\n  set exponent(exp) {\n    this._exp.value = exp;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._exp.dispose();\n\n    return this;\n  }\n\n}","import { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\n\nexport class SyncedSignal extends Signal {\n  constructor() {\n    super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    this.name = \"SyncedSignal\";\n    /**\n     * Don't override when something is connected to the input\n     */\n\n    this.override = false;\n    const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    this._lastVal = options.value;\n    this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n    this._syncedCallback = this._anchorValue.bind(this);\n    this.context.transport.on(\"start\", this._syncedCallback);\n    this.context.transport.on(\"pause\", this._syncedCallback);\n    this.context.transport.on(\"stop\", this._syncedCallback); // disconnect the constant source from the output and replace it with another one\n\n    this._constantSource.disconnect();\n\n    this._constantSource.stop(0); // create a new one\n\n\n    this._constantSource = this.output = new ToneConstantSource({\n      context: this.context,\n      offset: options.value,\n      units: options.units\n    }).start(0);\n    this.setValueAtTime(options.value, 0);\n  }\n  /**\n   * Callback which is invoked every tick.\n   */\n\n\n  _onTick(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds); // approximate ramp curves with linear ramps\n\n    if (this._lastVal !== val) {\n      this._lastVal = val;\n\n      this._constantSource.offset.setValueAtTime(val, time);\n    }\n  }\n  /**\n   * Anchor the value at the start and stop of the Transport\n   */\n\n\n  _anchorValue(time) {\n    const val = super.getValueAtTime(this.context.transport.seconds);\n    this._lastVal = val;\n\n    this._constantSource.offset.cancelAndHoldAtTime(time);\n\n    this._constantSource.offset.setValueAtTime(val, time);\n  }\n\n  getValueAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    return super.getValueAtTime(computedTime);\n  }\n\n  setValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setValueAtTime(value, computedTime);\n    return this;\n  }\n\n  linearRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.linearRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  exponentialRampToValueAtTime(value, time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.exponentialRampToValueAtTime(value, computedTime);\n    return this;\n  }\n\n  setTargetAtTime(value, startTime, timeConstant) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.setTargetAtTime(value, computedTime, timeConstant);\n    return this;\n  }\n\n  cancelScheduledValues(startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.cancelScheduledValues(computedTime);\n    return this;\n  }\n\n  setValueCurveAtTime(values, startTime, duration, scaling) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    duration = this.toSeconds(duration);\n    super.setValueCurveAtTime(values, computedTime, duration, scaling);\n    return this;\n  }\n\n  cancelAndHoldAtTime(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.cancelAndHoldAtTime(computedTime);\n    return this;\n  }\n\n  setRampPoint(time) {\n    const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n    super.setRampPoint(computedTime);\n    return this;\n  }\n\n  exponentialRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.exponentialRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  linearRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.linearRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  targetRampTo(value, rampTime, startTime) {\n    const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n    super.targetRampTo(value, rampTime, computedTime);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.context.transport.clear(this._synced);\n    this.context.transport.off(\"start\", this._syncedCallback);\n    this.context.transport.off(\"pause\", this._syncedCallback);\n    this.context.transport.off(\"stop\", this._syncedCallback);\n\n    this._constantSource.dispose();\n\n    return this;\n  }\n\n}","import { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @offline 2 1\n * @example\n * const env = new Tone.Envelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1,\n * \trelease: 0.8,\n * }).toDestination();\n * env.triggerAttackRelease(0.5);\n * @category Component\n */\n\nexport class Envelope extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    this._sig = new Signal({\n      context: this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    this.output = this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    this.input = undefined;\n    const options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    this.attack = options.attack;\n    this.decay = options.decay;\n    this.sustain = options.sustain;\n    this.release = options.release;\n    this.attackCurve = options.attackCurve;\n    this.releaseCurve = options.releaseCurve;\n    this.decayCurve = options.decayCurve;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.01,\n      attackCurve: \"linear\",\n      decay: 0.1,\n      decayCurve: \"exponential\",\n      release: 1,\n      releaseCurve: \"exponential\",\n      sustain: 0.5\n    });\n  }\n  /**\n   * Read the current value of the envelope. Useful for\n   * synchronizing visual output to the envelope.\n   */\n\n\n  get value() {\n    return this.getValueAtTime(this.now());\n  }\n  /**\n   * Get the curve\n   * @param  curve\n   * @param  direction  In/Out\n   * @return The curve name\n   */\n\n\n  _getCurve(curve, direction) {\n    if (isString(curve)) {\n      return curve;\n    } else {\n      // look up the name in the curves array\n      let curveName;\n\n      for (curveName in EnvelopeCurves) {\n        if (EnvelopeCurves[curveName][direction] === curve) {\n          return curveName;\n        }\n      } // return the custom curve\n\n\n      return curve;\n    }\n  }\n  /**\n   * Assign a the curve to the given name using the direction\n   * @param  name\n   * @param  direction In/Out\n   * @param  curve\n   */\n\n\n  _setCurve(name, direction, curve) {\n    // check if it's a valid type\n    if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n      const curveDef = EnvelopeCurves[curve];\n\n      if (isObject(curveDef)) {\n        if (name !== \"_decayCurve\") {\n          this[name] = curveDef[direction];\n        }\n      } else {\n        this[name] = curveDef;\n      }\n    } else if (isArray(curve) && name !== \"_decayCurve\") {\n      this[name] = curve;\n    } else {\n      throw new Error(\"Envelope: invalid curve: \" + curve);\n    }\n  }\n  /**\n   * The shape of the attack.\n   * Can be any of these strings:\n   * * \"linear\"\n   * * \"exponential\"\n   * * \"sine\"\n   * * \"cosine\"\n   * * \"bounce\"\n   * * \"ripple\"\n   * * \"step\"\n   *\n   * Can also be an array which describes the curve. Values\n   * in the array are evenly subdivided and linearly\n   * interpolated over the duration of the attack.\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope().toDestination();\n   * env.attackCurve = \"linear\";\n   * env.triggerAttack();\n   * @example\n   * const env = new Tone.Envelope().toDestination();\n   * // can also be an array\n   * env.attackCurve = [0, 0.2, 0.3, 0.4, 1];\n   * env.triggerAttack();\n   */\n\n\n  get attackCurve() {\n    return this._getCurve(this._attackCurve, \"In\");\n  }\n\n  set attackCurve(curve) {\n    this._setCurve(\"_attackCurve\", \"In\", curve);\n  }\n  /**\n   * The shape of the release. See the attack curve types.\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope({\n   * \trelease: 0.5\n   * });\n   * env.releaseCurve = \"linear\";\n   * env.triggerAttack();\n   * env.triggerRelease(0.5);\n   */\n\n\n  get releaseCurve() {\n    return this._getCurve(this._releaseCurve, \"Out\");\n  }\n\n  set releaseCurve(curve) {\n    this._setCurve(\"_releaseCurve\", \"Out\", curve);\n  }\n  /**\n   * The shape of the decay either \"linear\" or \"exponential\"\n   * @offline 1 1\n   * @example\n   * const env = new Tone.Envelope({\n   * \tsustain: 0.1,\n   * \tdecay: 0.5\n   * });\n   * env.decayCurve = \"linear\";\n   * env.triggerAttack();\n   */\n\n\n  get decayCurve() {\n    return this._decayCurve;\n  }\n\n  set decayCurve(curve) {\n    assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n    this._decayCurve = curve;\n  }\n  /**\n   * Trigger the attack/decay portion of the ADSR envelope.\n   * @param  time When the attack should start.\n   * @param velocity The velocity of the envelope scales the vales.\n   *                             number between 0-1\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n   * env.triggerAttack(\"+0.5\", 0.2);\n   */\n\n\n  triggerAttack(time, velocity = 1) {\n    this.log(\"triggerAttack\", time, velocity);\n    time = this.toSeconds(time);\n    const originalAttack = this.toSeconds(this.attack);\n    let attack = originalAttack;\n    const decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      // subtract the current value from the attack time\n      const attackRate = 1 / attack;\n      const remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n      attack = remainingDistance / attackRate;\n    } // attack\n\n\n    if (attack < this.sampleTime) {\n      this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly\n\n\n      this._sig.setValueAtTime(velocity, time);\n    } else if (this._attackCurve === \"linear\") {\n      this._sig.linearRampTo(velocity, attack, time);\n    } else if (this._attackCurve === \"exponential\") {\n      this._sig.targetRampTo(velocity, attack, time);\n    } else {\n      this._sig.cancelAndHoldAtTime(time);\n\n      let curve = this._attackCurve; // find the starting position in the curve\n\n      for (let i = 1; i < curve.length; i++) {\n        // the starting index is between the two values\n        if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n          curve = this._attackCurve.slice(i); // the first index is the current value\n\n          curve[0] = currentValue;\n          break;\n        }\n      }\n\n      this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n    } // decay\n\n\n    if (decay && this.sustain < 1) {\n      const decayValue = velocity * this.sustain;\n      const decayStart = time + attack;\n      this.log(\"decay\", decayStart);\n\n      if (this._decayCurve === \"linear\") {\n        this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n      } else {\n        this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Triggers the release of the envelope.\n   * @param  time When the release portion of the envelope should start.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator({\n   * \ttype: \"sawtooth\"\n   * }).connect(env).start();\n   * env.triggerAttack();\n   * // trigger the release half a second after the attack\n   * env.triggerRelease(\"+0.5\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    time = this.toSeconds(time);\n    const currentValue = this.getValueAtTime(time);\n\n    if (currentValue > 0) {\n      const release = this.toSeconds(this.release);\n\n      if (release < this.sampleTime) {\n        this._sig.setValueAtTime(0, time);\n      } else if (this._releaseCurve === \"linear\") {\n        this._sig.linearRampTo(0, release, time);\n      } else if (this._releaseCurve === \"exponential\") {\n        this._sig.targetRampTo(0, release, time);\n      } else {\n        assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n        this._sig.cancelAndHoldAtTime(time);\n\n        this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Get the scheduled value at the given time. This will\n   * return the unconverted (raw) value.\n   */\n\n\n  getValueAtTime(time) {\n    return this._sig.getValueAtTime(time);\n  }\n  /**\n   * triggerAttackRelease is shorthand for triggerAttack, then waiting\n   * some duration, then triggerRelease.\n   * @param duration The duration of the sustain.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity of the envelope.\n   * @example\n   * const env = new Tone.AmplitudeEnvelope().toDestination();\n   * const osc = new Tone.Oscillator().connect(env).start();\n   * // trigger the release 0.5 seconds after the attack\n   * env.triggerAttackRelease(0.5);\n   */\n\n\n  triggerAttackRelease(duration, time, velocity = 1) {\n    time = this.toSeconds(time);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + this.toSeconds(duration));\n    return this;\n  }\n  /**\n   * Cancels all scheduled envelope changes after the given time.\n   */\n\n\n  cancel(after) {\n    this._sig.cancelScheduledValues(this.toSeconds(after));\n\n    return this;\n  }\n  /**\n   * Connect the envelope to a destination node.\n   */\n\n\n  connect(destination, outputNumber = 0, inputNumber = 0) {\n    connectSignal(this, destination, outputNumber, inputNumber);\n    return this;\n  }\n  /**\n   * Render the envelope curve to an array of the given length.\n   * Good for visualizing the envelope curve. Rescales the duration of the\n   * envelope to fit the length.\n   */\n\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const duration = length / this.context.sampleRate;\n      const context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n\n      const attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n      const envelopeDuration = attackPortion + this.toSeconds(this.release);\n      const sustainTime = envelopeDuration * 0.1;\n      const totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n\n      const clone = new this.constructor(Object.assign(this.get(), {\n        attack: duration * this.toSeconds(this.attack) / totalDuration,\n        decay: duration * this.toSeconds(this.decay) / totalDuration,\n        release: duration * this.toSeconds(this.release) / totalDuration,\n        context\n      }));\n\n      clone._sig.toDestination();\n\n      clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n      const buffer = yield context.render();\n      return buffer.getChannelData(0);\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._sig.dispose();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\n\n\nconst EnvelopeCurves = (() => {\n  const curveLen = 128;\n  let i;\n  let k; // cosine curve\n\n  const cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  const rippleCurve = [];\n  const rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    const sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  const stairsCurve = [];\n  const steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  const sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  const bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    const freq = Math.pow(k, 3) * 4 + 0.2;\n    const val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    const out = new Array(curve.length);\n\n    for (let j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n})();","import { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\n\nexport class Instrument extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Instrument.getDefaults(), arguments));\n    /**\n     * Keep track of all events scheduled to the transport\n     * when the instrument is 'synced'\n     */\n\n    this._scheduledEvents = [];\n    /**\n     * If the instrument is currently synced\n     */\n\n    this._synced = false;\n    this._original_triggerAttack = this.triggerAttack;\n    this._original_triggerRelease = this.triggerRelease;\n    const options = optionsFromArguments(Instrument.getDefaults(), arguments);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      volume: 0\n    });\n  }\n  /**\n   * Sync the instrument to the Transport. All subsequent calls of\n   * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n   * @example\n   * const fmSynth = new Tone.FMSynth().toDestination();\n   * fmSynth.volume.value = -6;\n   * fmSynth.sync();\n   * // schedule 3 notes when the transport first starts\n   * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n   * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n   * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n   * // start the transport to hear the notes\n   * Tone.Transport.start();\n   */\n\n\n  sync() {\n    if (!this._synced) {\n      this._synced = true;\n\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 0);\n    }\n\n    return this;\n  }\n  /**\n   * Wrap the given method so that it can be synchronized\n   * @param method Which method to wrap and sync\n   * @param  timePosition What position the time argument appears in\n   */\n\n\n  _syncMethod(method, timePosition) {\n    const originalMethod = this[\"_original_\" + method] = this[method];\n\n    this[method] = (...args) => {\n      const time = args[timePosition];\n      const id = this.context.transport.schedule(t => {\n        args[timePosition] = t;\n        originalMethod.apply(this, args);\n      }, time);\n\n      this._scheduledEvents.push(id);\n    };\n  }\n  /**\n   * Unsync the instrument from the Transport\n   */\n\n\n  unsync() {\n    this._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\n    this._scheduledEvents = [];\n\n    if (this._synced) {\n      this._synced = false;\n      this.triggerAttack = this._original_triggerAttack;\n      this.triggerRelease = this._original_triggerRelease;\n    }\n\n    return this;\n  }\n  /**\n   * Trigger the attack and then the release after the duration.\n   * @param  note     The note to trigger.\n   * @param  duration How long the note should be held for before\n   *                         triggering the release. This value must be greater than 0.\n   * @param time  When the note should be triggered.\n   * @param  velocity The velocity the note should be triggered at.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger \"C4\" for the duration of an 8th note\n   * synth.triggerAttackRelease(\"C4\", \"8n\");\n   */\n\n\n  triggerAttackRelease(note, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    const computedDuration = this.toSeconds(duration);\n    this.triggerAttack(note, computedTime, velocity);\n    this.triggerRelease(computedTime + computedDuration);\n    return this;\n  }\n  /**\n   * clean up\n   * @returns {Instrument} this\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._volume.dispose();\n\n    this.unsync();\n    this._scheduledEvents = [];\n    return this;\n  }\n\n}","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\n\nexport class Monophonic extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n    const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    this.portamento = options.portamento;\n    this.onsilence = options.onsilence;\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      detune: 0,\n      onsilence: noOp,\n      portamento: 0\n    });\n  }\n  /**\n   * Trigger the attack of the note optionally with a given velocity.\n   * @param  note The note to trigger.\n   * @param  time When the note should start.\n   * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * // trigger the note a half second from now at half velocity\n   * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n   */\n\n\n  triggerAttack(note, time, velocity = 1) {\n    this.log(\"triggerAttack\", note, time, velocity);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeAttack(seconds, velocity);\n\n    this.setNote(note, seconds);\n    return this;\n  }\n  /**\n   * Trigger the release portion of the envelope\n   * @param  time If no time is given, the release happens immediatly\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // trigger the release a second from now\n   * synth.triggerRelease(\"+1\");\n   */\n\n\n  triggerRelease(time) {\n    this.log(\"triggerRelease\", time);\n    const seconds = this.toSeconds(time);\n\n    this._triggerEnvelopeRelease(seconds);\n\n    return this;\n  }\n  /**\n   * Set the note at the given time. If no time is given, the note\n   * will set immediately.\n   * @param note The note to change to.\n   * @param  time The time when the note should be set.\n   * @example\n   * const synth = new Tone.Synth().toDestination();\n   * synth.triggerAttack(\"C4\");\n   * // change to F#6 in one quarter note from now.\n   * synth.setNote(\"F#6\", \"+4n\");\n   */\n\n\n  setNote(note, time) {\n    const computedTime = this.toSeconds(time);\n    const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\n    if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n      const portTime = this.toSeconds(this.portamento);\n      this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n    } else {\n      this.frequency.setValueAtTime(computedFrequency, computedTime);\n    }\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","import { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * const ampEnv = new Tone.AmplitudeEnvelope({\n * \tattack: 0.1,\n * \tdecay: 0.2,\n * \tsustain: 1.0,\n * \trelease: 0.8\n * }).toDestination();\n * // create an oscillator and connect it\n * const osc = new Tone.Oscillator().connect(ampEnv).start();\n * // trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\n\nexport class AmplitudeEnvelope extends Envelope {\n  constructor() {\n    super(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"AmplitudeEnvelope\";\n    this._gainNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    this.output = this._gainNode;\n    this.input = this._gainNode;\n\n    this._sig.connect(this._gainNode.gain);\n\n    this.output = this._gainNode;\n    this.input = this._gainNode;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._gainNode.dispose();\n\n    return this;\n  }\n\n}","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class Synth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(Synth.getDefaults(), arguments));\n    this.name = \"Synth\";\n    const options = optionsFromArguments(Synth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign({\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }, options.oscillator));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: this.context\n    }, options.envelope)); // connect the oscillators to the output\n\n    this.oscillator.chain(this.envelope, this.output);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.3\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"triangle\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // the envelopes\n    this.envelope.triggerAttack(time, velocity);\n    this.oscillator.start(time); // if there is no release portion, stop the oscillator\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n  /**\n   * clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    return this;\n  }\n\n}","import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Synth } from \"./Synth\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n/**\n * Base class for both AM and FM synths\n */\n\nexport class ModulationSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n    this.name = \"ModulationSynth\";\n    const options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n    this._carrier = new Synth({\n      context: this.context,\n      oscillator: options.oscillator,\n      envelope: options.envelope,\n      onsilence: () => this.onsilence(this),\n      volume: -10\n    });\n    this._modulator = new Synth({\n      context: this.context,\n      oscillator: options.modulation,\n      envelope: options.modulationEnvelope,\n      volume: -10\n    });\n    this.oscillator = this._carrier.oscillator;\n    this.envelope = this._carrier.envelope;\n    this.modulation = this._modulator.oscillator;\n    this.modulationEnvelope = this._modulator.envelope;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\"\n    });\n    this.detune = new Signal({\n      context: this.context,\n      value: options.detune,\n      units: \"cents\"\n    });\n    this.harmonicity = new Multiply({\n      context: this.context,\n      value: options.harmonicity,\n      minValue: 0\n    });\n    this._modulationNode = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    readOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      harmonicity: 3,\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"sine\"\n      }),\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.01,\n        decay: 0.01,\n        sustain: 1,\n        release: 0.5\n      }),\n      modulation: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]), {\n        type: \"square\"\n      }),\n      modulationEnvelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.5,\n        decay: 0.0,\n        sustain: 1,\n        release: 0.5\n      })\n    });\n  }\n  /**\n   * Trigger the attack portion of the note\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeAttack(time, velocity); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeAttack(time, velocity);\n  }\n  /**\n   * Trigger the release portion of the note\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    // @ts-ignore\n    this._carrier._triggerEnvelopeRelease(time); // @ts-ignore\n\n\n    this._modulator._triggerEnvelopeRelease(time);\n\n    return this;\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._carrier.dispose();\n\n    this._modulator.dispose();\n\n    this.frequency.dispose();\n    this.detune.dispose();\n    this.harmonicity.dispose();\n\n    this._modulationNode.dispose();\n\n    return this;\n  }\n\n}","import { AudioToGain } from \"../signal/AudioToGain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth } from \"./ModulationSynth\";\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n *\n * @category Instrument\n */\n\nexport class AMSynth extends ModulationSynth {\n  constructor() {\n    super(optionsFromArguments(AMSynth.getDefaults(), arguments));\n    this.name = \"AMSynth\";\n    this._modulationScale = new AudioToGain({\n      context: this.context\n    }); // control the two voices frequency\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.detune.fan(this._carrier.detune, this._modulator.detune);\n\n    this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\n    this._carrier.chain(this._modulationNode, this.output);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._modulationScale.dispose();\n\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * const filter = new Tone.Filter(1500, \"highpass\").toDestination();\n * filter.frequency.rampTo(20000, 10);\n * const noise = new Tone.Noise().connect(filter).start();\n * @category Component\n */\n\nexport class Filter extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n    this.name = \"Filter\";\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    this._filters = [];\n    const options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n    this._filters = [];\n    this.Q = new Signal({\n      context: this.context,\n      units: \"positive\",\n      value: options.Q\n    });\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this.gain = new Signal({\n      context: this.context,\n      units: \"decibels\",\n      value: options.gain\n    });\n    this._type = options.type;\n    this.rolloff = options.rolloff;\n    readOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      Q: 1,\n      detune: 0,\n      frequency: 350,\n      gain: 0,\n      rolloff: -12,\n      type: \"lowpass\"\n    });\n  }\n  /**\n   * The type of the filter. Types: \"lowpass\", \"highpass\",\n   * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    const types = [\"lowpass\", \"highpass\", \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n    assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n    this._type = type;\n\n    this._filters.forEach(filter => filter.type = type);\n  }\n  /**\n   * The rolloff of the filter which is the drop in db\n   * per octave. Implemented internally by cascading filters.\n   * Only accepts the values -12, -24, -48 and -96.\n   */\n\n\n  get rolloff() {\n    return this._rolloff;\n  }\n\n  set rolloff(rolloff) {\n    const rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);\n    const possibilities = [-12, -24, -48, -96];\n    let cascadingCount = possibilities.indexOf(rolloffNum); // check the rolloff is valid\n\n    assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n    cascadingCount += 1;\n    this._rolloff = rolloffNum;\n    this.input.disconnect();\n\n    this._filters.forEach(filter => filter.disconnect());\n\n    this._filters = new Array(cascadingCount);\n\n    for (let count = 0; count < cascadingCount; count++) {\n      const filter = this.context.createBiquadFilter();\n      filter.type = this._type;\n      this.frequency.connect(filter.frequency);\n      this.detune.connect(filter.detune);\n      this.Q.connect(filter.Q);\n      this.gain.connect(filter.gain);\n      this._filters[count] = filter;\n    }\n\n    this._internalChannels = this._filters;\n    connectSeries(this.input, ...this._internalChannels, this.output);\n  }\n  /**\n   * Get the frequency response curve. This curve represents how the filter\n   * responses to frequencies between 20hz-20khz.\n   * @param  len The number of values to return\n   * @return The frequency response curve between 20-20kHz\n   */\n\n\n  getFrequencyResponse(len = 128) {\n    // start with all 1s\n    const totalResponse = new Float32Array(len).map(() => 1);\n    const freqValues = new Float32Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const norm = Math.pow(i / len, 2);\n      const freq = norm * (20000 - 20) + 20;\n      freqValues[i] = freq;\n    }\n\n    const magValues = new Float32Array(len);\n    const phaseValues = new Float32Array(len);\n\n    this._filters.forEach(() => {\n      const filterClone = this.context.createBiquadFilter();\n      filterClone.type = this._type;\n      filterClone.Q.value = this.Q.value;\n      filterClone.frequency.value = this.frequency.value;\n      filterClone.gain.value = this.gain.value;\n      filterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n      magValues.forEach((val, i) => {\n        totalResponse[i] *= val;\n      });\n    });\n\n    return totalResponse;\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._filters.forEach(filter => {\n      filter.disconnect();\n    });\n\n    writable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n    this.frequency.dispose();\n    this.Q.dispose();\n    this.detune.dispose();\n    this.gain.dispose();\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope } from \"./Envelope\";\nimport { Scale } from \"../../signal/Scale\";\nimport { Pow } from \"../../signal/Pow\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FrequencyEnvelope is an [[Envelope]] which ramps between [[baseFrequency]]\n * and [[octaves]]. It can also have an optional [[exponent]] to adjust the curve\n * which it ramps.\n * @example\n * const oscillator = new Tone.Oscillator().toDestination().start();\n * const freqEnv = new Tone.FrequencyEnvelope({\n * \tattack: 0.2,\n * \tbaseFrequency: \"C2\",\n * \toctaves: 4\n * });\n * freqEnv.connect(oscillator.frequency);\n * freqEnv.triggerAttack();\n */\n\nexport class FrequencyEnvelope extends Envelope {\n  constructor() {\n    super(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    this.name = \"FrequencyEnvelope\";\n    const options = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    this._octaves = options.octaves;\n    this._baseFrequency = this.toFrequency(options.baseFrequency);\n    this._exponent = this.input = new Pow({\n      context: this.context,\n      value: options.exponent\n    });\n    this._scale = this.output = new Scale({\n      context: this.context,\n      min: this._baseFrequency,\n      max: this._baseFrequency * Math.pow(2, this._octaves)\n    });\n\n    this._sig.chain(this._exponent, this._scale);\n  }\n\n  static getDefaults() {\n    return Object.assign(Envelope.getDefaults(), {\n      baseFrequency: 200,\n      exponent: 1,\n      octaves: 4\n    });\n  }\n  /**\n   * The envelope's minimum output value. This is the value which it\n   * starts at.\n   */\n\n\n  get baseFrequency() {\n    return this._baseFrequency;\n  }\n\n  set baseFrequency(min) {\n    const freq = this.toFrequency(min);\n    assertRange(freq, 0);\n    this._baseFrequency = freq;\n    this._scale.min = this._baseFrequency; // update the max value when the min changes\n\n    this.octaves = this._octaves;\n  }\n  /**\n   * The number of octaves above the baseFrequency that the\n   * envelope will scale to.\n   */\n\n\n  get octaves() {\n    return this._octaves;\n  }\n\n  set octaves(octaves) {\n    assertRange(octaves, 0);\n    this._octaves = octaves;\n    this._scale.max = this._baseFrequency * Math.pow(2, octaves);\n  }\n  /**\n   * The envelope's exponent value.\n   */\n\n\n  get exponent() {\n    return this._exponent.value;\n  }\n\n  set exponent(exponent) {\n    this._exponent.value = exponent;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._exponent.dispose();\n\n    this._scale.dispose();\n\n    return this;\n  }\n\n}","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope } from \"../component/envelope/FrequencyEnvelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\n\nexport class MonoSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n    this.name = \"MonoSynth\";\n    const options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n    this.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n      context: this.context,\n      detune: options.detune,\n      onstop: () => this.onsilence(this)\n    }));\n    this.frequency = this.oscillator.frequency;\n    this.detune = this.oscillator.detune;\n    this.filter = new Filter(Object.assign(options.filter, {\n      context: this.context\n    }));\n    this.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, {\n      context: this.context\n    }));\n    this.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, {\n      context: this.context\n    })); // connect the oscillators to the output\n\n    this.oscillator.chain(this.filter, this.envelope, this.output); // connect the filter envelope\n\n    this.filterEnvelope.connect(this.filter.frequency);\n    readOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.005,\n        decay: 0.1,\n        release: 1,\n        sustain: 0.9\n      }),\n      filter: Object.assign(omitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        Q: 1,\n        rolloff: -12,\n        type: \"lowpass\"\n      }),\n      filterEnvelope: Object.assign(omitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.6,\n        baseFrequency: 200,\n        decay: 0.2,\n        exponent: 2,\n        octaves: 3,\n        release: 2,\n        sustain: 0.5\n      }),\n      oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())), {\n        type: \"sawtooth\"\n      })\n    });\n  }\n  /**\n   * start the attack portion of the envelope\n   * @param time the time the attack should start\n   * @param velocity the velocity of the note (0-1)\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity = 1) {\n    this.envelope.triggerAttack(time, velocity);\n    this.filterEnvelope.triggerAttack(time);\n    this.oscillator.start(time);\n\n    if (this.envelope.sustain === 0) {\n      const computedAttack = this.toSeconds(this.envelope.attack);\n      const computedDecay = this.toSeconds(this.envelope.decay);\n      this.oscillator.stop(time + computedAttack + computedDecay);\n    }\n  }\n  /**\n   * start the release portion of the envelope\n   * @param time the time the release should start\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n    this.filterEnvelope.triggerRelease(time);\n    this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n\n  dispose() {\n    super.dispose();\n    this.oscillator.dispose();\n    this.envelope.dispose();\n    this.filterEnvelope.dispose();\n    this.filter.dispose();\n    return this;\n  }\n\n}","import { Monophonic } from \"./Monophonic\";\nimport { MonoSynth } from \"./MonoSynth\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n/**\n * DuoSynth is a monophonic synth composed of two [[MonoSynths]] run in parallel with control over the\n * frequency ratio between the two voices and vibrato effect.\n * @example\n * const duoSynth = new Tone.DuoSynth().toDestination();\n * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n * @category Instrument\n */\n\nexport class DuoSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(DuoSynth.getDefaults(), arguments));\n    this.name = \"DuoSynth\";\n    const options = optionsFromArguments(DuoSynth.getDefaults(), arguments);\n    this.voice0 = new MonoSynth(Object.assign(options.voice0, {\n      context: this.context,\n      onsilence: () => this.onsilence(this)\n    }));\n    this.voice1 = new MonoSynth(Object.assign(options.voice1, {\n      context: this.context\n    }));\n    this.harmonicity = new Multiply({\n      context: this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    this._vibrato = new LFO({\n      frequency: options.vibratoRate,\n      context: this.context,\n      min: -50,\n      max: 50\n    }); // start the vibrato immediately\n\n    this._vibrato.start();\n\n    this.vibratoRate = this._vibrato.frequency;\n    this._vibratoGain = new Gain({\n      context: this.context,\n      units: \"normalRange\",\n      gain: options.vibratoAmount\n    });\n    this.vibratoAmount = this._vibratoGain.gain;\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: 440\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    }); // control the two voices frequency\n\n    this.frequency.connect(this.voice0.frequency);\n    this.frequency.chain(this.harmonicity, this.voice1.frequency);\n\n    this._vibrato.connect(this._vibratoGain);\n\n    this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\n    this.detune.fan(this.voice0.detune, this.voice1.detune);\n    this.voice0.connect(this.output);\n    this.voice1.connect(this.output);\n    readOnly(this, [\"voice0\", \"voice1\", \"frequency\", \"vibratoAmount\", \"vibratoRate\"]);\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.voice0.envelope.getValueAtTime(time) + this.voice1.envelope.getValueAtTime(time);\n  }\n\n  static getDefaults() {\n    return deepMerge(Monophonic.getDefaults(), {\n      vibratoAmount: 0.5,\n      vibratoRate: 5,\n      harmonicity: 1.5,\n      voice0: deepMerge(omitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), {\n        filterEnvelope: {\n          attack: 0.01,\n          decay: 0.0,\n          sustain: 1,\n          release: 0.5\n        },\n        envelope: {\n          attack: 0.01,\n          decay: 0.0,\n          sustain: 1,\n          release: 0.5\n        }\n      }),\n      voice1: deepMerge(omitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())), {\n        filterEnvelope: {\n          attack: 0.01,\n          decay: 0.0,\n          sustain: 1,\n          release: 0.5\n        },\n        envelope: {\n          attack: 0.01,\n          decay: 0.0,\n          sustain: 1,\n          release: 0.5\n        }\n      })\n    });\n  }\n  /**\n   * Trigger the attack portion of the note\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity) {\n    // @ts-ignore\n    this.voice0._triggerEnvelopeAttack(time, velocity); // @ts-ignore\n\n\n    this.voice1._triggerEnvelopeAttack(time, velocity);\n  }\n  /**\n   * Trigger the release portion of the note\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    // @ts-ignore\n    this.voice0._triggerEnvelopeRelease(time); // @ts-ignore\n\n\n    this.voice1._triggerEnvelopeRelease(time);\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.voice0.dispose();\n    this.voice1.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._vibrato.dispose();\n\n    this.vibratoRate.dispose();\n\n    this._vibratoGain.dispose();\n\n    this.harmonicity.dispose();\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { ModulationSynth } from \"./ModulationSynth\";\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * const fmSynth = new Tone.FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n *\n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth {\n  constructor() {\n    super(optionsFromArguments(FMSynth.getDefaults(), arguments));\n    this.name = \"FMSynth\";\n    const options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n    this.modulationIndex = new Multiply({\n      context: this.context,\n      value: options.modulationIndex\n    }); // control the two voices frequency\n\n    this.frequency.connect(this._carrier.frequency);\n    this.frequency.chain(this.harmonicity, this._modulator.frequency);\n    this.frequency.chain(this.modulationIndex, this._modulationNode);\n    this.detune.fan(this._carrier.detune, this._modulator.detune);\n\n    this._modulator.connect(this._modulationNode.gain);\n\n    this._modulationNode.connect(this._carrier.frequency);\n\n    this._carrier.connect(this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(ModulationSynth.getDefaults(), {\n      modulationIndex: 10\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.modulationIndex.dispose();\n    return this;\n  }\n\n}","import { Envelope } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\n\nconst inharmRatios = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).\n * @category Instrument\n */\n\nexport class MetalSynth extends Monophonic {\n  constructor() {\n    super(optionsFromArguments(MetalSynth.getDefaults(), arguments));\n    this.name = \"MetalSynth\";\n    /**\n     * The array of FMOscillators\n     */\n\n    this._oscillators = [];\n    /**\n     * The frequency multipliers\n     */\n\n    this._freqMultipliers = [];\n    const options = optionsFromArguments(MetalSynth.getDefaults(), arguments);\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\"\n    });\n    this._amplitude = new Gain({\n      context: this.context,\n      gain: 0\n    }).connect(this.output);\n    this._highpass = new Filter({\n      // Q: -3.0102999566398125,\n      Q: 0,\n      context: this.context,\n      type: \"highpass\"\n    }).connect(this._amplitude);\n\n    for (let i = 0; i < inharmRatios.length; i++) {\n      const osc = new FMOscillator({\n        context: this.context,\n        harmonicity: options.harmonicity,\n        modulationIndex: options.modulationIndex,\n        modulationType: \"square\",\n        onstop: i === 0 ? () => this.onsilence(this) : noOp,\n        type: \"square\"\n      });\n      osc.connect(this._highpass);\n      this._oscillators[i] = osc;\n      const mult = new Multiply({\n        context: this.context,\n        value: inharmRatios[i]\n      });\n      this._freqMultipliers[i] = mult;\n      this.frequency.chain(mult, osc.frequency);\n      this.detune.connect(osc.detune);\n    }\n\n    this._filterFreqScaler = new Scale({\n      context: this.context,\n      max: 7000,\n      min: this.toFrequency(options.resonance)\n    });\n    this.envelope = new Envelope({\n      attack: options.envelope.attack,\n      attackCurve: \"linear\",\n      context: this.context,\n      decay: options.envelope.decay,\n      release: options.envelope.release,\n      sustain: 0\n    });\n    this.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n    this.envelope.connect(this._amplitude.gain); // set the octaves\n\n    this._octaves = options.octaves;\n    this.octaves = options.octaves;\n  }\n\n  static getDefaults() {\n    return deepMerge(Monophonic.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        attack: 0.001,\n        decay: 1.4,\n        release: 0.2\n      }),\n      harmonicity: 5.1,\n      modulationIndex: 32,\n      octaves: 1.5,\n      resonance: 4000\n    });\n  }\n  /**\n   * Trigger the attack.\n   * @param time When the attack should be triggered.\n   * @param velocity The velocity that the envelope should be triggered at.\n   */\n\n\n  _triggerEnvelopeAttack(time, velocity = 1) {\n    this.envelope.triggerAttack(time, velocity);\n\n    this._oscillators.forEach(osc => osc.start(time));\n\n    if (this.envelope.sustain === 0) {\n      this._oscillators.forEach(osc => {\n        osc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Trigger the release of the envelope.\n   * @param time When the release should be triggered.\n   */\n\n\n  _triggerEnvelopeRelease(time) {\n    this.envelope.triggerRelease(time);\n\n    this._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));\n\n    return this;\n  }\n\n  getLevelAtTime(time) {\n    time = this.toSeconds(time);\n    return this.envelope.getValueAtTime(time);\n  }\n  /**\n   * The modulationIndex of the oscillators which make up the source.\n   * see [[FMOscillator.modulationIndex]]\n   * @min 1\n   * @max 100\n   */\n\n\n  get modulationIndex() {\n    return this._oscillators[0].modulationIndex.value;\n  }\n\n  set modulationIndex(val) {\n    this._oscillators.forEach(osc => osc.modulationIndex.value = val);\n  }\n  /**\n   * The harmonicity of the oscillators which make up the source.\n   * see Tone.FMOscillator.harmonicity\n   * @min 0.1\n   * @max 10\n   */\n\n\n  get harmonicity() {\n    return this._oscillators[0].harmonicity.value;\n  }\n\n  set harmonicity(val) {\n    this._oscillators.forEach(osc => osc.harmonicity.value = val);\n  }\n  /**\n   * The lower level of the highpass filter which is attached to the envelope.\n   * This value should be between [0, 7000]\n   * @min 0\n   * @max 7000\n   */\n\n\n  get resonance() {\n    return this._filterFreqScaler.min;\n  }\n\n  set resonance(val) {\n    this._filterFreqScaler.min = this.toFrequency(val);\n    this.octaves = this._octaves;\n  }\n  /**\n   * The number of octaves above the \"resonance\" frequency\n   * that the filter ramps during the attack/decay envelope\n   * @min 0\n   * @max 8\n   */\n\n\n  get octaves() {\n    return this._octaves;\n  }\n\n  set octaves(val) {\n    this._octaves = val;\n    this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._oscillators.forEach(osc => osc.dispose());\n\n    this._freqMultipliers.forEach(freqMult => freqMult.dispose());\n\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._filterFreqScaler.dispose();\n\n    this._amplitude.dispose();\n\n    this.envelope.dispose();\n\n    this._highpass.dispose();\n\n    return this;\n  }\n\n}","import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\n\nexport class MembraneSynth extends Synth {\n  constructor() {\n    super(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n    this.name = \"MembraneSynth\";\n    /**\n     * Portamento is ignored in this synth. use pitch decay instead.\n     */\n\n    this.portamento = 0;\n    const options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n    this.pitchDecay = options.pitchDecay;\n    this.octaves = options.octaves;\n    readOnly(this, [\"oscillator\", \"envelope\"]);\n  }\n\n  static getDefaults() {\n    return deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n      envelope: {\n        attack: 0.001,\n        attackCurve: \"exponential\",\n        decay: 0.4,\n        release: 1.4,\n        sustain: 0.01\n      },\n      octaves: 10,\n      oscillator: {\n        type: \"sine\"\n      },\n      pitchDecay: 0.05\n    });\n  }\n\n  setNote(note, time) {\n    const seconds = this.toSeconds(time);\n    const hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n    const maxNote = hertz * this.octaves;\n    this.oscillator.frequency.setValueAtTime(maxNote, seconds);\n    this.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    return this;\n  }\n\n}\n\n__decorate([range(0)], MembraneSynth.prototype, \"octaves\", void 0);\n\n__decorate([timeRange(0)], MembraneSynth.prototype, \"pitchDecay\", void 0);","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument } from \"./Instrument\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]].\n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\n\nexport class NoiseSynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n    this.name = \"NoiseSynth\";\n    const options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n    this.noise = new Noise(Object.assign({\n      context: this.context\n    }, options.noise));\n    this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: this.context\n    }, options.envelope)); // connect the noise to the output\n\n    this.noise.chain(this.envelope, this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n        decay: 0.1,\n        sustain: 0.0\n      }),\n      noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {\n        type: \"white\"\n      })\n    });\n  }\n  /**\n   * Start the attack portion of the envelopes. Unlike other\n   * instruments, Tone.NoiseSynth doesn't have a note.\n   * @example\n   * const noiseSynth = new Tone.NoiseSynth().toDestination();\n   * noiseSynth.triggerAttack();\n   */\n\n\n  triggerAttack(time, velocity = 1) {\n    time = this.toSeconds(time); // the envelopes\n\n    this.envelope.triggerAttack(time, velocity); // start the noise\n\n    this.noise.start(time);\n\n    if (this.envelope.sustain === 0) {\n      this.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n    }\n\n    return this;\n  }\n  /**\n   * Start the release portion of the envelopes.\n   */\n\n\n  triggerRelease(time) {\n    time = this.toSeconds(time);\n    this.envelope.triggerRelease(time);\n    this.noise.stop(time + this.toSeconds(this.envelope.release));\n    return this;\n  }\n\n  sync() {\n    this._syncMethod(\"triggerAttack\", 0);\n\n    this._syncMethod(\"triggerRelease\", 0);\n\n    return this;\n  }\n\n  triggerAttackRelease(duration, time, velocity = 1) {\n    time = this.toSeconds(time);\n    duration = this.toSeconds(duration);\n    this.triggerAttack(time, velocity);\n    this.triggerRelease(time + duration);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.noise.dispose();\n    this.envelope.dispose();\n    return this;\n  }\n\n}","const workletContext = new Set();\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\n\nexport function addToWorklet(classOrFunction) {\n  workletContext.add(classOrFunctionToString(classOrFunction));\n}\n/**\n * Converts a class or a function to a string so it can be used in the worklet context\n */\n\nfunction classOrFunctionToString(classOrFunction) {\n  const regexp = new RegExp(/class.*extends.*\\{/m);\n  const matches = classOrFunction.toString().match(regexp);\n\n  if (matches) {\n    // if it extends another class, get that class name\n    return classOrFunction.toString().replace(matches[0], `class ${classOrFunction.name} extends ${Object.getPrototypeOf(classOrFunction).name} {`);\n  } else {\n    // otherwise just return the class as a string\n    return classOrFunction.toString();\n  }\n}\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\n\n\nexport function registerProcessor(name, classDesc) {\n  const processor =\n  /* javascript */\n  `registerProcessor(\"${name}\", ${classOrFunctionToString(classDesc)})`;\n  workletContext.add(processor);\n}\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\n\nexport function getWorkletGlobalScope() {\n  return Array.from(workletContext).join(\"\\n\");\n}","import { ToneAudioNode } from \"../context/ToneAudioNode\";\nimport { noOp } from \"../util/Interface\";\nimport { getWorkletGlobalScope } from \"./WorkletGlobalScope\";\nexport class ToneAudioWorklet extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"ToneAudioWorklet\";\n    /**\n     * The constructor options for the node\n     */\n\n    this.workletOptions = {};\n    /**\n     * Callback which is invoked when there is an error in the processing\n     */\n\n    this.onprocessorerror = noOp;\n    const blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], {\n      type: \"text/javascript\"\n    }));\n\n    const name = this._audioWorkletName();\n\n    this._dummyGain = this.context.createGain();\n    this._dummyParam = this._dummyGain.gain; // Register the processor\n\n    this.context.addAudioWorkletModule(blobUrl, name).then(() => {\n      // create the worklet when it's read\n      if (!this.disposed) {\n        this._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);\n        this._worklet.onprocessorerror = this.onprocessorerror.bind(this);\n        this.onReady(this._worklet);\n      }\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dummyGain.disconnect();\n\n    if (this._worklet) {\n      this._worklet.port.postMessage(\"dispose\");\n\n      this._worklet.disconnect();\n    }\n\n    return this;\n  }\n\n}","import { AudioWorkletProcessor } from \"./AudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n/**\n * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]].\n */\n\nexport class ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n  constructor(options) {\n    super(options);\n    /**\n     * If the processor was disposed or not. Keep alive until it's disposed.\n     */\n\n    this.disposed = false;\n    /**\n     * The number of samples in the processing block\n     */\n\n    this.blockSize = 128;\n    /**\n     * the sample rate\n     */\n    // @ts-ignore\n\n    this.sampleRate = sampleRate;\n\n    this.port.onmessage = event => {\n      // when it receives a dispose \n      if (event.data === \"dispose\") {\n        this.disposed = true;\n      }\n    };\n  }\n\n}\naddToWorklet(ToneAudioWorkletProcessor);","/**\n * This is just an interface for the AudioWorkletProcessor\n */\nexport class AudioWorkletProcessor {\n  constructor(_options) {\n    this.parameterDescriptors = [];\n    this.port = new MessagePort();\n  }\n\n  process(_inputs, _outputs, _parameters) {\n    return false;\n  }\n\n}","import { ToneAudioWorkletProcessor } from \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\nexport class SingleIOProcessor extends ToneAudioWorkletProcessor {\n  constructor(options) {\n    super(Object.assign(options, {\n      numberOfInputs: 1,\n      numberOfOutputs: 1\n    }));\n    /**\n     * Holds the name of the parameter and a single value of that\n     * parameter at the current sample\n     */\n\n    this.params = {};\n  }\n  /**\n   * Update the private `params` object with the\n   * values of the parameters at the given index\n   */\n\n\n  updateParams(parameters, index) {\n    for (const paramName in parameters) {\n      const param = parameters[paramName];\n\n      if (param.length > 1) {\n        this.params[paramName] = parameters[paramName][index];\n      } else {\n        this.params[paramName] = parameters[paramName][0];\n      }\n    }\n  }\n  /**\n   * Process a single frame of the audio\n   */\n\n\n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    const output = outputs[0]; // get the parameter values\n\n    const channelCount = Math.max((input === null || input === void 0 ? void 0 : input.length) || 0, output.length);\n\n    for (let sample = 0; sample < this.blockSize; sample++) {\n      this.updateParams(parameters, sample);\n\n      for (let channel = 0; channel < channelCount; channel++) {\n        const inputSample = (input === null || input === void 0 ? void 0 : input.length) ? input[channel][sample] : 0;\n        output[channel][sample] = this.generate(inputSample, channel, this.params);\n      }\n    }\n\n    return !this.disposed;\n  }\n\n}\n;\naddToWorklet(SingleIOProcessor);","import { addToWorklet } from \"./WorkletGlobalScope\";\n/**\n * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n */\n\nexport class DelayLine {\n  constructor(size, channels) {\n    this.buffer = [];\n    this.writeHead = [];\n    this.size = size; // create the empty channels\n\n    for (let i = 0; i < channels; i++) {\n      this.buffer[i] = new Float32Array(this.size);\n      this.writeHead[i] = 0;\n    }\n  }\n  /**\n   * Push a value onto the end\n   */\n\n\n  push(channel, value) {\n    this.writeHead[channel] += 1;\n\n    if (this.writeHead[channel] > this.size) {\n      this.writeHead[channel] = 0;\n    }\n\n    this.buffer[channel][this.writeHead[channel]] = value;\n  }\n  /**\n   * Get the recorded value of the channel given the delay\n   */\n\n\n  get(channel, delay) {\n    let readHead = this.writeHead[channel] - Math.floor(delay);\n\n    if (readHead < 0) {\n      readHead += this.size;\n    }\n\n    return this.buffer[channel][readHead];\n  }\n\n}\naddToWorklet(DelayLine);","import { SingleIOProcessor } from \"../../core/worklet/SingleIOProcessor.worklet\";\nimport \"../../core/worklet/DelayLine.worklet\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"feedback-comb-filter\";\nexport class FeedbackCombFilterWorklet extends SingleIOProcessor {\n  constructor(options) {\n    super(options); // @ts-ignore\n\n    this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n  }\n\n  static get parameterDescriptors() {\n    return [{\n      name: \"delayTime\",\n      defaultValue: 0.1,\n      minValue: 0,\n      maxValue: 1\n    }, {\n      name: \"feedback\",\n      defaultValue: 0.5,\n      minValue: 0,\n      maxValue: 0.9999\n    }];\n  }\n\n  generate(input, channel, parameters) {\n    const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n    this.delayLine.push(channel, input + delayedSample * parameters.feedback); // console.log(channel);\n\n    return delayedSample;\n  }\n\n}\nregisterProcessor(workletName, FeedbackCombFilterWorklet);","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/worklet/ToneAudioWorklet\";\nimport { workletName } from \"./FeedbackCombFilter.worklet\";\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n *\n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the\n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the\n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.\n * @category Component\n */\n\nexport class FeedbackCombFilter extends ToneAudioWorklet {\n  constructor() {\n    super(optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]));\n    this.name = \"FeedbackCombFilter\";\n    const options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    this.delayTime = new Param({\n      context: this.context,\n      value: options.delayTime,\n      units: \"time\",\n      minValue: 0,\n      maxValue: 1,\n      param: this._dummyParam,\n      swappable: true\n    });\n    this.resonance = new Param({\n      context: this.context,\n      value: options.resonance,\n      units: \"normalRange\",\n      param: this._dummyParam,\n      swappable: true\n    });\n    readOnly(this, [\"resonance\", \"delayTime\"]);\n  }\n\n  _audioWorkletName() {\n    return workletName;\n  }\n  /**\n   * The default parameters\n   */\n\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      delayTime: 0.1,\n      resonance: 0.5\n    });\n  }\n\n  onReady(node) {\n    connectSeries(this.input, node, this.output);\n    const delayTime = node.parameters.get(\"delayTime\");\n    ;\n    this.delayTime.setParam(delayTime);\n    const feedback = node.parameters.get(\"feedback\");\n    ;\n    this.resonance.setParam(feedback);\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.delayTime.dispose();\n    this.resonance.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\".\n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop.\n * References:\n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/\n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\n\nexport class OnePoleFilter extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    this.name = \"OnePoleFilter\";\n    const options = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    this._frequency = options.frequency;\n    this._type = options.type;\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n\n    this._createFilter();\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      frequency: 880,\n      type: \"lowpass\"\n    });\n  }\n  /**\n   * Create a filter and dispose the old one\n   */\n\n\n  _createFilter() {\n    const oldFilter = this._filter;\n    const freq = this.toFrequency(this._frequency);\n    const t = 1 / (2 * Math.PI * freq);\n\n    if (this._type === \"lowpass\") {\n      const a0 = 1 / (t * this.context.sampleRate);\n      const b1 = a0 - 1;\n      this._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n    } else {\n      const b1 = 1 / (t * this.context.sampleRate) - 1;\n      this._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n    }\n\n    this.input.chain(this._filter, this.output);\n\n    if (oldFilter) {\n      // dispose it on the next block\n      this.context.setTimeout(() => {\n        if (!this.disposed) {\n          this.input.disconnect(oldFilter);\n          oldFilter.disconnect();\n        }\n      }, this.blockTime);\n    }\n  }\n  /**\n   * The frequency value.\n   */\n\n\n  get frequency() {\n    return this._frequency;\n  }\n\n  set frequency(fq) {\n    this._frequency = fq;\n\n    this._createFilter();\n  }\n  /**\n   * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(t) {\n    this._type = t;\n\n    this._createFilter();\n  }\n  /**\n   * Get the frequency response curve. This curve represents how the filter\n   * responses to frequencies between 20hz-20khz.\n   * @param  len The number of values to return\n   * @return The frequency response curve between 20-20kHz\n   */\n\n\n  getFrequencyResponse(len = 128) {\n    const freqValues = new Float32Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const norm = Math.pow(i / len, 2);\n      const freq = norm * (20000 - 20) + 20;\n      freqValues[i] = freq;\n    }\n\n    const magValues = new Float32Array(len);\n    const phaseValues = new Float32Array(len);\n\n    this._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\n    return magValues;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n\n    this._filter.disconnect();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter\";\nimport { OnePoleFilter } from \"./OnePoleFilter\";\n/**\n * A lowpass feedback comb filter. It is similar to\n * [[FeedbackCombFilter]], but includes a lowpass filter.\n * @category Component\n */\n\nexport class LowpassCombFilter extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]));\n    this.name = \"LowpassCombFilter\";\n    const options = optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]);\n    this._combFilter = this.output = new FeedbackCombFilter({\n      context: this.context,\n      delayTime: options.delayTime,\n      resonance: options.resonance\n    });\n    this.delayTime = this._combFilter.delayTime;\n    this.resonance = this._combFilter.resonance;\n    this._lowpass = this.input = new OnePoleFilter({\n      context: this.context,\n      frequency: options.dampening,\n      type: \"lowpass\"\n    }); // connections\n\n    this._lowpass.connect(this._combFilter);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      dampening: 3000,\n      delayTime: 0.1,\n      resonance: 0.5\n    });\n  }\n  /**\n   * The dampening control of the feedback\n   */\n\n\n  get dampening() {\n    return this._lowpass.frequency;\n  }\n\n  set dampening(fq) {\n    this._lowpass.frequency = fq;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._combFilter.dispose();\n\n    this._lowpass.dispose();\n\n    return this;\n  }\n\n}","import { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\nimport { deepMerge } from \"../core/util/Defaults\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument } from \"./Instrument\";\n/**\n * Karplus-String string synthesis.\n * @example\n * const plucky = new Tone.PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\", \"+0.5\");\n * plucky.triggerAttack(\"C3\", \"+1\");\n * plucky.triggerAttack(\"C2\", \"+1.5\");\n * plucky.triggerAttack(\"C1\", \"+2\");\n * @category Instrument\n */\n\nexport class PluckSynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(PluckSynth.getDefaults(), arguments));\n    this.name = \"PluckSynth\";\n    const options = optionsFromArguments(PluckSynth.getDefaults(), arguments);\n    this._noise = new Noise({\n      context: this.context,\n      type: \"pink\"\n    });\n    this.attackNoise = options.attackNoise;\n    this._lfcf = new LowpassCombFilter({\n      context: this.context,\n      dampening: options.dampening,\n      resonance: options.resonance\n    });\n    this.resonance = options.resonance;\n    this.release = options.release;\n\n    this._noise.connect(this._lfcf);\n\n    this._lfcf.connect(this.output);\n  }\n\n  static getDefaults() {\n    return deepMerge(Instrument.getDefaults(), {\n      attackNoise: 1,\n      dampening: 4000,\n      resonance: 0.7,\n      release: 1\n    });\n  }\n  /**\n   * The dampening control. i.e. the lowpass filter frequency of the comb filter\n   * @min 0\n   * @max 7000\n   */\n\n\n  get dampening() {\n    return this._lfcf.dampening;\n  }\n\n  set dampening(fq) {\n    this._lfcf.dampening = fq;\n  }\n\n  triggerAttack(note, time) {\n    const freq = this.toFrequency(note);\n    time = this.toSeconds(time);\n    const delayAmount = 1 / freq;\n\n    this._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\n    this._noise.start(time);\n\n    this._noise.stop(time + delayAmount * this.attackNoise);\n\n    this._lfcf.resonance.cancelScheduledValues(time);\n\n    this._lfcf.resonance.setValueAtTime(this.resonance, time);\n\n    return this;\n  }\n  /**\n   * Ramp down the [[resonance]] to 0 over the duration of the release time.\n   */\n\n\n  triggerRelease(time) {\n    this._lfcf.resonance.linearRampTo(0, this.release, time);\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._noise.dispose();\n\n    this._lfcf.dispose();\n\n    return this;\n  }\n\n}","import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nexport class PolySynth extends Instrument {\n  constructor() {\n    super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    this._averageActiveVoices = 0;\n    const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    const defaults = options.voice.getDefaults();\n    this.options = Object.assign(defaults, options.options);\n    this.voice = options.voice;\n    this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    this._dummyVoice = this._getNextAvailableVoice(); // remove it from the voices list\n\n    const index = this._voices.indexOf(this._dummyVoice);\n\n    this._voices.splice(index, 1); // kick off the GC interval\n\n\n    this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      maxPolyphony: 32,\n      options: {},\n      voice: Synth\n    });\n  }\n  /**\n   * The number of active voices.\n   */\n\n\n  get activeVoices() {\n    return this._activeVoices.length;\n  }\n  /**\n   * Invoked when the source is done making sound, so that it can be\n   * readded to the pool of available voices\n   */\n\n\n  _makeVoiceAvailable(voice) {\n    this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n    const activeVoiceIndex = this._activeVoices.findIndex(e => e.voice === voice);\n\n    this._activeVoices.splice(activeVoiceIndex, 1);\n  }\n  /**\n   * Get an available voice from the pool of available voices.\n   * If one is not available and the maxPolyphony limit is reached,\n   * steal a voice, otherwise return null.\n   */\n\n\n  _getNextAvailableVoice() {\n    // if there are available voices, return the first one\n    if (this._availableVoices.length) {\n      return this._availableVoices.shift();\n    } else if (this._voices.length < this.maxPolyphony) {\n      // otherwise if there is still more maxPolyphony, make a new voice\n      const voice = new this.voice(Object.assign(this.options, {\n        context: this.context,\n        onsilence: this._makeVoiceAvailable.bind(this)\n      }));\n      voice.connect(this.output);\n\n      this._voices.push(voice);\n\n      return voice;\n    } else {\n      warn(\"Max polyphony exceeded. Note dropped.\");\n    }\n  }\n  /**\n   * Occasionally check if there are any allocated voices which can be cleaned up.\n   */\n\n\n  _collectGarbage() {\n    this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n    if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n      // take off an available note\n      const firstAvail = this._availableVoices.shift();\n\n      const index = this._voices.indexOf(firstAvail);\n\n      this._voices.splice(index, 1);\n\n      if (!this.context.isOffline) {\n        firstAvail.dispose();\n      }\n    }\n  }\n  /**\n   * Internal method which triggers the attack\n   */\n\n\n  _triggerAttack(notes, time, velocity) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const voice = this._getNextAvailableVoice();\n\n      if (voice) {\n        voice.triggerAttack(note, time, velocity);\n\n        this._activeVoices.push({\n          midi: midiNote,\n          voice,\n          released: false\n        });\n\n        this.log(\"triggerAttack\", note, time);\n      }\n    });\n  }\n  /**\n   * Internal method which triggers the release\n   */\n\n\n  _triggerRelease(notes, time) {\n    notes.forEach(note => {\n      const midiNote = new MidiClass(this.context, note).toMidi();\n\n      const event = this._activeVoices.find(({\n        midi,\n        released\n      }) => midi === midiNote && !released);\n\n      if (event) {\n        // trigger release on that note\n        event.voice.triggerRelease(time); // mark it as released\n\n        event.released = true;\n        this.log(\"triggerRelease\", note, time);\n      }\n    });\n  }\n  /**\n   * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n   * to wait for just-in-time scheduling\n   */\n\n\n  _scheduleEvent(type, notes, time, velocity) {\n    assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n    if (time <= this.now()) {\n      // do it immediately\n      if (type === \"attack\") {\n        this._triggerAttack(notes, time, velocity);\n      } else {\n        this._triggerRelease(notes, time);\n      }\n    } else {\n      // schedule it to start in the future\n      this.context.setTimeout(() => {\n        this._scheduleEvent(type, notes, time, velocity);\n      }, time - this.now());\n    }\n  }\n  /**\n   * Trigger the attack portion of the note\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  The start time of the note.\n   * @param velocity The velocity of the note.\n   * @example\n   * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n   * // trigger a chord immediately with a velocity of 0.2\n   * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n   */\n\n\n  triggerAttack(notes, time, velocity) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n    return this;\n  }\n  /**\n   * Trigger the release of the note. Unlike monophonic instruments,\n   * a note (or array of notes) needs to be passed in as the first argument.\n   * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n   * @param  time  When the release will be triggered.\n   * @example\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n   * // trigger the release of the given notes.\n   * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n   * poly.triggerRelease(\"F5\", \"+3\");\n   */\n\n\n  triggerRelease(notes, time) {\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    const computedTime = this.toSeconds(time);\n\n    this._scheduleEvent(\"release\", notes, computedTime);\n\n    return this;\n  }\n  /**\n   * Trigger the attack and release after the specified duration\n   * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n   * @param  duration the duration of the note\n   * @param  time  if no time is given, defaults to now\n   * @param  velocity the velocity of the attack (0-1)\n   * @example\n   * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n   * // can pass in an array of durations as well\n   * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n   */\n\n\n  triggerAttackRelease(notes, duration, time, velocity) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n      notes = notes;\n\n      for (let i = 0; i < notes.length; i++) {\n        const d = duration[Math.min(i, duration.length - 1)];\n        const durationSeconds = this.toSeconds(d);\n        assert(durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes[i], computedTime + durationSeconds);\n      }\n    } else {\n      const durationSeconds = this.toSeconds(duration);\n      assert(durationSeconds > 0, \"The duration must be greater than 0\");\n      this.triggerRelease(notes, computedTime + durationSeconds);\n    }\n\n    return this;\n  }\n\n  sync() {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  }\n  /**\n   * Set a member/attribute of the voices\n   * @example\n   * const poly = new Tone.PolySynth().toDestination();\n   * // set all of the voices using an options object for the synth type\n   * poly.set({\n   * \tenvelope: {\n   * \t\tattack: 0.25\n   * \t}\n   * });\n   * poly.triggerAttackRelease(\"Bb3\", 0.2);\n   */\n\n\n  set(options) {\n    // remove options which are controlled by the PolySynth\n    const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n    this.options = deepMerge(this.options, sanitizedOptions);\n\n    this._voices.forEach(voice => voice.set(sanitizedOptions));\n\n    this._dummyVoice.set(sanitizedOptions);\n\n    return this;\n  }\n\n  get() {\n    return this._dummyVoice.get();\n  }\n  /**\n   * Trigger the release portion of all the currently active voices immediately.\n   * Useful for silencing the synth.\n   */\n\n\n  releaseAll() {\n    const now = this.now();\n\n    this._activeVoices.forEach(({\n      voice\n    }) => {\n      voice.triggerRelease(now);\n    });\n\n    this._activeVoices = [];\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dummyVoice.dispose();\n\n    this._voices.forEach(v => v.dispose());\n\n    this._activeVoices = [];\n    this._availableVoices = [];\n    this.context.clearInterval(this._gcTimeout);\n    return this;\n  }\n\n}","import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tC1: \"C1.mp3\",\n * \t\tC2: \"C2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/examples/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t},\n * });\n * @category Instrument\n */\n\nexport class Sampler extends Instrument {\n  constructor() {\n    super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    this._activeSources = new Map();\n    const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    const urlMap = {};\n    Object.keys(options.urls).forEach(note => {\n      const noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), `url key is neither a note or midi pitch: ${note}`);\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        const mid = new FrequencyClass(this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    this.attack = options.attack;\n    this.release = options.release;\n    this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n  }\n\n  static getDefaults() {\n    return Object.assign(Instrument.getDefaults(), {\n      attack: 0,\n      baseUrl: \"\",\n      curve: \"exponential\",\n      onload: noOp,\n      onerror: noOp,\n      release: 0.1,\n      urls: {}\n    });\n  }\n  /**\n   * Returns the difference in steps between the given midi note at the closets sample.\n   */\n\n\n  _findClosest(midi) {\n    // searches within 8 octaves of the given midi note\n    const MAX_INTERVAL = 96;\n    let interval = 0;\n\n    while (interval < MAX_INTERVAL) {\n      // check above and below\n      if (this._buffers.has(midi + interval)) {\n        return -interval;\n      } else if (this._buffers.has(midi - interval)) {\n        return interval;\n      }\n\n      interval++;\n    }\n\n    throw new Error(`No available buffers for note: ${midi}`);\n  }\n  /**\n   * @param  notes\tThe note to play, or an array of notes.\n   * @param  time     When to play the note\n   * @param  velocity The velocity to play the sample back.\n   */\n\n\n  triggerAttack(notes, time, velocity = 1) {\n    this.log(\"triggerAttack\", notes, time, velocity);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the closest note pitch\n\n      const difference = this._findClosest(midi);\n\n      const closestNote = midi - difference;\n\n      const buffer = this._buffers.get(closestNote);\n\n      const playbackRate = intervalToFrequencyRatio(difference); // play that note\n\n      const source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        curve: this.curve,\n        fadeIn: this.attack,\n        fadeOut: this.release,\n        playbackRate\n      }).connect(this.output);\n      source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n      if (!isArray(this._activeSources.get(midi))) {\n        this._activeSources.set(midi, []);\n      }\n\n      this._activeSources.get(midi).push(source); // remove it when it's done\n\n\n      source.onended = () => {\n        if (this._activeSources && this._activeSources.has(midi)) {\n          const sources = this._activeSources.get(midi);\n\n          const index = sources.indexOf(source);\n\n          if (index !== -1) {\n            sources.splice(index, 1);\n          }\n        }\n      };\n    });\n    return this;\n  }\n  /**\n   * @param  notes\tThe note to release, or an array of notes.\n   * @param  time     \tWhen to release the note.\n   */\n\n\n  triggerRelease(notes, time) {\n    this.log(\"triggerRelease\", notes, time);\n\n    if (!Array.isArray(notes)) {\n      notes = [notes];\n    }\n\n    notes.forEach(note => {\n      const midi = new FrequencyClass(this.context, note).toMidi(); // find the note\n\n      if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n        const sources = this._activeSources.get(midi);\n\n        time = this.toSeconds(time);\n        sources.forEach(source => {\n          source.stop(time);\n        });\n\n        this._activeSources.set(midi, []);\n      }\n    });\n    return this;\n  }\n  /**\n   * Release all currently active notes.\n   * @param  time     \tWhen to release the notes.\n   */\n\n\n  releaseAll(time) {\n    const computedTime = this.toSeconds(time);\n\n    this._activeSources.forEach(sources => {\n      while (sources.length) {\n        const source = sources.shift();\n        source.stop(computedTime);\n      }\n    });\n\n    return this;\n  }\n\n  sync() {\n    this._syncMethod(\"triggerAttack\", 1);\n\n    this._syncMethod(\"triggerRelease\", 1);\n\n    return this;\n  }\n  /**\n   * Invoke the attack phase, then after the duration, invoke the release.\n   * @param  notes\tThe note to play and release, or an array of notes.\n   * @param  duration The time the note should be held\n   * @param  time     When to start the attack\n   * @param  velocity The velocity of the attack\n   */\n\n\n  triggerAttackRelease(notes, duration, time, velocity = 1) {\n    const computedTime = this.toSeconds(time);\n    this.triggerAttack(notes, computedTime, velocity);\n\n    if (isArray(duration)) {\n      assert(isArray(notes), \"notes must be an array when duration is array\");\n      notes.forEach((note, index) => {\n        const d = duration[Math.min(index, duration.length - 1)];\n        this.triggerRelease(note, computedTime + this.toSeconds(d));\n      });\n    } else {\n      this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n    }\n\n    return this;\n  }\n  /**\n   * Add a note to the sampler.\n   * @param  note      The buffer's pitch.\n   * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n   * @param  callback  The callback to invoke when the url is loaded.\n   */\n\n\n  add(note, url, callback) {\n    assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\n    if (isNote(note)) {\n      // convert the note name to MIDI\n      const mid = new FrequencyClass(this.context, note).toMidi();\n\n      this._buffers.add(mid, url, callback);\n    } else {\n      // otherwise if it's numbers assume it's midi\n      this._buffers.add(note, url, callback);\n    }\n\n    return this;\n  }\n  /**\n   * If the buffers are loaded or not\n   */\n\n\n  get loaded() {\n    return this._buffers.loaded;\n  }\n  /**\n   * Clean up\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._buffers.dispose();\n\n    this._activeSources.forEach(sources => {\n      sources.forEach(source => source.dispose());\n    });\n\n    this._activeSources.clear();\n\n    return this;\n  }\n\n}\n\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","import \"../core/clock/Transport\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * const chordEvent = new Tone.ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\n\nexport class ToneEvent extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n    this.name = \"ToneEvent\";\n    /**\n     * Tracks the scheduled events\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * A delay time from when the event is scheduled to start\n     */\n\n    this._startOffset = 0;\n    const options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n    this._loop = options.loop;\n    this.callback = options.callback;\n    this.value = options.value;\n    this._loopStart = this.toTicks(options.loopStart);\n    this._loopEnd = this.toTicks(options.loopEnd);\n    this._playbackRate = options.playbackRate;\n    this._probability = options.probability;\n    this._humanize = options.humanize;\n    this.mute = options.mute;\n    this._playbackRate = options.playbackRate;\n    this._state.increasing = true; // schedule the events for the first time\n\n    this._rescheduleEvents();\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      callback: noOp,\n      humanize: false,\n      loop: false,\n      loopEnd: \"1m\",\n      loopStart: 0,\n      mute: false,\n      playbackRate: 1,\n      probability: 1,\n      value: null\n    });\n  }\n  /**\n   * Reschedule all of the events along the timeline\n   * with the updated values.\n   * @param after Only reschedules events after the given time.\n   */\n\n\n  _rescheduleEvents(after = -1) {\n    // if no argument is given, schedules all of the events\n    this._state.forEachFrom(after, event => {\n      let duration;\n\n      if (event.state === \"started\") {\n        if (event.id !== -1) {\n          this.context.transport.clear(event.id);\n        }\n\n        const startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\n        if (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n          duration = Infinity;\n\n          if (isNumber(this._loop)) {\n            duration = this._loop * this._getLoopDuration();\n          }\n\n          const nextEvent = this._state.getAfter(startTick);\n\n          if (nextEvent !== null) {\n            duration = Math.min(duration, nextEvent.time - startTick);\n          }\n\n          if (duration !== Infinity) {\n            // schedule a stop since it's finite duration\n            this._state.setStateAtTime(\"stopped\", startTick + duration + 1, {\n              id: -1\n            });\n\n            duration = new TicksClass(this.context, duration);\n          }\n\n          const interval = new TicksClass(this.context, this._getLoopDuration());\n          event.id = this.context.transport.scheduleRepeat(this._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n        } else {\n          event.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n        }\n      }\n    });\n  }\n  /**\n   * Returns the playback state of the note, either \"started\" or \"stopped\".\n   */\n\n\n  get state() {\n    return this._state.getValueAtTime(this.context.transport.ticks);\n  }\n  /**\n   * The start from the scheduled start time.\n   */\n\n\n  get startOffset() {\n    return this._startOffset;\n  }\n\n  set startOffset(offset) {\n    this._startOffset = offset;\n  }\n  /**\n   * The probability of the notes being triggered.\n   */\n\n\n  get probability() {\n    return this._probability;\n  }\n\n  set probability(prob) {\n    this._probability = prob;\n  }\n  /**\n   * If set to true, will apply small random variation\n   * to the callback time. If the value is given as a time, it will randomize\n   * by that amount.\n   * @example\n   * const event = new Tone.ToneEvent();\n   * event.humanize = true;\n   */\n\n\n  get humanize() {\n    return this._humanize;\n  }\n\n  set humanize(variation) {\n    this._humanize = variation;\n  }\n  /**\n   * Start the note at the given time.\n   * @param  time  When the event should start.\n   */\n\n\n  start(time) {\n    const ticks = this.toTicks(time);\n\n    if (this._state.getValueAtTime(ticks) === \"stopped\") {\n      this._state.add({\n        id: -1,\n        state: \"started\",\n        time: ticks\n      });\n\n      this._rescheduleEvents(ticks);\n    }\n\n    return this;\n  }\n  /**\n   * Stop the Event at the given time.\n   * @param  time  When the event should stop.\n   */\n\n\n  stop(time) {\n    this.cancel(time);\n    const ticks = this.toTicks(time);\n\n    if (this._state.getValueAtTime(ticks) === \"started\") {\n      this._state.setStateAtTime(\"stopped\", ticks, {\n        id: -1\n      });\n\n      const previousEvent = this._state.getBefore(ticks);\n\n      let reschedulTime = ticks;\n\n      if (previousEvent !== null) {\n        reschedulTime = previousEvent.time;\n      }\n\n      this._rescheduleEvents(reschedulTime);\n    }\n\n    return this;\n  }\n  /**\n   * Cancel all scheduled events greater than or equal to the given time\n   * @param  time  The time after which events will be cancel.\n   */\n\n\n  cancel(time) {\n    time = defaultArg(time, -Infinity);\n    const ticks = this.toTicks(time);\n\n    this._state.forEachFrom(ticks, event => {\n      this.context.transport.clear(event.id);\n    });\n\n    this._state.cancel(ticks);\n\n    return this;\n  }\n  /**\n   * The callback function invoker. Also\n   * checks if the Event is done playing\n   * @param  time  The time of the event in seconds\n   */\n\n\n  _tick(time) {\n    const ticks = this.context.transport.getTicksAtTime(time);\n\n    if (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n      if (this.probability < 1 && Math.random() > this.probability) {\n        return;\n      }\n\n      if (this.humanize) {\n        let variation = 0.02;\n\n        if (!isBoolean(this.humanize)) {\n          variation = this.toSeconds(this.humanize);\n        }\n\n        time += (Math.random() * 2 - 1) * variation;\n      }\n\n      this.callback(time, this.value);\n    }\n  }\n  /**\n   * Get the duration of the loop.\n   */\n\n\n  _getLoopDuration() {\n    return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n  }\n  /**\n   * If the note should loop or not\n   * between ToneEvent.loopStart and\n   * ToneEvent.loopEnd. If set to true,\n   * the event will loop indefinitely,\n   * if set to a number greater than 1\n   * it will play a specific number of\n   * times, if set to false, 0 or 1, the\n   * part will only play once.\n   */\n\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(loop) {\n    this._loop = loop;\n\n    this._rescheduleEvents();\n  }\n  /**\n   * The playback rate of the note. Defaults to 1.\n   * @example\n   * const note = new Tone.ToneEvent();\n   * note.loop = true;\n   * // repeat the note twice as fast\n   * note.playbackRate = 2;\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n\n    this._rescheduleEvents();\n  }\n  /**\n   * The loopEnd point is the time the event will loop\n   * if ToneEvent.loop is true.\n   */\n\n\n  get loopEnd() {\n    return new TicksClass(this.context, this._loopEnd).toSeconds();\n  }\n\n  set loopEnd(loopEnd) {\n    this._loopEnd = this.toTicks(loopEnd);\n\n    if (this._loop) {\n      this._rescheduleEvents();\n    }\n  }\n  /**\n   * The time when the loop should start.\n   */\n\n\n  get loopStart() {\n    return new TicksClass(this.context, this._loopStart).toSeconds();\n  }\n\n  set loopStart(loopStart) {\n    this._loopStart = this.toTicks(loopStart);\n\n    if (this._loop) {\n      this._rescheduleEvents();\n    }\n  }\n  /**\n   * The current progress of the loop interval.\n   * Returns 0 if the event is not started yet or\n   * it is not set to loop.\n   */\n\n\n  get progress() {\n    if (this._loop) {\n      const ticks = this.context.transport.ticks;\n\n      const lastEvent = this._state.get(ticks);\n\n      if (lastEvent !== null && lastEvent.state === \"started\") {\n        const loopDuration = this._getLoopDuration();\n\n        const progress = (ticks - lastEvent.time) % loopDuration;\n        return progress / loopDuration;\n      } else {\n        return 0;\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n    this.cancel();\n\n    this._state.dispose();\n\n    return this;\n  }\n\n}","import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Loop extends ToneWithContext {\n  constructor() {\n    super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    this.name = \"Loop\";\n    const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    this._event = new ToneEvent({\n      context: this.context,\n      callback: this._tick.bind(this),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    this.callback = options.callback; // set the iterations\n\n    this.iterations = options.iterations;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneWithContext.getDefaults(), {\n      interval: \"4n\",\n      callback: noOp,\n      playbackRate: 1,\n      iterations: Infinity,\n      probability: 1,\n      mute: false,\n      humanize: false\n    });\n  }\n  /**\n   * Start the loop at the specified time along the Transport's timeline.\n   * @param  time  When to start the Loop.\n   */\n\n\n  start(time) {\n    this._event.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the loop at the given time.\n   * @param  time  When to stop the Loop.\n   */\n\n\n  stop(time) {\n    this._event.stop(time);\n\n    return this;\n  }\n  /**\n   * Cancel all scheduled events greater than or equal to the given time\n   * @param  time  The time after which events will be cancel.\n   */\n\n\n  cancel(time) {\n    this._event.cancel(time);\n\n    return this;\n  }\n  /**\n   * Internal function called when the notes should be called\n   * @param time  The time the event occurs\n   */\n\n\n  _tick(time) {\n    this.callback(time);\n  }\n  /**\n   * The state of the Loop, either started or stopped.\n   */\n\n\n  get state() {\n    return this._event.state;\n  }\n  /**\n   * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n   */\n\n\n  get progress() {\n    return this._event.progress;\n  }\n  /**\n   * The time between successive callbacks.\n   * @example\n   * const loop = new Tone.Loop();\n   * loop.interval = \"8n\"; // loop every 8n\n   */\n\n\n  get interval() {\n    return this._event.loopEnd;\n  }\n\n  set interval(interval) {\n    this._event.loopEnd = interval;\n  }\n  /**\n   * The playback rate of the loop. The normal playback rate is 1 (no change).\n   * A `playbackRate` of 2 would be twice as fast.\n   */\n\n\n  get playbackRate() {\n    return this._event.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._event.playbackRate = rate;\n  }\n  /**\n   * Random variation +/-0.01s to the scheduled time.\n   * Or give it a time value which it will randomize by.\n   */\n\n\n  get humanize() {\n    return this._event.humanize;\n  }\n\n  set humanize(variation) {\n    this._event.humanize = variation;\n  }\n  /**\n   * The probably of the callback being invoked.\n   */\n\n\n  get probability() {\n    return this._event.probability;\n  }\n\n  set probability(prob) {\n    this._event.probability = prob;\n  }\n  /**\n   * Muting the Loop means that no callbacks are invoked.\n   */\n\n\n  get mute() {\n    return this._event.mute;\n  }\n\n  set mute(mute) {\n    this._event.mute = mute;\n  }\n  /**\n   * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n   */\n\n\n  get iterations() {\n    if (this._event.loop === true) {\n      return Infinity;\n    } else {\n      return this._event.loop;\n    }\n  }\n\n  set iterations(iters) {\n    if (iters === Infinity) {\n      this._event.loop = true;\n    } else {\n      this._event.loop = iters;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._event.dispose();\n\n    return this;\n  }\n\n}","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * @category Event\n */\n\nexport class Part extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n    this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n\n    this._events = new Set();\n    const options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]); // make sure things are assigned in the right order\n\n    this._state.increasing = true; // add the events\n\n    options.events.forEach(event => {\n      if (isArray(event)) {\n        this.add(event[0], event[1]);\n      } else {\n        this.add(event);\n      }\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneEvent.getDefaults(), {\n      events: []\n    });\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset from the start of the part to begin playing at.\n   */\n\n\n  start(time, offset) {\n    const ticks = this.toTicks(time);\n\n    if (this._state.getValueAtTime(ticks) !== \"started\") {\n      offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\n      if (this._loop) {\n        offset = defaultArg(offset, this._loopStart);\n      } else {\n        offset = defaultArg(offset, 0);\n      }\n\n      const computedOffset = this.toTicks(offset);\n\n      this._state.add({\n        id: -1,\n        offset: computedOffset,\n        state: \"started\",\n        time: ticks\n      });\n\n      this._forEach(event => {\n        this._startNote(event, ticks, computedOffset);\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Start the event in the given event at the correct time given\n   * the ticks and offset and looping.\n   * @param  event\n   * @param  ticks\n   * @param  offset\n   */\n\n\n  _startNote(event, ticks, offset) {\n    ticks -= offset;\n\n    if (this._loop) {\n      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n        if (event.startOffset < offset) {\n          // start it on the next loop\n          ticks += this._getLoopDuration();\n        }\n\n        event.start(new TicksClass(this.context, ticks));\n      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n        event.loop = false;\n        event.start(new TicksClass(this.context, ticks));\n      }\n    } else if (event.startOffset >= offset) {\n      event.start(new TicksClass(this.context, ticks));\n    }\n  }\n\n  get startOffset() {\n    return this._startOffset;\n  }\n\n  set startOffset(offset) {\n    this._startOffset = offset;\n\n    this._forEach(event => {\n      event.startOffset += this._startOffset;\n    });\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n\n  stop(time) {\n    const ticks = this.toTicks(time);\n\n    this._state.cancel(ticks);\n\n    this._state.setStateAtTime(\"stopped\", ticks);\n\n    this._forEach(event => {\n      event.stop(time);\n    });\n\n    return this;\n  }\n  /**\n   * Get/Set an Event's value at the given time.\n   * If a value is passed in and no event exists at\n   * the given time, one will be created with that value.\n   * If two events are at the same time, the first one will\n   * be returned.\n   * @example\n   * const part = new Tone.Part();\n   * part.at(\"1m\"); // returns the part at the first measure\n   * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n   * // if an event didn't exist at that time, it will be created.\n   * @param time The time of the event to get or set.\n   * @param value If a value is passed in, the value of the event at the given time will be set to it.\n   */\n\n\n  at(time, value) {\n    const timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n    const tickTime = new TicksClass(this.context, 1).toSeconds();\n\n    const iterator = this._events.values();\n\n    let result = iterator.next();\n\n    while (!result.done) {\n      const event = result.value;\n\n      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n        if (isDefined(value)) {\n          event.value = value;\n        }\n\n        return event;\n      }\n\n      result = iterator.next();\n    } // if there was no event at that time, create one\n\n\n    if (isDefined(value)) {\n      this.add(time, value); // return the new event\n\n      return this.at(time);\n    } else {\n      return null;\n    }\n  }\n\n  add(time, value) {\n    // extract the parameters\n    if (time instanceof Object && Reflect.has(time, \"time\")) {\n      value = time;\n      time = value.time;\n    }\n\n    const ticks = this.toTicks(time);\n    let event;\n\n    if (value instanceof ToneEvent) {\n      event = value;\n      event.callback = this._tick.bind(this);\n    } else {\n      event = new ToneEvent({\n        callback: this._tick.bind(this),\n        context: this.context,\n        value\n      });\n    } // the start offset\n\n\n    event.startOffset = ticks; // initialize the values\n\n    event.set({\n      humanize: this.humanize,\n      loop: this.loop,\n      loopEnd: this.loopEnd,\n      loopStart: this.loopStart,\n      playbackRate: this.playbackRate,\n      probability: this.probability\n    });\n\n    this._events.add(event); // start the note if it should be played right now\n\n\n    this._restartEvent(event);\n\n    return this;\n  }\n  /**\n   * Restart the given event\n   */\n\n\n  _restartEvent(event) {\n    this._state.forEach(stateEvent => {\n      if (stateEvent.state === \"started\") {\n        this._startNote(event, stateEvent.time, stateEvent.offset);\n      } else {\n        // stop the note\n        event.stop(new TicksClass(this.context, stateEvent.time));\n      }\n    });\n  }\n\n  remove(time, value) {\n    // extract the parameters\n    if (isObject(time) && time.hasOwnProperty(\"time\")) {\n      value = time;\n      time = value.time;\n    }\n\n    time = this.toTicks(time);\n\n    this._events.forEach(event => {\n      if (event.startOffset === time) {\n        if (isUndef(value) || isDefined(value) && event.value === value) {\n          this._events.delete(event);\n\n          event.dispose();\n        }\n      }\n    });\n\n    return this;\n  }\n  /**\n   * Remove all of the notes from the group.\n   */\n\n\n  clear() {\n    this._forEach(event => event.dispose());\n\n    this._events.clear();\n\n    return this;\n  }\n  /**\n   * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n   * @param after The time after which to cancel the scheduled events.\n   */\n\n\n  cancel(after) {\n    this._forEach(event => event.cancel(after));\n\n    this._state.cancel(this.toTicks(after));\n\n    return this;\n  }\n  /**\n   * Iterate over all of the events\n   */\n\n\n  _forEach(callback) {\n    if (this._events) {\n      this._events.forEach(event => {\n        if (event instanceof Part) {\n          event._forEach(callback);\n        } else {\n          callback(event);\n        }\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Set the attribute of all of the events\n   * @param  attr  the attribute to set\n   * @param  value      The value to set it to\n   */\n\n\n  _setAll(attr, value) {\n    this._forEach(event => {\n      event[attr] = value;\n    });\n  }\n  /**\n   * Internal tick method\n   * @param  time  The time of the event in seconds\n   */\n\n\n  _tick(time, value) {\n    if (!this.mute) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * Determine if the event should be currently looping\n   * given the loop boundries of this Part.\n   * @param  event  The event to test\n   */\n\n\n  _testLoopBoundries(event) {\n    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n      event.cancel(0);\n    } else if (event.state === \"stopped\") {\n      // reschedule it if it's stopped\n      this._restartEvent(event);\n    }\n  }\n\n  get probability() {\n    return this._probability;\n  }\n\n  set probability(prob) {\n    this._probability = prob;\n\n    this._setAll(\"probability\", prob);\n  }\n\n  get humanize() {\n    return this._humanize;\n  }\n\n  set humanize(variation) {\n    this._humanize = variation;\n\n    this._setAll(\"humanize\", variation);\n  }\n  /**\n   * If the part should loop or not\n   * between Part.loopStart and\n   * Part.loopEnd. If set to true,\n   * the part will loop indefinitely,\n   * if set to a number greater than 1\n   * it will play a specific number of\n   * times, if set to false, 0 or 1, the\n   * part will only play once.\n   * @example\n   * const part = new Tone.Part();\n   * // loop the part 8 times\n   * part.loop = 8;\n   */\n\n\n  get loop() {\n    return this._loop;\n  }\n\n  set loop(loop) {\n    this._loop = loop;\n\n    this._forEach(event => {\n      event.loopStart = this.loopStart;\n      event.loopEnd = this.loopEnd;\n      event.loop = loop;\n\n      this._testLoopBoundries(event);\n    });\n  }\n  /**\n   * The loopEnd point determines when it will\n   * loop if Part.loop is true.\n   */\n\n\n  get loopEnd() {\n    return new TicksClass(this.context, this._loopEnd).toSeconds();\n  }\n\n  set loopEnd(loopEnd) {\n    this._loopEnd = this.toTicks(loopEnd);\n\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopEnd = loopEnd;\n\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The loopStart point determines when it will\n   * loop if Part.loop is true.\n   */\n\n\n  get loopStart() {\n    return new TicksClass(this.context, this._loopStart).toSeconds();\n  }\n\n  set loopStart(loopStart) {\n    this._loopStart = this.toTicks(loopStart);\n\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopStart = this.loopStart;\n\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The playback rate of the part\n   */\n\n\n  get playbackRate() {\n    return this._playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n\n    this._setAll(\"playbackRate\", rate);\n  }\n  /**\n   * The number of scheduled notes in the part.\n   */\n\n\n  get length() {\n    return this._events.size;\n  }\n\n  dispose() {\n    super.dispose();\n    this.clear();\n    return this;\n  }\n\n}","import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\n\nfunction* upPatternGen(values) {\n  let index = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index++;\n  }\n}\n/**\n * Start at the last value and go down to 0\n */\n\n\nfunction* downPatternGen(values) {\n  let index = values.length - 1;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    index--;\n  }\n}\n/**\n * Infinitely yield the generator\n */\n\n\nfunction* infiniteGen(values, gen) {\n  while (true) {\n    yield* gen(values);\n  }\n}\n/**\n * Make sure that the index is in the given range\n */\n\n\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\n\n\nfunction* alternatingGenerator(values, directionUp) {\n  let index = directionUp ? 0 : values.length - 1;\n\n  while (true) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n\n    if (directionUp) {\n      index++;\n\n      if (index >= values.length - 1) {\n        directionUp = false;\n      }\n    } else {\n      index--;\n\n      if (index <= 0) {\n        directionUp = true;\n      }\n    }\n  }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\n\n\nfunction* jumpUp(values) {\n  let index = 0;\n  let stepIndex = 0;\n\n  while (index < values.length) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? 2 : -1;\n  }\n}\n/**\n * Starting from the top move down 2, up 1\n */\n\n\nfunction* jumpDown(values) {\n  let index = values.length - 1;\n  let stepIndex = 0;\n\n  while (index >= 0) {\n    index = clampToArraySize(index, values);\n    yield values[index];\n    stepIndex++;\n    index += stepIndex % 2 ? -2 : 1;\n  }\n}\n/**\n * Choose a random index each time\n */\n\n\nfunction* randomGen(values) {\n  while (true) {\n    const randomIndex = Math.floor(Math.random() * values.length);\n    yield values[randomIndex];\n  }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\n\n\nfunction* randomOnce(values) {\n  // create an array of indices\n  const copy = [];\n\n  for (let i = 0; i < values.length; i++) {\n    copy.push(i);\n  }\n\n  while (copy.length > 0) {\n    // random choose an index, and then remove it so it's not chosen again\n    const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n    const index = clampToArraySize(randVal[0], values);\n    yield values[index];\n  }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\n\n\nfunction* randomWalk(values) {\n  // randomly choose a starting index in the values array\n  let index = Math.floor(Math.random() * values.length);\n\n  while (true) {\n    if (index === 0) {\n      index++; // at bottom of array, so force upward step\n    } else if (index === values.length - 1) {\n      index--; // at top of array, so force downward step\n    } else if (Math.random() < 0.5) {\n      // else choose random downward or upward step\n      index--;\n    } else {\n      index++;\n    }\n\n    yield values[index];\n  }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\n\n\nexport function* PatternGenerator(values, pattern = \"up\", index = 0) {\n  // safeguards\n  assert(values.length > 0, \"The array must have more than one value in it\");\n\n  switch (pattern) {\n    case \"up\":\n      yield* infiniteGen(values, upPatternGen);\n\n    case \"down\":\n      yield* infiniteGen(values, downPatternGen);\n\n    case \"upDown\":\n      yield* alternatingGenerator(values, true);\n\n    case \"downUp\":\n      yield* alternatingGenerator(values, false);\n\n    case \"alternateUp\":\n      yield* infiniteGen(values, jumpUp);\n\n    case \"alternateDown\":\n      yield* infiniteGen(values, jumpDown);\n\n    case \"random\":\n      yield* randomGen(values);\n\n    case \"randomOnce\":\n      yield* infiniteGen(values, randomOnce);\n\n    case \"randomWalk\":\n      yield* randomWalk(values);\n  }\n}","import { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\n\nexport class Pattern extends Loop {\n  constructor() {\n    super(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n    this.name = \"Pattern\";\n    const options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n    this.callback = options.callback;\n    this._values = options.values;\n    this._pattern = PatternGenerator(options.values, options.pattern);\n    this._type = options.pattern;\n  }\n\n  static getDefaults() {\n    return Object.assign(Loop.getDefaults(), {\n      pattern: \"up\",\n      values: [],\n      callback: noOp\n    });\n  }\n  /**\n   * Internal function called when the notes should be called\n   */\n\n\n  _tick(time) {\n    const value = this._pattern.next();\n\n    this._value = value.value;\n    this.callback(time, this._value);\n  }\n  /**\n   * The array of events.\n   */\n\n\n  get values() {\n    return this._values;\n  }\n\n  set values(val) {\n    this._values = val; // reset the pattern\n\n    this.pattern = this._type;\n  }\n  /**\n   * The current value of the pattern.\n   */\n\n\n  get value() {\n    return this._value;\n  }\n  /**\n   * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n   */\n\n\n  get pattern() {\n    return this._type;\n  }\n\n  set pattern(pattern) {\n    this._type = pattern;\n    this._pattern = PatternGenerator(this._values, this._type);\n  }\n\n}","import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport class Sequence extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n\n    this._part = new Part({\n      callback: this._seqCallback.bind(this),\n      context: this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n\n    this._events = [];\n    /**\n     * The proxied array\n     */\n\n    this._eventsArray = [];\n    const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    this._subdivision = this.toTicks(options.subdivision);\n    this.events = options.events; // set all of the values\n\n    this.loop = options.loop;\n    this.loopStart = options.loopStart;\n    this.loopEnd = options.loopEnd;\n    this.playbackRate = options.playbackRate;\n    this.probability = options.probability;\n    this.humanize = options.humanize;\n    this.mute = options.mute;\n    this.playbackRate = options.playbackRate;\n  }\n\n  static getDefaults() {\n    return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n      events: [],\n      loop: true,\n      loopEnd: 0,\n      loopStart: 0,\n      subdivision: \"8n\"\n    });\n  }\n  /**\n   * The internal callback for when an event is invoked\n   */\n\n\n  _seqCallback(time, value) {\n    if (value !== null) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * The sequence\n   */\n\n\n  get events() {\n    return this._events;\n  }\n\n  set events(s) {\n    this.clear();\n    this._eventsArray = s;\n    this._events = this._createSequence(this._eventsArray);\n\n    this._eventsUpdated();\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset index to start at\n   */\n\n\n  start(time, offset) {\n    this._part.start(time, offset ? this._indexTime(offset) : offset);\n\n    return this;\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n\n\n  stop(time) {\n    this._part.stop(time);\n\n    return this;\n  }\n  /**\n   * The subdivision of the sequence. This can only be\n   * set in the constructor. The subdivision is the\n   * interval between successive steps.\n   */\n\n\n  get subdivision() {\n    return new TicksClass(this.context, this._subdivision).toSeconds();\n  }\n  /**\n   * Create a sequence proxy which can be monitored to create subsequences\n   */\n\n\n  _createSequence(array) {\n    return new Proxy(array, {\n      get: (target, property) => {\n        // property is index in this case\n        return target[property];\n      },\n      set: (target, property, value) => {\n        if (isString(property) && isFinite(parseInt(property, 10))) {\n          if (isArray(value)) {\n            target[property] = this._createSequence(value);\n          } else {\n            target[property] = value;\n          }\n        } else {\n          target[property] = value;\n        }\n\n        this._eventsUpdated(); // return true to accept the changes\n\n\n        return true;\n      }\n    });\n  }\n  /**\n   * When the sequence has changed, all of the events need to be recreated\n   */\n\n\n  _eventsUpdated() {\n    this._part.clear();\n\n    this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd\n\n\n    this.loopEnd = this.loopEnd;\n  }\n  /**\n   * reschedule all of the events that need to be rescheduled\n   */\n\n\n  _rescheduleSequence(sequence, subdivision, startOffset) {\n    sequence.forEach((value, index) => {\n      const eventOffset = index * subdivision + startOffset;\n\n      if (isArray(value)) {\n        this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n      } else {\n        const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\n        this._part.add(startTime, value);\n      }\n    });\n  }\n  /**\n   * Get the time of the index given the Sequence's subdivision\n   * @param  index\n   * @return The time of that index\n   */\n\n\n  _indexTime(index) {\n    return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n  }\n  /**\n   * Clear all of the events\n   */\n\n\n  clear() {\n    this._part.clear();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._part.dispose();\n\n    return this;\n  } //-------------------------------------\n  // PROXY CALLS\n  //-------------------------------------\n\n\n  get loop() {\n    return this._part.loop;\n  }\n\n  set loop(l) {\n    this._part.loop = l;\n  }\n  /**\n   * The index at which the sequence should start looping\n   */\n\n\n  get loopStart() {\n    return this._loopStart;\n  }\n\n  set loopStart(index) {\n    this._loopStart = index;\n    this._part.loopStart = this._indexTime(index);\n  }\n  /**\n   * The index at which the sequence should end looping\n   */\n\n\n  get loopEnd() {\n    return this._loopEnd;\n  }\n\n  set loopEnd(index) {\n    this._loopEnd = index;\n\n    if (index === 0) {\n      this._part.loopEnd = this._indexTime(this._eventsArray.length);\n    } else {\n      this._part.loopEnd = this._indexTime(index);\n    }\n  }\n\n  get startOffset() {\n    return this._part.startOffset;\n  }\n\n  set startOffset(start) {\n    this._part.startOffset = start;\n  }\n\n  get playbackRate() {\n    return this._part.playbackRate;\n  }\n\n  set playbackRate(rate) {\n    this._part.playbackRate = rate;\n  }\n\n  get probability() {\n    return this._part.probability;\n  }\n\n  set probability(prob) {\n    this._part.probability = prob;\n  }\n\n  get progress() {\n    return this._part.progress;\n  }\n\n  get humanize() {\n    return this._part.humanize;\n  }\n\n  set humanize(variation) {\n    this._part.humanize = variation;\n  }\n  /**\n   * The number of scheduled events\n   */\n\n\n  get length() {\n    return this._part.length;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * const crossFade = new Tone.CrossFade().toDestination();\n * // connect two inputs Tone.to a/b\n * const inputA = new Tone.Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Tone.Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\n\nexport class CrossFade extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n    this.name = \"CrossFade\";\n    /**\n     * The crossfading is done by a StereoPannerNode\n     */\n\n    this._panner = this.context.createStereoPanner();\n    /**\n     * Split the output of the panner node into two values used to control the gains.\n     */\n\n    this._split = this.context.createChannelSplitter(2);\n    /**\n     * Convert the fade value into an audio range value so it can be connected\n     * to the panner.pan AudioParam\n     */\n\n    this._g2a = new GainToAudio({\n      context: this.context\n    });\n    /**\n     * The input which is at full level when fade = 0\n     */\n\n    this.a = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The input which is at full level when fade = 1\n     */\n\n    this.b = new Gain({\n      context: this.context,\n      gain: 0\n    });\n    /**\n     * The output is a mix between `a` and `b` at the ratio of `fade`\n     */\n\n    this.output = new Gain({\n      context: this.context\n    });\n    this._internalChannels = [this.a, this.b];\n    const options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n    this.fade = new Signal({\n      context: this.context,\n      units: \"normalRange\",\n      value: options.fade\n    });\n    readOnly(this, \"fade\");\n    this.context.getConstant(1).connect(this._panner);\n\n    this._panner.connect(this._split); // this is necessary for standardized-audio-context\n    // doesn't make any difference for the native AudioContext\n    // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\n\n    this._panner.channelCount = 1;\n    this._panner.channelCountMode = \"explicit\";\n    connect(this._split, this.a.gain, 0);\n    connect(this._split, this.b.gain, 1);\n    this.fade.chain(this._g2a, this._panner.pan);\n    this.a.connect(this.output);\n    this.b.connect(this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      fade: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.a.dispose();\n    this.b.dispose();\n    this.output.dispose();\n    this.fade.dispose();\n\n    this._g2a.dispose();\n\n    this._panner.disconnect();\n\n    this._split.disconnect();\n\n    return this;\n  }\n\n}","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\n\nexport class Effect extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"Effect\";\n    /**\n     * the drywet knob to control the amount of effect\n     */\n\n    this._dryWet = new CrossFade({\n      context: this.context\n    });\n    /**\n     * The wet control is how much of the effected\n     * will pass through to the output. 1 = 100% effected\n     * signal, 0 = 100% dry signal.\n     */\n\n    this.wet = this._dryWet.fade;\n    /**\n     * connect the effectSend to the input of hte effect\n     */\n\n    this.effectSend = new Gain({\n      context: this.context\n    });\n    /**\n     * connect the output of the effect to the effectReturn\n     */\n\n    this.effectReturn = new Gain({\n      context: this.context\n    });\n    /**\n     * The effect input node\n     */\n\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The effect output\n     */\n\n    this.output = this._dryWet; // connections\n\n    this.input.fan(this._dryWet.a, this.effectSend);\n    this.effectReturn.connect(this._dryWet.b);\n    this.wet.setValueAtTime(options.wet, 0);\n    this._internalChannels = [this.effectReturn, this.effectSend];\n    readOnly(this, \"wet\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      wet: 1\n    });\n  }\n  /**\n   * chains the effect in between the effectSend and effectReturn\n   */\n\n\n  connectEffect(effect) {\n    // add it to the internal channels\n    this._internalChannels.push(effect);\n\n    this.effectSend.chain(effect, this.effectReturn);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dryWet.dispose();\n\n    this.effectSend.dispose();\n    this.effectReturn.dispose();\n    this.wet.dispose();\n    return this;\n  }\n\n}","import { Effect } from \"../effect/Effect\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base class for LFO-based effects.\n */\n\nexport class LFOEffect extends Effect {\n  constructor(options) {\n    super(options);\n    this.name = \"LFOEffect\";\n    this._lfo = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      amplitude: options.depth\n    });\n    this.depth = this._lfo.amplitude;\n    this.frequency = this._lfo.frequency;\n    this.type = options.type;\n    readOnly(this, [\"frequency\", \"depth\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      frequency: 1,\n      type: \"sine\",\n      depth: 1\n    });\n  }\n  /**\n   * Start the effect.\n   */\n\n\n  start(time) {\n    this._lfo.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the lfo\n   */\n\n\n  stop(time) {\n    this._lfo.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the filter to the transport. See [[LFO.sync]]\n   */\n\n\n  sync() {\n    this._lfo.sync();\n\n    return this;\n  }\n  /**\n   * Unsync the filter from the transport.\n   */\n\n\n  unsync() {\n    this._lfo.unsync();\n\n    return this;\n  }\n  /**\n   * The type of the LFO's oscillator: See [[Oscillator.type]]\n   * @example\n   * const autoFilter = new Tone.AutoFilter().start().toDestination();\n   * const noise = new Tone.Noise().start().connect(autoFilter);\n   * autoFilter.type = \"square\";\n   */\n\n\n  get type() {\n    return this._lfo.type;\n  }\n\n  set type(type) {\n    this._lfo.type = type;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._lfo.dispose();\n\n    this.frequency.dispose();\n    this.depth.dispose();\n    return this;\n  }\n\n}","import { Filter } from \"../component/filter/Filter\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect } from \"./LFOEffect\";\n/**\n * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n * Setting the LFO rate and depth allows for control over the filter modulation rate\n * and depth.\n *\n * @example\n * // create an autofilter and start it's LFO\n * const autoFilter = new Tone.AutoFilter(\"4n\").toDestination().start();\n * // route an oscillator through the filter and start it\n * const oscillator = new Tone.Oscillator().connect(autoFilter).start();\n * @category Effect\n */\n\nexport class AutoFilter extends LFOEffect {\n  constructor() {\n    super(optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]));\n    this.name = \"AutoFilter\";\n    const options = optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]);\n    this.filter = new Filter(Object.assign(options.filter, {\n      context: this.context\n    })); // connections\n\n    this.connectEffect(this.filter);\n\n    this._lfo.connect(this.filter.frequency);\n\n    this.octaves = options.octaves;\n    this.baseFrequency = options.baseFrequency;\n  }\n\n  static getDefaults() {\n    return Object.assign(LFOEffect.getDefaults(), {\n      baseFrequency: 200,\n      octaves: 2.6,\n      filter: {\n        type: \"lowpass\",\n        rolloff: -12,\n        Q: 1\n      }\n    });\n  }\n  /**\n   * The minimum value of the filter's cutoff frequency.\n   */\n\n\n  get baseFrequency() {\n    return this._lfo.min;\n  }\n\n  set baseFrequency(freq) {\n    this._lfo.min = this.toFrequency(freq); // and set the max\n\n    this.octaves = this._octaves;\n  }\n  /**\n   * The maximum value of the filter's cutoff frequency.\n   */\n\n\n  get octaves() {\n    return this._octaves;\n  }\n\n  set octaves(oct) {\n    this._octaves = oct;\n    this._lfo.max = this._lfo.min * Math.pow(2, oct);\n  }\n\n  dispose() {\n    super.dispose();\n    this.filter.dispose();\n    return this;\n  }\n\n}","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @offline 0.5 2\n * @example\n * // move the input signal from right to left\n * const panner = new Tone.Panner(1).toDestination();\n * panner.pan.rampTo(-1, 0.5);\n * const osc = new Tone.Oscillator(100).connect(panner).start();\n * @category Component\n */\n\nexport class Panner extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n    this.name = \"Panner\";\n    /**\n     * the panner node\n     */\n\n    this._panner = this.context.createStereoPanner();\n    this.input = this._panner;\n    this.output = this._panner;\n    const options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n    this.pan = new Param({\n      context: this.context,\n      param: this._panner.pan,\n      value: options.pan,\n      minValue: -1,\n      maxValue: 1\n    }); // this is necessary for standardized-audio-context\n    // doesn't make any difference for the native AudioContext\n    // https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\n    this._panner.channelCount = options.channelCount;\n    this._panner.channelCountMode = \"explicit\"; // initial value\n\n    readOnly(this, \"pan\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      pan: 0,\n      channelCount: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.disconnect();\n\n    this.pan.dispose();\n    return this;\n  }\n\n}","import { Panner } from \"../component/channel/Panner\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect } from \"./LFOEffect\";\n/**\n * AutoPanner is a [[Panner]] with an [[LFO]] connected to the pan amount.\n * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n *\n * @example\n * // create an autopanner and start it\n * const autoPanner = new Tone.AutoPanner(\"4n\").toDestination().start();\n * // route an oscillator through the panner and start it\n * const oscillator = new Tone.Oscillator().connect(autoPanner).start();\n * @category Effect\n */\n\nexport class AutoPanner extends LFOEffect {\n  constructor() {\n    super(optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"AutoPanner\";\n    const options = optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]);\n    this._panner = new Panner({\n      context: this.context,\n      channelCount: options.channelCount\n    }); // connections\n\n    this.connectEffect(this._panner);\n\n    this._lfo.connect(this._panner.pan);\n\n    this._lfo.min = -1;\n    this._lfo.max = 1;\n  }\n\n  static getDefaults() {\n    return Object.assign(LFOEffect.getDefaults(), {\n      channelCount: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OnePoleFilter } from \"../filter/OnePoleFilter\";\nimport { Abs } from \"../../signal/Abs\";\n/**\n * Follower is a simple envelope follower.\n * It's implemented by applying a lowpass filter to the absolute value of the incoming signal.\n * ```\n *          +-----+    +---------------+\n * Input +--> Abs +----> OnePoleFilter +--> Output\n *          +-----+    +---------------+\n * ```\n * @category Component\n */\n\nexport class Follower extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]));\n    this.name = \"Follower\";\n    const options = optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]);\n    this._abs = this.input = new Abs({\n      context: this.context\n    });\n    this._lowpass = this.output = new OnePoleFilter({\n      context: this.context,\n      frequency: 1 / this.toSeconds(options.smoothing),\n      type: \"lowpass\"\n    });\n\n    this._abs.connect(this._lowpass);\n\n    this._smoothing = options.smoothing;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      smoothing: 0.05\n    });\n  }\n  /**\n   * The amount of time it takes a value change to arrive at the updated value.\n   */\n\n\n  get smoothing() {\n    return this._smoothing;\n  }\n\n  set smoothing(smoothing) {\n    this._smoothing = smoothing;\n    this._lowpass.frequency = 1 / this.toSeconds(this.smoothing);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._abs.dispose();\n\n    this._lowpass.dispose();\n\n    return this;\n  }\n\n}","import { Effect } from \"./Effect\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Follower } from \"../component/analysis/Follower\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Gain } from \"../core/context/Gain\";\nimport { dbToGain, gainToDb } from \"../core/type/Conversions\";\nimport { ScaleExp } from \"../signal/ScaleExp\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * AutoWah connects a [[Follower]] to a [[Filter]].\n * The frequency of the filter, follows the input amplitude curve.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n *\n * @example\n * const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\n * // initialize the synth and connect to autowah\n * const synth = new Tone.Synth().connect(autoWah);\n * // Q value influences the effect of the wah - default is 2\n * autoWah.Q.value = 6;\n * // more audible on higher notes\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Effect\n */\n\nexport class AutoWah extends Effect {\n  constructor() {\n    super(optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]));\n    this.name = \"AutoWah\";\n    const options = optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]);\n    this._follower = new Follower({\n      context: this.context,\n      smoothing: options.follower\n    });\n    this._sweepRange = new ScaleExp({\n      context: this.context,\n      min: 0,\n      max: 1,\n      exponent: 0.5\n    });\n    this._baseFrequency = this.toFrequency(options.baseFrequency);\n    this._octaves = options.octaves;\n    this._inputBoost = new Gain({\n      context: this.context\n    });\n    this._bandpass = new Filter({\n      context: this.context,\n      rolloff: -48,\n      frequency: 0,\n      Q: options.Q\n    });\n    this._peaking = new Filter({\n      context: this.context,\n      type: \"peaking\"\n    });\n    this._peaking.gain.value = options.gain;\n    this.gain = this._peaking.gain;\n    this.Q = this._bandpass.Q; // the control signal path\n\n    this.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);\n\n    this._sweepRange.connect(this._bandpass.frequency);\n\n    this._sweepRange.connect(this._peaking.frequency); // the filtered path\n\n\n    this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn); // set the initial value\n\n    this._setSweepRange();\n\n    this.sensitivity = options.sensitivity;\n    readOnly(this, [\"gain\", \"Q\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      baseFrequency: 100,\n      octaves: 6,\n      sensitivity: 0,\n      Q: 2,\n      gain: 2,\n      follower: 0.2\n    });\n  }\n  /**\n   * The number of octaves that the filter will sweep above the baseFrequency.\n   */\n\n\n  get octaves() {\n    return this._octaves;\n  }\n\n  set octaves(octaves) {\n    this._octaves = octaves;\n\n    this._setSweepRange();\n  }\n  /**\n   * The follower's smoothing time\n   */\n\n\n  get follower() {\n    return this._follower.smoothing;\n  }\n\n  set follower(follower) {\n    this._follower.smoothing = follower;\n  }\n  /**\n   * The base frequency from which the sweep will start from.\n   */\n\n\n  get baseFrequency() {\n    return this._baseFrequency;\n  }\n\n  set baseFrequency(baseFreq) {\n    this._baseFrequency = this.toFrequency(baseFreq);\n\n    this._setSweepRange();\n  }\n  /**\n   * The sensitivity to control how responsive to the input signal the filter is.\n   */\n\n\n  get sensitivity() {\n    return gainToDb(1 / this._inputBoost.gain.value);\n  }\n\n  set sensitivity(sensitivity) {\n    this._inputBoost.gain.value = 1 / dbToGain(sensitivity);\n  }\n  /**\n   * sets the sweep range of the scaler\n   */\n\n\n  _setSweepRange() {\n    this._sweepRange.min = this._baseFrequency;\n    this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._follower.dispose();\n\n    this._sweepRange.dispose();\n\n    this._bandpass.dispose();\n\n    this._peaking.dispose();\n\n    this._inputBoost.dispose();\n\n    return this;\n  }\n\n}","import { SingleIOProcessor } from \"../core/worklet/SingleIOProcessor.worklet\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope\";\nexport const workletName = \"bit-crusher\";\nexport default class BitCrusherWorklet extends SingleIOProcessor {\n  static get parameterDescriptors() {\n    return [{\n      name: \"bits\",\n      defaultValue: 12,\n      minValue: 1,\n      maxValue: 16\n    }];\n  }\n\n  generate(input, _channel, parameters) {\n    const step = Math.pow(0.5, parameters.bits - 1);\n    const val = step * Math.floor(input / step + 0.5);\n    return val;\n  }\n\n}\nregisterProcessor(workletName, BitCrusherWorklet);","import { ToneAudioWorklet } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect } from \"./Effect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\n\nexport class BitCrusher extends Effect {\n  constructor() {\n    super(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n    this.name = \"BitCrusher\";\n    const options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n    this._bitCrusherWorklet = new BitCrusherWorklet({\n      context: this.context,\n      bits: options.bits\n    }); // connect it up\n\n    this.connectEffect(this._bitCrusherWorklet);\n    this.bits = this._bitCrusherWorklet.bits;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      bits: 4\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._bitCrusherWorklet.dispose();\n\n    return this;\n  }\n\n}\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\n\nclass BitCrusherWorklet extends ToneAudioWorklet {\n  constructor() {\n    super(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n    this.name = \"BitCrusherWorklet\";\n    const options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    });\n    this.bits = new Param({\n      context: this.context,\n      value: options.bits,\n      units: \"positive\",\n      minValue: 1,\n      maxValue: 16,\n      param: this._dummyParam,\n      swappable: true\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioWorklet.getDefaults(), {\n      bits: 12\n    });\n  }\n\n  _audioWorkletName() {\n    return workletName;\n  }\n\n  onReady(node) {\n    connectSeries(this.input, node, this.output);\n    const bits = node.parameters.get(\"bits\");\n    this.bits.setParam(bits);\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.bits.dispose();\n    return this;\n  }\n\n}","import { Effect } from \"./Effect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n/**\n * Chebyshev is a waveshaper which is good\n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones,\n * and order = 1 is no change.\n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\n\nexport class Chebyshev extends Effect {\n  constructor() {\n    super(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n    this.name = \"Chebyshev\";\n    const options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n    this._shaper = new WaveShaper({\n      context: this.context,\n      length: 4096\n    });\n    this._order = options.order;\n    this.connectEffect(this._shaper);\n    this.order = options.order;\n    this.oversample = options.oversample;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      order: 1,\n      oversample: \"none\"\n    });\n  }\n  /**\n   * get the coefficient for that degree\n   * @param  x the x value\n   * @param  degree\n   * @param  memo memoize the computed value. this speeds up computation greatly.\n   */\n\n\n  _getCoefficient(x, degree, memo) {\n    if (memo.has(degree)) {\n      return memo.get(degree);\n    } else if (degree === 0) {\n      memo.set(degree, 0);\n    } else if (degree === 1) {\n      memo.set(degree, x);\n    } else {\n      memo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n    }\n\n    return memo.get(degree);\n  }\n  /**\n   * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming\n   * signal through a Tone.WaveShaper. The equations are in the form:\n   * ```\n   * order 2: 2x^2 + 1\n   * order 3: 4x^3 + 3x\n   * ```\n   * @min 1\n   * @max 100\n   */\n\n\n  get order() {\n    return this._order;\n  }\n\n  set order(order) {\n    this._order = order;\n\n    this._shaper.setMap(x => {\n      return this._getCoefficient(x, order, new Map());\n    });\n  }\n  /**\n   * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    this._shaper.oversample = oversampling;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Split splits an incoming signal into the number of given channels.\n *\n * @example\n * const split = new Tone.Split();\n * // stereoSignal.connect(split);\n * @category Component\n */\n\nexport class Split extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]));\n    this.name = \"Split\";\n    const options = optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]);\n    this._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);\n    this._internalChannels = [this._splitter];\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      channels: 2\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._splitter.disconnect();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * const merge = new Tone.Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Tone.Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\n\nexport class Merge extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n    this.name = \"Merge\";\n    const options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n    this._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      channels: 2\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._merger.disconnect();\n\n    return this;\n  }\n\n}","import { connect, connectSeries, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Split } from \"../component/channel/Split\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base class for Stereo effects.\n */\n\nexport class StereoEffect extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"StereoEffect\";\n    this.input = new Gain({\n      context: this.context\n    }); // force mono sources to be stereo\n\n    this.input.channelCount = 2;\n    this.input.channelCountMode = \"explicit\";\n    this._dryWet = this.output = new CrossFade({\n      context: this.context,\n      fade: options.wet\n    });\n    this.wet = this._dryWet.fade;\n    this._split = new Split({\n      context: this.context,\n      channels: 2\n    });\n    this._merge = new Merge({\n      context: this.context,\n      channels: 2\n    }); // connections\n\n    this.input.connect(this._split); // dry wet connections\n\n    this.input.connect(this._dryWet.a);\n\n    this._merge.connect(this._dryWet.b);\n\n    readOnly(this, [\"wet\"]);\n  }\n  /**\n   * Connect the left part of the effect\n   */\n\n\n  connectEffectLeft(...nodes) {\n    this._split.connect(nodes[0], 0, 0);\n\n    connectSeries(...nodes);\n    connect(nodes[nodes.length - 1], this._merge, 0, 0);\n  }\n  /**\n   * Connect the right part of the effect\n   */\n\n\n  connectEffectRight(...nodes) {\n    this._split.connect(nodes[0], 1, 0);\n\n    connectSeries(...nodes);\n    connect(nodes[nodes.length - 1], this._merge, 0, 1);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      wet: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._dryWet.dispose();\n\n    this._split.dispose();\n\n    this._merge.dispose();\n\n    return this;\n  }\n\n}","import { StereoEffect } from \"./StereoEffect\";\nimport { Signal } from \"../signal/Signal\";\nimport { Gain } from \"../core/context/Gain\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Split } from \"../component/channel/Split\";\nimport { Merge } from \"../component/channel/Merge\";\n/**\n * Just like a stereo feedback effect, but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +---+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit\n * +-->                          +----->        +---->                          +---+\n * |                                                                                |\n * +--------------------------------+ feedbackR <-----------------------------------+\n * ```\n */\n\nexport class StereoFeedbackEffect extends StereoEffect {\n  constructor(options) {\n    super(options);\n    this.feedback = new Signal({\n      context: this.context,\n      value: options.feedback,\n      units: \"normalRange\"\n    });\n    this._feedbackL = new Gain({\n      context: this.context\n    });\n    this._feedbackR = new Gain({\n      context: this.context\n    });\n    this._feedbackSplit = new Split({\n      context: this.context,\n      channels: 2\n    });\n    this._feedbackMerge = new Merge({\n      context: this.context,\n      channels: 2\n    });\n\n    this._merge.connect(this._feedbackSplit);\n\n    this._feedbackMerge.connect(this._split); // the left output connected to the left input\n\n\n    this._feedbackSplit.connect(this._feedbackL, 0, 0);\n\n    this._feedbackL.connect(this._feedbackMerge, 0, 0); // the right output connected to the right input\n\n\n    this._feedbackSplit.connect(this._feedbackR, 1, 0);\n\n    this._feedbackR.connect(this._feedbackMerge, 0, 1); // the feedback control\n\n\n    this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n    readOnly(this, [\"feedback\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      feedback: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.feedback.dispose();\n\n    this._feedbackL.dispose();\n\n    this._feedbackR.dispose();\n\n    this._feedbackSplit.dispose();\n\n    this._feedbackMerge.dispose();\n\n    return this;\n  }\n\n}","import { StereoFeedbackEffect } from \"../effect/StereoFeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Chorus is a stereo chorus effect composed of a left and right delay with an [[LFO]] applied to the delayTime of each channel.\n * When [[feedback]] is set to a value larger than 0, you also get Flanger-type effects.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * const chorus = new Tone.Chorus(4, 2.5, 0.5);\n * const synth = new Tone.PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n *\n * @category Effect\n */\n\nexport class Chorus extends StereoFeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]));\n    this.name = \"Chorus\";\n    const options = optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]);\n    this._depth = options.depth;\n    this._delayTime = options.delayTime / 1000;\n    this._lfoL = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1\n    });\n    this._lfoR = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1,\n      phase: 180\n    });\n    this._delayNodeL = new Delay({\n      context: this.context\n    });\n    this._delayNodeR = new Delay({\n      context: this.context\n    });\n    this.frequency = this._lfoL.frequency;\n    readOnly(this, [\"frequency\"]); // have one LFO frequency control the other\n\n    this._lfoL.frequency.connect(this._lfoR.frequency); // connections\n\n\n    this.connectEffectLeft(this._delayNodeL);\n    this.connectEffectRight(this._delayNodeR); // lfo setup\n\n    this._lfoL.connect(this._delayNodeL.delayTime);\n\n    this._lfoR.connect(this._delayNodeR.delayTime); // set the initial values\n\n\n    this.depth = this._depth;\n    this.type = options.type;\n    this.spread = options.spread;\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoFeedbackEffect.getDefaults(), {\n      frequency: 1.5,\n      delayTime: 3.5,\n      depth: 0.7,\n      type: \"sine\",\n      spread: 180,\n      feedback: 0,\n      wet: 0.5\n    });\n  }\n  /**\n   * The depth of the effect. A depth of 1 makes the delayTime\n   * modulate between 0 and 2*delayTime (centered around the delayTime).\n   */\n\n\n  get depth() {\n    return this._depth;\n  }\n\n  set depth(depth) {\n    this._depth = depth;\n    const deviation = this._delayTime * depth;\n    this._lfoL.min = Math.max(this._delayTime - deviation, 0);\n    this._lfoL.max = this._delayTime + deviation;\n    this._lfoR.min = Math.max(this._delayTime - deviation, 0);\n    this._lfoR.max = this._delayTime + deviation;\n  }\n  /**\n   * The delayTime in milliseconds of the chorus. A larger delayTime\n   * will give a more pronounced effect. Nominal range a delayTime\n   * is between 2 and 20ms.\n   */\n\n\n  get delayTime() {\n    return this._delayTime * 1000;\n  }\n\n  set delayTime(delayTime) {\n    this._delayTime = delayTime / 1000;\n    this.depth = this._depth;\n  }\n  /**\n   * The oscillator type of the LFO.\n   */\n\n\n  get type() {\n    return this._lfoL.type;\n  }\n\n  set type(type) {\n    this._lfoL.type = type;\n    this._lfoR.type = type;\n  }\n  /**\n   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n   * When set to 180, LFO's will be panned hard left and right respectively.\n   */\n\n\n  get spread() {\n    return this._lfoR.phase - this._lfoL.phase;\n  }\n\n  set spread(spread) {\n    this._lfoL.phase = 90 - spread / 2;\n    this._lfoR.phase = spread / 2 + 90;\n  }\n  /**\n   * Start the effect.\n   */\n\n\n  start(time) {\n    this._lfoL.start(time);\n\n    this._lfoR.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the lfo\n   */\n\n\n  stop(time) {\n    this._lfoL.stop(time);\n\n    this._lfoR.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the filter to the transport. See [[LFO.sync]]\n   */\n\n\n  sync() {\n    this._lfoL.sync();\n\n    this._lfoR.sync();\n\n    return this;\n  }\n  /**\n   * Unsync the filter from the transport.\n   */\n\n\n  unsync() {\n    this._lfoL.unsync();\n\n    this._lfoR.unsync();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._lfoL.dispose();\n\n    this._lfoR.dispose();\n\n    this._delayNodeL.dispose();\n\n    this._delayNodeR.dispose();\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect } from \"./Effect\";\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\n\nexport class Distortion extends Effect {\n  constructor() {\n    super(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n    this.name = \"Distortion\";\n    const options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n    this._shaper = new WaveShaper({\n      context: this.context,\n      length: 4096\n    });\n    this._distortion = options.distortion;\n    this.connectEffect(this._shaper);\n    this.distortion = options.distortion;\n    this.oversample = options.oversample;\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      distortion: 0.4,\n      oversample: \"none\"\n    });\n  }\n  /**\n   * The amount of distortion. Nominal range is between 0 and 1.\n   */\n\n\n  get distortion() {\n    return this._distortion;\n  }\n\n  set distortion(amount) {\n    this._distortion = amount;\n    const k = amount * 100;\n    const deg = Math.PI / 180;\n\n    this._shaper.setMap(x => {\n      if (Math.abs(x) < 0.001) {\n        // should output 0 when input is 0\n        return 0;\n      } else {\n        return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n      }\n    });\n  }\n  /**\n   * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n   */\n\n\n  get oversample() {\n    return this._shaper.oversample;\n  }\n\n  set oversample(oversampling) {\n    this._shaper.oversample = oversampling;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._shaper.dispose();\n\n    return this;\n  }\n\n}","import { Gain } from \"../core/context/Gain\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect } from \"./Effect\";\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\n\nexport class FeedbackEffect extends Effect {\n  constructor(options) {\n    super(options);\n    this.name = \"FeedbackEffect\";\n    this._feedbackGain = new Gain({\n      context: this.context,\n      gain: options.feedback,\n      units: \"normalRange\"\n    });\n    this.feedback = this._feedbackGain.gain;\n    readOnly(this, \"feedback\"); // the feedback loop\n\n    this.effectReturn.chain(this._feedbackGain, this.effectSend);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      feedback: 0.125\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._feedbackGain.dispose();\n\n    this.feedback.dispose();\n    return this;\n  }\n\n}","import { Delay } from \"../core/context/Delay\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect } from \"./FeedbackEffect\";\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\n\nexport class FeedbackDelay extends FeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n    this.name = \"FeedbackDelay\";\n    const options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n    this._delayNode = new Delay({\n      context: this.context,\n      delayTime: options.delayTime,\n      maxDelay: options.maxDelay\n    });\n    this.delayTime = this._delayNode.delayTime; // connect it up\n\n    this.connectEffect(this._delayNode);\n    readOnly(this, \"delayTime\");\n  }\n\n  static getDefaults() {\n    return Object.assign(FeedbackEffect.getDefaults(), {\n      delayTime: 0.25,\n      maxDelay: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._delayNode.dispose();\n\n    this.delayTime.dispose();\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90°.\n * Here the `offset90` phase is offset by +90° in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\n\nexport class PhaseShiftAllpass extends ToneAudioNode {\n  constructor(options) {\n    super(options);\n    this.name = \"PhaseShiftAllpass\";\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * The phase shifted output\n     */\n\n    this.output = new Gain({\n      context: this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n\n    this.offset90 = new Gain({\n      context: this.context\n    });\n    const allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n    const allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n    this._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n    this._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n    this._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]); // connect Allpass filter banks\n\n    connectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n    connectSeries(this.input, ...this._bank1, this.offset90);\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n\n\n  _createAllPassFilterBank(bankValues) {\n    const nodes = bankValues.map(value => {\n      const coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n      return this.context.createIIRFilter(coefficients[0], coefficients[1]);\n    });\n    return nodes;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n    this.output.dispose();\n    this.offset90.dispose();\n\n    this._bank0.forEach(f => f.disconnect());\n\n    this._bank1.forEach(f => f.disconnect());\n\n    this._oneSampleDelay.disconnect();\n\n    return this;\n  }\n\n}","import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\n\nexport class FrequencyShifter extends Effect {\n  constructor() {\n    super(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n    this.name = \"FrequencyShifter\";\n    const options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency,\n      minValue: -this.context.sampleRate / 2,\n      maxValue: this.context.sampleRate / 2\n    });\n    this._sine = new ToneOscillatorNode({\n      context: this.context,\n      type: \"sine\"\n    });\n    this._cosine = new Oscillator({\n      context: this.context,\n      phase: -90,\n      type: \"sine\"\n    });\n    this._sineMultiply = new Multiply({\n      context: this.context\n    });\n    this._cosineMultiply = new Multiply({\n      context: this.context\n    });\n    this._negate = new Negate({\n      context: this.context\n    });\n    this._add = new Add({\n      context: this.context\n    });\n    this._phaseShifter = new PhaseShiftAllpass({\n      context: this.context\n    });\n    this.effectSend.connect(this._phaseShifter); // connect the carrier frequency signal to the two oscillators\n\n    this.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n    this._phaseShifter.offset90.connect(this._cosineMultiply);\n\n    this._cosine.connect(this._cosineMultiply.factor);\n\n    this._phaseShifter.connect(this._sineMultiply);\n\n    this._sine.connect(this._sineMultiply.factor);\n\n    this._sineMultiply.connect(this._negate);\n\n    this._cosineMultiply.connect(this._add);\n\n    this._negate.connect(this._add.addend);\n\n    this._add.connect(this.effectReturn); // start the oscillators at the same time\n\n\n    const now = this.immediate();\n\n    this._sine.start(now);\n\n    this._cosine.start(now);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      frequency: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n\n    this._add.dispose();\n\n    this._cosine.dispose();\n\n    this._cosineMultiply.dispose();\n\n    this._negate.dispose();\n\n    this._phaseShifter.dispose();\n\n    this._sine.dispose();\n\n    this._sineMultiply.dispose();\n\n    return this;\n  }\n\n}","import { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\n/**\n * An array of comb filter delay values from Freeverb implementation\n */\n\nconst combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];\n/**\n * An array of allpass filter frequency values from Freeverb implementation\n */\n\nconst allpassFilterFrequencies = [225, 556, 441, 341];\n/**\n * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).\n * Freeverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms\n * @example\n * const freeverb = new Tone.Freeverb().toDestination();\n * freeverb.dampening = 1000;\n * // routing synth through the reverb\n * const synth = new Tone.NoiseSynth().connect(freeverb);\n * synth.triggerAttackRelease(0.05);\n * @category Effect\n */\n\nexport class Freeverb extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]));\n    this.name = \"Freeverb\";\n    /**\n     * the comb filters\n     */\n\n    this._combFilters = [];\n    /**\n     * the allpass filters on the left\n     */\n\n    this._allpassFiltersL = [];\n    /**\n     * the allpass filters on the right\n     */\n\n    this._allpassFiltersR = [];\n    const options = optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]);\n    this.roomSize = new Signal({\n      context: this.context,\n      value: options.roomSize,\n      units: \"normalRange\"\n    }); // make the allpass filters on the right\n\n    this._allpassFiltersL = allpassFilterFrequencies.map(freq => {\n      const allpassL = this.context.createBiquadFilter();\n      allpassL.type = \"allpass\";\n      allpassL.frequency.value = freq;\n      return allpassL;\n    }); // make the allpass filters on the left\n\n    this._allpassFiltersR = allpassFilterFrequencies.map(freq => {\n      const allpassR = this.context.createBiquadFilter();\n      allpassR.type = \"allpass\";\n      allpassR.frequency.value = freq;\n      return allpassR;\n    }); // make the comb filters\n\n    this._combFilters = combFilterTunings.map((delayTime, index) => {\n      const lfpf = new LowpassCombFilter({\n        context: this.context,\n        dampening: options.dampening,\n        delayTime\n      });\n\n      if (index < combFilterTunings.length / 2) {\n        this.connectEffectLeft(lfpf, ...this._allpassFiltersL);\n      } else {\n        this.connectEffectRight(lfpf, ...this._allpassFiltersR);\n      }\n\n      this.roomSize.connect(lfpf.resonance);\n      return lfpf;\n    });\n    readOnly(this, [\"roomSize\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      roomSize: 0.7,\n      dampening: 3000\n    });\n  }\n  /**\n   * The amount of dampening of the reverberant signal.\n   */\n\n\n  get dampening() {\n    return this._combFilters[0].dampening;\n  }\n\n  set dampening(d) {\n    this._combFilters.forEach(c => c.dampening = d);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._allpassFiltersL.forEach(al => al.disconnect());\n\n    this._allpassFiltersR.forEach(ar => ar.disconnect());\n\n    this._combFilters.forEach(cf => cf.dispose());\n\n    this.roomSize.dispose();\n    return this;\n  }\n\n}","import { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * an array of the comb filter delay time values\n */\n\nconst combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];\n/**\n * the resonances of each of the comb filters\n */\n\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n/**\n * the allpass filter frequencies\n */\n\nconst allpassFilterFreqs = [347, 113, 37];\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four [[FeedbackCombFilter]].\n * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms\n *\n * @example\n * const reverb = new Tone.JCReverb(0.4).toDestination();\n * const delay = new Tone.FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new Tone.DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n *\n * @category Effect\n */\n\nexport class JCReverb extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]));\n    this.name = \"JCReverb\";\n    /**\n     * a series of allpass filters\n     */\n\n    this._allpassFilters = [];\n    /**\n     * parallel feedback comb filters\n     */\n\n    this._feedbackCombFilters = [];\n    const options = optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]);\n    this.roomSize = new Signal({\n      context: this.context,\n      value: options.roomSize,\n      units: \"normalRange\"\n    });\n    this._scaleRoomSize = new Scale({\n      context: this.context,\n      min: -0.733,\n      max: 0.197\n    }); // make the allpass filters\n\n    this._allpassFilters = allpassFilterFreqs.map(freq => {\n      const allpass = this.context.createBiquadFilter();\n      allpass.type = \"allpass\";\n      allpass.frequency.value = freq;\n      return allpass;\n    }); // and the comb filters\n\n    this._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {\n      const fbcf = new FeedbackCombFilter({\n        context: this.context,\n        delayTime\n      });\n\n      this._scaleRoomSize.connect(fbcf.resonance);\n\n      fbcf.resonance.value = combFilterResonances[index];\n\n      if (index < combFilterDelayTimes.length / 2) {\n        this.connectEffectLeft(...this._allpassFilters, fbcf);\n      } else {\n        this.connectEffectRight(...this._allpassFilters, fbcf);\n      }\n\n      return fbcf;\n    }); // chain the allpass filters together\n\n    this.roomSize.connect(this._scaleRoomSize);\n    readOnly(this, [\"roomSize\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      roomSize: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._allpassFilters.forEach(apf => apf.disconnect());\n\n    this._feedbackCombFilters.forEach(fbcf => fbcf.dispose());\n\n    this.roomSize.dispose();\n\n    this._scaleRoomSize.dispose();\n\n    return this;\n  }\n\n}","import { StereoFeedbackEffect } from \"./StereoFeedbackEffect\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Just like a [[StereoFeedbackEffect]], but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +-----+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |\n * +-->                          +----->        +---->                          +---+ |\n * |                                                                                  |\n * +--------------------------------+ feedbackR <-------------------------------------+\n * ```\n */\n\nexport class StereoXFeedbackEffect extends StereoFeedbackEffect {\n  constructor(options) {\n    super(options); // the left output connected to the right input\n\n    this._feedbackL.disconnect();\n\n    this._feedbackL.connect(this._feedbackMerge, 0, 1); // the left output connected to the right input\n\n\n    this._feedbackR.disconnect();\n\n    this._feedbackR.connect(this._feedbackMerge, 0, 0);\n\n    readOnly(this, [\"feedback\"]);\n  }\n\n}","import { StereoXFeedbackEffect } from \"./StereoXFeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\n\nexport class PingPongDelay extends StereoXFeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n    this.name = \"PingPongDelay\";\n    const options = optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n    this._leftDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this._rightDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this._rightPreDelay = new Delay({\n      context: this.context,\n      maxDelay: options.maxDelay\n    });\n    this.delayTime = new Signal({\n      context: this.context,\n      units: \"time\",\n      value: options.delayTime\n    }); // connect it up\n\n    this.connectEffectLeft(this._leftDelay);\n    this.connectEffectRight(this._rightPreDelay, this._rightDelay);\n    this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime); // rearranged the feedback to be after the rightPreDelay\n\n    this._feedbackL.disconnect();\n\n    this._feedbackL.connect(this._rightDelay);\n\n    readOnly(this, [\"delayTime\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoXFeedbackEffect.getDefaults(), {\n      delayTime: 0.25,\n      maxDelay: 1\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._leftDelay.dispose();\n\n    this._rightDelay.dispose();\n\n    this._rightPreDelay.dispose();\n\n    this.delayTime.dispose();\n    return this;\n  }\n\n}","import { FeedbackEffect } from \"./FeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\n\nexport class PitchShift extends FeedbackEffect {\n  constructor() {\n    super(optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]));\n    this.name = \"PitchShift\";\n    const options = optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]);\n    this._frequency = new Signal({\n      context: this.context\n    });\n    this._delayA = new Delay({\n      maxDelay: 1,\n      context: this.context\n    });\n    this._lfoA = new LFO({\n      context: this.context,\n      min: 0,\n      max: 0.1,\n      type: \"sawtooth\"\n    }).connect(this._delayA.delayTime);\n    this._delayB = new Delay({\n      maxDelay: 1,\n      context: this.context\n    });\n    this._lfoB = new LFO({\n      context: this.context,\n      min: 0,\n      max: 0.1,\n      type: \"sawtooth\",\n      phase: 180\n    }).connect(this._delayB.delayTime);\n    this._crossFade = new CrossFade({\n      context: this.context\n    });\n    this._crossFadeLFO = new LFO({\n      context: this.context,\n      min: 0,\n      max: 1,\n      type: \"triangle\",\n      phase: 90\n    }).connect(this._crossFade.fade);\n    this._feedbackDelay = new Delay({\n      delayTime: options.delayTime,\n      context: this.context\n    });\n    this.delayTime = this._feedbackDelay.delayTime;\n    readOnly(this, \"delayTime\");\n    this._pitch = options.pitch;\n    this._windowSize = options.windowSize; // connect the two delay lines up\n\n    this._delayA.connect(this._crossFade.a);\n\n    this._delayB.connect(this._crossFade.b); // connect the frequency\n\n\n    this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency); // route the input\n\n\n    this.effectSend.fan(this._delayA, this._delayB);\n\n    this._crossFade.chain(this._feedbackDelay, this.effectReturn); // start the LFOs at the same time\n\n\n    const now = this.now();\n\n    this._lfoA.start(now);\n\n    this._lfoB.start(now);\n\n    this._crossFadeLFO.start(now); // set the initial value\n\n\n    this.windowSize = this._windowSize;\n  }\n\n  static getDefaults() {\n    return Object.assign(FeedbackEffect.getDefaults(), {\n      pitch: 0,\n      windowSize: 0.1,\n      delayTime: 0,\n      feedback: 0\n    });\n  }\n  /**\n   * Repitch the incoming signal by some interval (measured in semi-tones).\n   * @example\n   * const pitchShift = new Tone.PitchShift().toDestination();\n   * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();\n   * pitchShift.pitch = -12; // down one octave\n   * pitchShift.pitch = 7; // up a fifth\n   */\n\n\n  get pitch() {\n    return this._pitch;\n  }\n\n  set pitch(interval) {\n    this._pitch = interval;\n    let factor = 0;\n\n    if (interval < 0) {\n      this._lfoA.min = 0;\n      this._lfoA.max = this._windowSize;\n      this._lfoB.min = 0;\n      this._lfoB.max = this._windowSize;\n      factor = intervalToFrequencyRatio(interval - 1) + 1;\n    } else {\n      this._lfoA.min = this._windowSize;\n      this._lfoA.max = 0;\n      this._lfoB.min = this._windowSize;\n      this._lfoB.max = 0;\n      factor = intervalToFrequencyRatio(interval) - 1;\n    }\n\n    this._frequency.value = factor * (1.2 / this._windowSize);\n  }\n  /**\n   * The window size corresponds roughly to the sample length in a looping sampler.\n   * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n   * signal, but larger values will result in smoother pitch shifting for larger intervals.\n   * A nominal range of 0.03 to 0.1 is recommended.\n   */\n\n\n  get windowSize() {\n    return this._windowSize;\n  }\n\n  set windowSize(size) {\n    this._windowSize = this.toSeconds(size);\n    this.pitch = this._pitch;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._frequency.dispose();\n\n    this._delayA.dispose();\n\n    this._delayB.dispose();\n\n    this._lfoA.dispose();\n\n    this._lfoB.dispose();\n\n    this._crossFade.dispose();\n\n    this._crossFadeLFO.dispose();\n\n    this._feedbackDelay.dispose();\n\n    return this;\n  }\n\n}","import { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\n\nexport class Phaser extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n    this.name = \"Phaser\";\n    const options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n    this._lfoL = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1\n    });\n    this._lfoR = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1,\n      phase: 180\n    });\n    this._baseFrequency = this.toFrequency(options.baseFrequency);\n    this._octaves = options.octaves;\n    this.Q = new Signal({\n      context: this.context,\n      value: options.Q,\n      units: \"positive\"\n    });\n    this._filtersL = this._makeFilters(options.stages, this._lfoL);\n    this._filtersR = this._makeFilters(options.stages, this._lfoR);\n    this.frequency = this._lfoL.frequency;\n    this.frequency.value = options.frequency; // connect them up\n\n    this.connectEffectLeft(...this._filtersL);\n    this.connectEffectRight(...this._filtersR); // control the frequency with one LFO\n\n    this._lfoL.frequency.connect(this._lfoR.frequency); // set the options\n\n\n    this.baseFrequency = options.baseFrequency;\n    this.octaves = options.octaves; // start the lfo\n\n    this._lfoL.start();\n\n    this._lfoR.start();\n\n    readOnly(this, [\"frequency\", \"Q\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      frequency: 0.5,\n      octaves: 3,\n      stages: 10,\n      Q: 10,\n      baseFrequency: 350\n    });\n  }\n\n  _makeFilters(stages, connectToFreq) {\n    const filters = []; // make all the filters\n\n    for (let i = 0; i < stages; i++) {\n      const filter = this.context.createBiquadFilter();\n      filter.type = \"allpass\";\n      this.Q.connect(filter.Q);\n      connectToFreq.connect(filter.frequency);\n      filters.push(filter);\n    }\n\n    return filters;\n  }\n  /**\n   * The number of octaves the phase goes above the baseFrequency\n   */\n\n\n  get octaves() {\n    return this._octaves;\n  }\n\n  set octaves(octaves) {\n    this._octaves = octaves;\n    const max = this._baseFrequency * Math.pow(2, octaves);\n    this._lfoL.max = max;\n    this._lfoR.max = max;\n  }\n  /**\n   * The the base frequency of the filters.\n   */\n\n\n  get baseFrequency() {\n    return this._baseFrequency;\n  }\n\n  set baseFrequency(freq) {\n    this._baseFrequency = this.toFrequency(freq);\n    this._lfoL.min = this._baseFrequency;\n    this._lfoR.min = this._baseFrequency;\n    this.octaves = this._octaves;\n  }\n\n  dispose() {\n    super.dispose();\n    this.Q.dispose();\n\n    this._lfoL.dispose();\n\n    this._lfoR.dispose();\n\n    this._filtersL.forEach(f => f.disconnect());\n\n    this._filtersR.forEach(f => f.disconnect());\n\n    this.frequency.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport class Reverb extends Effect {\n  constructor() {\n    super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    this._convolver = this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    this.ready = Promise.resolve();\n    const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    this._decay = options.decay;\n    this._preDelay = options.preDelay;\n    this.generate();\n    this.connectEffect(this._convolver);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      decay: 1.5,\n      preDelay: 0.01\n    });\n  }\n  /**\n   * The duration of the reverb.\n   */\n\n\n  get decay() {\n    return this._decay;\n  }\n\n  set decay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0.001);\n    this._decay = time;\n    this.generate();\n  }\n  /**\n   * The amount of time before the reverb is fully ramped in.\n   */\n\n\n  get preDelay() {\n    return this._preDelay;\n  }\n\n  set preDelay(time) {\n    time = this.toSeconds(time);\n    assertRange(time, 0);\n    this._preDelay = time;\n    this.generate();\n  }\n  /**\n   * Generate the Impulse Response. Returns a promise while the IR is being generated.\n   * @return Promise which returns this object.\n   */\n\n\n  generate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n      const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n      const noiseL = new Noise({\n        context\n      });\n      const noiseR = new Noise({\n        context\n      });\n      const merge = new Merge({\n        context\n      });\n      noiseL.connect(merge, 0, 0);\n      noiseR.connect(merge, 0, 1);\n      const gainNode = new Gain({\n        context\n      }).toDestination();\n      merge.connect(gainNode);\n      noiseL.start(0);\n      noiseR.start(0); // predelay\n\n      gainNode.gain.setValueAtTime(0, 0);\n      gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n      gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n      const renderPromise = context.render();\n      this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n      yield previousReady; // set the buffer\n\n      this._convolver.buffer = (yield renderPromise).get();\n      return this;\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._convolver.disconnect();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Split } from \"./Split\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels).\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n */\n\nexport class MidSideSplit extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(MidSideSplit.getDefaults(), arguments));\n    this.name = \"MidSideSplit\";\n    this._split = this.input = new Split({\n      channels: 2,\n      context: this.context\n    });\n    this._midAdd = new Add({\n      context: this.context\n    });\n    this.mid = new Multiply({\n      context: this.context,\n      value: Math.SQRT1_2\n    });\n    this._sideSubtract = new Subtract({\n      context: this.context\n    });\n    this.side = new Multiply({\n      context: this.context,\n      value: Math.SQRT1_2\n    });\n\n    this._split.connect(this._midAdd, 0);\n\n    this._split.connect(this._midAdd.addend, 1);\n\n    this._split.connect(this._sideSubtract, 0);\n\n    this._split.connect(this._sideSubtract.subtrahend, 1);\n\n    this._midAdd.connect(this.mid);\n\n    this._sideSubtract.connect(this.side);\n  }\n\n  dispose() {\n    super.dispose();\n    this.mid.dispose();\n    this.side.dispose();\n\n    this._midAdd.dispose();\n\n    this._sideSubtract.dispose();\n\n    this._split.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Merge } from \"./Merge\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * MidSideMerge merges the mid and side signal after they've been separated by [[MidSideMerge]]\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ\n * ```\n */\n\nexport class MidSideMerge extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(MidSideMerge.getDefaults(), arguments));\n    this.name = \"MidSideMerge\";\n    this.mid = new Gain({\n      context: this.context\n    });\n    this.side = new Gain({\n      context: this.context\n    });\n    this._left = new Add({\n      context: this.context\n    });\n    this._leftMult = new Multiply({\n      context: this.context,\n      value: Math.SQRT1_2\n    });\n    this._right = new Subtract({\n      context: this.context\n    });\n    this._rightMult = new Multiply({\n      context: this.context,\n      value: Math.SQRT1_2\n    });\n    this._merge = this.output = new Merge({\n      context: this.context\n    });\n    this.mid.fan(this._left);\n    this.side.connect(this._left.addend);\n    this.mid.connect(this._right);\n    this.side.connect(this._right.subtrahend);\n\n    this._left.connect(this._leftMult);\n\n    this._right.connect(this._rightMult);\n\n    this._leftMult.connect(this._merge, 0, 0);\n\n    this._rightMult.connect(this._merge, 0, 1);\n  }\n\n  dispose() {\n    super.dispose();\n    this.mid.dispose();\n    this.side.dispose();\n\n    this._leftMult.dispose();\n\n    this._rightMult.dispose();\n\n    this._left.dispose();\n\n    this._right.dispose();\n\n    return this;\n  }\n\n}","import { Effect } from \"./Effect\";\nimport { MidSideSplit } from \"../component/channel/MidSideSplit\";\nimport { MidSideMerge } from \"../component/channel/MidSideMerge\";\n/**\n * Mid/Side processing separates the the 'mid' signal\n * (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels)\n * and effects them separately before being recombined.\n * Applies a Mid/Side seperation and recombination.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * This is a base-class for Mid/Side Effects.\n */\n\nexport class MidSideEffect extends Effect {\n  constructor(options) {\n    super(options);\n    this.name = \"MidSideEffect\";\n    this._midSideMerge = new MidSideMerge({\n      context: this.context\n    });\n    this._midSideSplit = new MidSideSplit({\n      context: this.context\n    });\n    this._midSend = this._midSideSplit.mid;\n    this._sideSend = this._midSideSplit.side;\n    this._midReturn = this._midSideMerge.mid;\n    this._sideReturn = this._midSideMerge.side; // the connections\n\n    this.effectSend.connect(this._midSideSplit);\n\n    this._midSideMerge.connect(this.effectReturn);\n  }\n  /**\n   * Connect the mid chain of the effect\n   */\n\n\n  connectEffectMid(...nodes) {\n    this._midSend.chain(...nodes, this._midReturn);\n  }\n  /**\n   * Connect the side chain of the effect\n   */\n\n\n  connectEffectSide(...nodes) {\n    this._sideSend.chain(...nodes, this._sideReturn);\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._midSideSplit.dispose();\n\n    this._midSideMerge.dispose();\n\n    this._midSend.dispose();\n\n    this._sideSend.dispose();\n\n    this._midReturn.dispose();\n\n    this._sideReturn.dispose();\n\n    return this;\n  }\n\n}","import { MidSideEffect } from \"../effect/MidSideEffect\";\nimport { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Subtract } from \"../signal/Subtract\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { connect } from \"../core/context/ToneAudioNode\";\n/**\n * Applies a width factor to the mid/side seperation.\n * 0 is all mid and 1 is all side.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * ```\n * Mid *= 2*(1-width)<br>\n * Side *= 2*width\n * ```\n * @category Effect\n */\n\nexport class StereoWidener extends MidSideEffect {\n  constructor() {\n    super(optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]));\n    this.name = \"StereoWidener\";\n    const options = optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]);\n    this.width = new Signal({\n      context: this.context,\n      value: options.width,\n      units: \"normalRange\"\n    });\n    readOnly(this, [\"width\"]);\n    this._twoTimesWidthMid = new Multiply({\n      context: this.context,\n      value: 2\n    });\n    this._twoTimesWidthSide = new Multiply({\n      context: this.context,\n      value: 2\n    });\n    this._midMult = new Multiply({\n      context: this.context\n    });\n\n    this._twoTimesWidthMid.connect(this._midMult.factor);\n\n    this.connectEffectMid(this._midMult);\n    this._oneMinusWidth = new Subtract({\n      context: this.context\n    });\n\n    this._oneMinusWidth.connect(this._twoTimesWidthMid);\n\n    connect(this.context.getConstant(1), this._oneMinusWidth);\n    this.width.connect(this._oneMinusWidth.subtrahend);\n    this._sideMult = new Multiply({\n      context: this.context\n    });\n    this.width.connect(this._twoTimesWidthSide);\n\n    this._twoTimesWidthSide.connect(this._sideMult.factor);\n\n    this.connectEffectSide(this._sideMult);\n  }\n\n  static getDefaults() {\n    return Object.assign(MidSideEffect.getDefaults(), {\n      width: 0.5\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.width.dispose();\n\n    this._midMult.dispose();\n\n    this._sideMult.dispose();\n\n    this._twoTimesWidthMid.dispose();\n\n    this._twoTimesWidthSide.dispose();\n\n    this._oneMinusWidth.dispose();\n\n    return this;\n  }\n\n}","import { StereoEffect } from \"./StereoEffect\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Signal } from \"../signal/Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Tremolo modulates the amplitude of an incoming signal using an [[LFO]].\n * The effect is a stereo effect where the modulation phase is inverted in each channel.\n *\n * @example\n * // create a tremolo and start it's LFO\n * const tremolo = new Tone.Tremolo(9, 0.75).toDestination().start();\n * // route an oscillator through the tremolo and start it\n * const oscillator = new Tone.Oscillator().connect(tremolo).start();\n *\n * @category Effect\n */\n\nexport class Tremolo extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n    this.name = \"Tremolo\";\n    const options = optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n    this._lfoL = new LFO({\n      context: this.context,\n      type: options.type,\n      min: 1,\n      max: 0\n    });\n    this._lfoR = new LFO({\n      context: this.context,\n      type: options.type,\n      min: 1,\n      max: 0\n    });\n    this._amplitudeL = new Gain({\n      context: this.context\n    });\n    this._amplitudeR = new Gain({\n      context: this.context\n    });\n    this.frequency = new Signal({\n      context: this.context,\n      value: options.frequency,\n      units: \"frequency\"\n    });\n    this.depth = new Signal({\n      context: this.context,\n      value: options.depth,\n      units: \"normalRange\"\n    });\n    readOnly(this, [\"frequency\", \"depth\"]);\n    this.connectEffectLeft(this._amplitudeL);\n    this.connectEffectRight(this._amplitudeR);\n\n    this._lfoL.connect(this._amplitudeL.gain);\n\n    this._lfoR.connect(this._amplitudeR.gain);\n\n    this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n    this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n    this.spread = options.spread;\n  }\n\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      frequency: 10,\n      type: \"sine\",\n      depth: 0.5,\n      spread: 180\n    });\n  }\n  /**\n   * Start the tremolo.\n   */\n\n\n  start(time) {\n    this._lfoL.start(time);\n\n    this._lfoR.start(time);\n\n    return this;\n  }\n  /**\n   * Stop the tremolo.\n   */\n\n\n  stop(time) {\n    this._lfoL.stop(time);\n\n    this._lfoR.stop(time);\n\n    return this;\n  }\n  /**\n   * Sync the effect to the transport.\n   */\n\n\n  sync() {\n    this._lfoL.sync();\n\n    this._lfoR.sync();\n\n    this.context.transport.syncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * Unsync the filter from the transport\n   */\n\n\n  unsync() {\n    this._lfoL.unsync();\n\n    this._lfoR.unsync();\n\n    this.context.transport.unsyncSignal(this.frequency);\n    return this;\n  }\n  /**\n   * The oscillator type.\n   */\n\n\n  get type() {\n    return this._lfoL.type;\n  }\n\n  set type(type) {\n    this._lfoL.type = type;\n    this._lfoR.type = type;\n  }\n  /**\n   * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n   * When set to 180, LFO's will be panned hard left and right respectively.\n   */\n\n\n  get spread() {\n    return this._lfoR.phase - this._lfoL.phase; // 180\n  }\n\n  set spread(spread) {\n    this._lfoL.phase = 90 - spread / 2;\n    this._lfoR.phase = spread / 2 + 90;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._lfoL.dispose();\n\n    this._lfoR.dispose();\n\n    this._amplitudeL.dispose();\n\n    this._amplitudeR.dispose();\n\n    this.frequency.dispose();\n    this.depth.dispose();\n    return this;\n  }\n\n}","import { Effect } from \"./Effect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n * modulates the delayTime of the delay, causing the pitch to rise and fall.\n * @category Effect\n */\n\nexport class Vibrato extends Effect {\n  constructor() {\n    super(optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n    this.name = \"Vibrato\";\n    const options = optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n    this._delayNode = new Delay({\n      context: this.context,\n      delayTime: 0,\n      maxDelay: options.maxDelay\n    });\n    this._lfo = new LFO({\n      context: this.context,\n      type: options.type,\n      min: 0,\n      max: options.maxDelay,\n      frequency: options.frequency,\n      phase: -90 // offse the phase so the resting position is in the center\n\n    }).start().connect(this._delayNode.delayTime);\n    this.frequency = this._lfo.frequency;\n    this.depth = this._lfo.amplitude;\n    this.depth.value = options.depth;\n    readOnly(this, [\"frequency\", \"depth\"]);\n    this.effectSend.chain(this._delayNode, this.effectReturn);\n  }\n\n  static getDefaults() {\n    return Object.assign(Effect.getDefaults(), {\n      maxDelay: 0.005,\n      frequency: 5,\n      depth: 0.1,\n      type: \"sine\"\n    });\n  }\n  /**\n   * Type of oscillator attached to the Vibrato.\n   */\n\n\n  get type() {\n    return this._lfo.type;\n  }\n\n  set type(type) {\n    this._lfo.type = type;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._delayNode.dispose();\n\n    this._lfo.dispose();\n\n    this.frequency.dispose();\n    this.depth.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\n\nexport class Analyser extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n    this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n\n    this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n\n    this._buffers = [];\n    const options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    this.input = this.output = this._gain = new Gain({\n      context: this.context\n    });\n    this._split = new Split({\n      context: this.context,\n      channels: options.channels\n    });\n    this.input.connect(this._split);\n    assertRange(options.channels, 1); // create the analysers\n\n    for (let channel = 0; channel < options.channels; channel++) {\n      this._analysers[channel] = this.context.createAnalyser();\n\n      this._split.connect(this._analysers[channel], channel, 0);\n    } // set the values initially\n\n\n    this.size = options.size;\n    this.type = options.type;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      size: 1024,\n      smoothing: 0.8,\n      type: \"fft\",\n      channels: 1\n    });\n  }\n  /**\n   * Run the analysis given the current settings. If [[channels]] = 1,\n   * it will return a Float32Array. If [[channels]] > 1, it will\n   * return an array of Float32Arrays where each index in the array\n   * represents the analysis done on a channel.\n   */\n\n\n  getValue() {\n    this._analysers.forEach((analyser, index) => {\n      const buffer = this._buffers[index];\n\n      if (this._type === \"fft\") {\n        analyser.getFloatFrequencyData(buffer);\n      } else if (this._type === \"waveform\") {\n        analyser.getFloatTimeDomainData(buffer);\n      }\n    });\n\n    if (this.channels === 1) {\n      return this._buffers[0];\n    } else {\n      return this._buffers;\n    }\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   */\n\n\n  get size() {\n    return this._analysers[0].frequencyBinCount;\n  }\n\n  set size(size) {\n    this._analysers.forEach((analyser, index) => {\n      analyser.fftSize = size * 2;\n      this._buffers[index] = new Float32Array(size);\n    });\n  }\n  /**\n   * The number of channels the analyser does the analysis on. Channel\n   * separation is done using [[Split]]\n   */\n\n\n  get channels() {\n    return this._analysers.length;\n  }\n  /**\n   * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n    this._type = type;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analysers[0].smoothingTimeConstant;\n  }\n\n  set smoothing(val) {\n    this._analysers.forEach(a => a.smoothingTimeConstant = val);\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n\n    this._analysers.forEach(a => a.disconnect());\n\n    this._split.dispose();\n\n    this._gain.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Analyser } from \"./Analyser\";\n/**\n * The base class for Metering classes.\n */\n\nexport class MeterBase extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(MeterBase.getDefaults(), arguments));\n    this.name = \"MeterBase\";\n    this.input = this.output = this._analyser = new Analyser({\n      context: this.context,\n      size: 256,\n      type: \"waveform\"\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._analyser.dispose();\n\n    return this;\n  }\n\n}","import { gainToDb } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { warn } from \"../../core/util/Debug\";\nimport { Analyser } from \"./Analyser\";\n/**\n * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n * of an input signal. It can also get the raw value of the input signal.\n *\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\n\nexport class Meter extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]));\n    this.name = \"Meter\";\n    /**\n     * The previous frame's value\n     */\n\n    this._rms = 0;\n    const options = optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]);\n    this.input = this.output = this._analyser = new Analyser({\n      context: this.context,\n      size: 256,\n      type: \"waveform\",\n      channels: options.channels\n    });\n    this.smoothing = options.smoothing, this.normalRange = options.normalRange;\n  }\n\n  static getDefaults() {\n    return Object.assign(MeterBase.getDefaults(), {\n      smoothing: 0.8,\n      normalRange: false,\n      channels: 1\n    });\n  }\n  /**\n   * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.\n   * @deprecated\n   */\n\n\n  getLevel() {\n    warn(\"'getLevel' has been changed to 'getValue'\");\n    return this.getValue();\n  }\n  /**\n   * Get the current value of the incoming signal.\n   * Output is in decibels when [[normalRange]] is `false`.\n   * If [[channels]] = 1, then the output is a single number\n   * representing the value of the input signal. When [[channels]] > 1,\n   * then each channel is returned as a value in a number array.\n   */\n\n\n  getValue() {\n    const aValues = this._analyser.getValue();\n\n    const channelValues = this.channels === 1 ? [aValues] : aValues;\n    const vals = channelValues.map(values => {\n      const totalSquared = values.reduce((total, current) => total + current * current, 0);\n      const rms = Math.sqrt(totalSquared / values.length); // the rms can only fall at the rate of the smoothing\n      // but can jump up instantly\n\n      this._rms = Math.max(rms, this._rms * this.smoothing);\n      return this.normalRange ? this._rms : gainToDb(this._rms);\n    });\n\n    if (this.channels === 1) {\n      return vals[0];\n    } else {\n      return vals;\n    }\n  }\n  /**\n   * The number of channels of analysis.\n   */\n\n\n  get channels() {\n    return this._analyser.channels;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._analyser.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\n\nexport class FFT extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n    this.name = \"FFT\";\n    const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    this.normalRange = options.normalRange;\n    this._analyser.type = \"fft\";\n    this.size = options.size;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalRange: false,\n      size: 1024,\n      smoothing: 0.8\n    });\n  }\n  /**\n   * Gets the current frequency data from the connected audio source.\n   * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n   */\n\n\n  getValue() {\n    const values = this._analyser.getValue();\n\n    return values.map(v => this.normalRange ? dbToGain(v) : v);\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   * Determines the size of the array returned by [[getValue]] (i.e. the number of\n   * frequency bins). Large FFT sizes may be costly to compute.\n   */\n\n\n  get size() {\n    return this._analyser.size;\n  }\n\n  set size(size) {\n    this._analyser.size = size;\n  }\n  /**\n   * 0 represents no time averaging with the last analysis frame.\n   */\n\n\n  get smoothing() {\n    return this._analyser.smoothing;\n  }\n\n  set smoothing(val) {\n    this._analyser.smoothing = val;\n  }\n\n}","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\n/**\n * DCMeter gets the raw value of the input signal at the current time.\n *\n * @example\n * const meter = new Tone.DCMeter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\n\nexport class DCMeter extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(DCMeter.getDefaults(), arguments));\n    this.name = \"DCMeter\";\n    this._analyser.type = \"waveform\";\n    this._analyser.size = 256;\n  }\n  /**\n   * Get the signal value of the incoming signal\n   */\n\n\n  getValue() {\n    const value = this._analyser.getValue();\n\n    return value[0];\n  }\n\n}","import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\n/**\n * Get the current waveform data of the connected audio source.\n * @category Component\n */\n\nexport class Waveform extends MeterBase {\n  constructor() {\n    super(optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]));\n    this.name = \"Waveform\";\n    const options = optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]);\n    this._analyser.type = \"waveform\";\n    this.size = options.size;\n  }\n\n  static getDefaults() {\n    return Object.assign(MeterBase.getDefaults(), {\n      size: 1024\n    });\n  }\n  /**\n   * Return the waveform for the current time as a Float32Array where each value in the array\n   * represents a sample in the waveform.\n   */\n\n\n  getValue() {\n    return this._analyser.getValue();\n  }\n  /**\n   * The size of analysis. This must be a power of two in the range 16 to 16384.\n   * Determines the size of the array returned by [[getValue]].\n   */\n\n\n  get size() {\n    return this._analyser.size;\n  }\n\n  set size(size) {\n    this._analyser.size = size;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\n\nexport class Solo extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n    this.name = \"Solo\";\n    const options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n    this.input = this.output = new Gain({\n      context: this.context\n    });\n\n    if (!Solo._allSolos.has(this.context)) {\n      Solo._allSolos.set(this.context, new Set());\n    }\n\n    Solo._allSolos.get(this.context).add(this); // set initially\n\n\n    this.solo = options.solo;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      solo: false\n    });\n  }\n  /**\n   * Isolates this instance and mutes all other instances of Solo.\n   * Only one instance can be soloed at a time. A soloed\n   * instance will report `solo=false` when another instance is soloed.\n   */\n\n\n  get solo() {\n    return this._isSoloed();\n  }\n\n  set solo(solo) {\n    if (solo) {\n      this._addSolo();\n    } else {\n      this._removeSolo();\n    }\n\n    Solo._allSolos.get(this.context).forEach(instance => instance._updateSolo());\n  }\n  /**\n   * If the current instance is muted, i.e. another instance is soloed\n   */\n\n\n  get muted() {\n    return this.input.gain.value === 0;\n  }\n  /**\n   * Add this to the soloed array\n   */\n\n\n  _addSolo() {\n    if (!Solo._soloed.has(this.context)) {\n      Solo._soloed.set(this.context, new Set());\n    }\n\n    Solo._soloed.get(this.context).add(this);\n  }\n  /**\n   * Remove this from the soloed array\n   */\n\n\n  _removeSolo() {\n    if (Solo._soloed.has(this.context)) {\n      Solo._soloed.get(this.context).delete(this);\n    }\n  }\n  /**\n   * Is this on the soloed array\n   */\n\n\n  _isSoloed() {\n    return Solo._soloed.has(this.context) && Solo._soloed.get(this.context).has(this);\n  }\n  /**\n   * Returns true if no one is soloed\n   */\n\n\n  _noSolos() {\n    // either does not have any soloed added\n    return !Solo._soloed.has(this.context) || // or has a solo set but doesn't include any items\n    Solo._soloed.has(this.context) && Solo._soloed.get(this.context).size === 0;\n  }\n  /**\n   * Solo the current instance and unsolo all other instances.\n   */\n\n\n  _updateSolo() {\n    if (this._isSoloed()) {\n      this.input.gain.value = 1;\n    } else if (this._noSolos()) {\n      // no one is soloed\n      this.input.gain.value = 1;\n    } else {\n      this.input.gain.value = 0;\n    }\n  }\n\n  dispose() {\n    super.dispose();\n\n    Solo._allSolos.get(this.context).delete(this);\n\n    this._removeSolo();\n\n    return this;\n  }\n\n}\n/**\n * Hold all of the solo'ed tracks belonging to a specific context\n */\n\nSolo._allSolos = new Map();\n/**\n * Hold the currently solo'ed instance(s)\n */\n\nSolo._soloed = new Map();","import { readOnly } from \"../../core/util/Interface\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\n\nexport class PanVol extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n    this.name = \"PanVol\";\n    const options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n    this._panner = this.input = new Panner({\n      context: this.context,\n      pan: options.pan,\n      channelCount: options.channelCount\n    });\n    this.pan = this._panner.pan;\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume; // connections\n\n    this._panner.connect(this._volume);\n\n    this.mute = options.mute;\n    readOnly(this, [\"pan\", \"volume\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      pan: 0,\n      volume: 0,\n      channelCount: 1\n    });\n  }\n  /**\n   * Mute/unmute the volume\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.dispose();\n\n    this.pan.dispose();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls.\n * See [[PanVol]] and [[Solo]]\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\n\nexport class Channel extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n    this.name = \"Channel\";\n    const options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n    this._solo = this.input = new Solo({\n      solo: options.solo,\n      context: this.context\n    });\n    this._panVol = this.output = new PanVol({\n      context: this.context,\n      pan: options.pan,\n      volume: options.volume,\n      mute: options.mute\n    });\n    this.pan = this._panVol.pan;\n    this.volume = this._panVol.volume;\n\n    this._solo.connect(this._panVol);\n\n    readOnly(this, [\"pan\", \"volume\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      pan: 0,\n      volume: 0,\n      mute: false,\n      solo: false\n    });\n  }\n  /**\n   * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n   */\n\n\n  get solo() {\n    return this._solo.solo;\n  }\n\n  set solo(solo) {\n    this._solo.solo = solo;\n  }\n  /**\n   * If the current instance is muted, i.e. another instance is soloed,\n   * or the channel is muted\n   */\n\n\n  get muted() {\n    return this._solo.muted || this.mute;\n  }\n  /**\n   * Mute/unmute the volume\n   */\n\n\n  get mute() {\n    return this._panVol.mute;\n  }\n\n  set mute(mute) {\n    this._panVol.mute = mute;\n  }\n  /**\n   * Get the gain node belonging to the bus name. Create it if\n   * it doesn't exist\n   * @param name The bus name\n   */\n\n\n  _getBus(name) {\n    if (!Channel.buses.has(name)) {\n      Channel.buses.set(name, new Gain({\n        context: this.context\n      }));\n    }\n\n    return Channel.buses.get(name);\n  }\n  /**\n   * Send audio to another channel using a string. `send` is a lot like\n   * [[connect]], except it uses a string instead of an object. This can\n   * be useful in large applications to decouple sections since [[send]]\n   * and [[receive]] can be invoked separately in order to connect an object\n   * @param name The channel name to send the audio\n   * @param volume The amount of the signal to send.\n   * \tDefaults to 0db, i.e. send the entire signal\n   * @returns Returns the gain node of this connection.\n   */\n\n\n  send(name, volume = 0) {\n    const bus = this._getBus(name);\n\n    const sendKnob = new Gain({\n      context: this.context,\n      units: \"decibels\",\n      gain: volume\n    });\n    this.connect(sendKnob);\n    sendKnob.connect(bus);\n    return sendKnob;\n  }\n  /**\n   * Receive audio from a channel which was connected with [[send]].\n   * @param name The channel name to receive audio from.\n   */\n\n\n  receive(name) {\n    const bus = this._getBus(name);\n\n    bus.connect(this);\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panVol.dispose();\n\n    this.pan.dispose();\n    this.volume.dispose();\n\n    this._solo.dispose();\n\n    return this;\n  }\n\n}\n/**\n * Store the send/receive channels by name.\n */\n\nChannel.buses = new Map();","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\n\nexport class MultibandSplit extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n    this.name = \"MultibandSplit\";\n    /**\n     * the input\n     */\n\n    this.input = new Gain({\n      context: this.context\n    });\n    /**\n     * no output node, use either low, mid or high outputs\n     */\n\n    this.output = undefined;\n    /**\n     * The low band.\n     */\n\n    this.low = new Filter({\n      context: this.context,\n      frequency: 0,\n      type: \"lowpass\"\n    });\n    /**\n     * the lower filter of the mid band\n     */\n\n    this._lowMidFilter = new Filter({\n      context: this.context,\n      frequency: 0,\n      type: \"highpass\"\n    });\n    /**\n     * The mid band output.\n     */\n\n    this.mid = new Filter({\n      context: this.context,\n      frequency: 0,\n      type: \"lowpass\"\n    });\n    /**\n     * The high band output.\n     */\n\n    this.high = new Filter({\n      context: this.context,\n      frequency: 0,\n      type: \"highpass\"\n    });\n    this._internalChannels = [this.low, this.mid, this.high];\n    const options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n    this.lowFrequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.lowFrequency\n    });\n    this.highFrequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.highFrequency\n    });\n    this.Q = new Signal({\n      context: this.context,\n      units: \"positive\",\n      value: options.Q\n    });\n    this.input.fan(this.low, this.high);\n    this.input.chain(this._lowMidFilter, this.mid); // the frequency control signal\n\n    this.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n    this.highFrequency.fan(this.mid.frequency, this.high.frequency); // the Q value\n\n    this.Q.connect(this.low.Q);\n    this.Q.connect(this._lowMidFilter.Q);\n    this.Q.connect(this.mid.Q);\n    this.Q.connect(this.high.Q);\n    readOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      Q: 1,\n      highFrequency: 2500,\n      lowFrequency: 400\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    writable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n    this.low.dispose();\n\n    this._lowMidFilter.dispose();\n\n    this.mid.dispose();\n    this.high.dispose();\n    this.lowFrequency.dispose();\n    this.highFrequency.dispose();\n    this.Q.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"./ToneAudioNode\";\nimport { Param } from \"./Param\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you\n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context.\n */\n\nexport class Listener extends ToneAudioNode {\n  constructor() {\n    super(...arguments);\n    this.name = \"Listener\";\n    this.positionX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionX\n    });\n    this.positionY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionY\n    });\n    this.positionZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.positionZ\n    });\n    this.forwardX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardX\n    });\n    this.forwardY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardY\n    });\n    this.forwardZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.forwardZ\n    });\n    this.upX = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upX\n    });\n    this.upY = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upY\n    });\n    this.upZ = new Param({\n      context: this.context,\n      param: this.context.rawContext.listener.upZ\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      positionX: 0,\n      positionY: 0,\n      positionZ: 0,\n      forwardX: 0,\n      forwardY: 0,\n      forwardZ: -1,\n      upX: 0,\n      upY: 1,\n      upZ: 0\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.positionX.dispose();\n    this.positionY.dispose();\n    this.positionZ.dispose();\n    this.forwardX.dispose();\n    this.forwardY.dispose();\n    this.forwardZ.dispose();\n    this.upX.dispose();\n    this.upY.dispose();\n    this.upZ.dispose();\n    return this;\n  }\n\n} //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n  context.listener = new Listener({\n    context\n  });\n});\nonContextClose(context => {\n  context.listener.dispose();\n});","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport \"../../core/context/Listener\";\n/**\n * A spatialized panner node which supports equalpower or HRTF panning.\n * @category Component\n */\n\nexport class Panner3D extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]));\n    this.name = \"Panner3D\";\n    const options = optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]);\n    this._panner = this.input = this.output = this.context.createPanner(); // set some values\n\n    this.panningModel = options.panningModel;\n    this.maxDistance = options.maxDistance;\n    this.distanceModel = options.distanceModel;\n    this.coneOuterGain = options.coneOuterGain;\n    this.coneOuterAngle = options.coneOuterAngle;\n    this.coneInnerAngle = options.coneInnerAngle;\n    this.refDistance = options.refDistance;\n    this.rolloffFactor = options.rolloffFactor;\n    this.positionX = new Param({\n      context: this.context,\n      param: this._panner.positionX,\n      value: options.positionX\n    });\n    this.positionY = new Param({\n      context: this.context,\n      param: this._panner.positionY,\n      value: options.positionY\n    });\n    this.positionZ = new Param({\n      context: this.context,\n      param: this._panner.positionZ,\n      value: options.positionZ\n    });\n    this.orientationX = new Param({\n      context: this.context,\n      param: this._panner.orientationX,\n      value: options.orientationX\n    });\n    this.orientationY = new Param({\n      context: this.context,\n      param: this._panner.orientationY,\n      value: options.orientationY\n    });\n    this.orientationZ = new Param({\n      context: this.context,\n      param: this._panner.orientationZ,\n      value: options.orientationZ\n    });\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      coneInnerAngle: 360,\n      coneOuterAngle: 360,\n      coneOuterGain: 0,\n      distanceModel: \"inverse\",\n      maxDistance: 10000,\n      orientationX: 0,\n      orientationY: 0,\n      orientationZ: 0,\n      panningModel: \"equalpower\",\n      positionX: 0,\n      positionY: 0,\n      positionZ: 0,\n      refDistance: 1,\n      rolloffFactor: 1\n    });\n  }\n  /**\n   * Sets the position of the source in 3d space.\n   */\n\n\n  setPosition(x, y, z) {\n    this.positionX.value = x;\n    this.positionY.value = y;\n    this.positionZ.value = z;\n    return this;\n  }\n  /**\n   * Sets the orientation of the source in 3d space.\n   */\n\n\n  setOrientation(x, y, z) {\n    this.orientationX.value = x;\n    this.orientationY.value = y;\n    this.orientationZ.value = z;\n    return this;\n  }\n  /**\n   * The panning model. Either \"equalpower\" or \"HRTF\".\n   */\n\n\n  get panningModel() {\n    return this._panner.panningModel;\n  }\n\n  set panningModel(val) {\n    this._panner.panningModel = val;\n  }\n  /**\n   * A reference distance for reducing volume as source move further from the listener\n   */\n\n\n  get refDistance() {\n    return this._panner.refDistance;\n  }\n\n  set refDistance(val) {\n    this._panner.refDistance = val;\n  }\n  /**\n   * Describes how quickly the volume is reduced as source moves away from listener.\n   */\n\n\n  get rolloffFactor() {\n    return this._panner.rolloffFactor;\n  }\n\n  set rolloffFactor(val) {\n    this._panner.rolloffFactor = val;\n  }\n  /**\n   * The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n   */\n\n\n  get distanceModel() {\n    return this._panner.distanceModel;\n  }\n\n  set distanceModel(val) {\n    this._panner.distanceModel = val;\n  }\n  /**\n   * The angle, in degrees, inside of which there will be no volume reduction\n   */\n\n\n  get coneInnerAngle() {\n    return this._panner.coneInnerAngle;\n  }\n\n  set coneInnerAngle(val) {\n    this._panner.coneInnerAngle = val;\n  }\n  /**\n   * The angle, in degrees, outside of which the volume will be reduced\n   * to a constant value of coneOuterGain\n   */\n\n\n  get coneOuterAngle() {\n    return this._panner.coneOuterAngle;\n  }\n\n  set coneOuterAngle(val) {\n    this._panner.coneOuterAngle = val;\n  }\n  /**\n   * The gain outside of the coneOuterAngle\n   */\n\n\n  get coneOuterGain() {\n    return this._panner.coneOuterGain;\n  }\n\n  set coneOuterGain(val) {\n    this._panner.coneOuterGain = val;\n  }\n  /**\n   * The maximum distance between source and listener,\n   * after which the volume will not be reduced any further.\n   */\n\n\n  get maxDistance() {\n    return this._panner.maxDistance;\n  }\n\n  set maxDistance(val) {\n    this._panner.maxDistance = val;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._panner.disconnect();\n\n    this.orientationX.dispose();\n    this.orientationY.dispose();\n    this.orientationZ.dispose();\n    this.positionX.dispose();\n    this.positionY.dispose();\n    this.positionZ.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n */\n\nexport class Recorder extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Recorder.getDefaults(), arguments, [\"gain\", \"units\"]));\n    this.name = \"Recorder\";\n    const options = optionsFromArguments(Recorder.getDefaults(), arguments, [\"gain\", \"units\"]);\n    this.input = new Gain({\n      context: this.context\n    });\n    assert(Recorder.supported, \"Media Recorder API is not available\");\n    this._stream = this.context.createMediaStreamDestination();\n    this.input.connect(this._stream);\n    this._recorder = new MediaRecorder(this._stream.stream, {\n      mimeType: options.mimeType\n    });\n  }\n\n  static getDefaults() {\n    return ToneAudioNode.getDefaults();\n  }\n  /**\n   * The mime type is the format that the audio is encoded in. For Chrome\n   * that is typically webm encoded as \"vorbis\".\n   */\n\n\n  get mimeType() {\n    return this._recorder.mimeType;\n  }\n  /**\n   * Test if your platform supports the Media Recorder API. If it's not available,\n   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n   */\n\n\n  static get supported() {\n    return theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n  }\n  /**\n   * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n   */\n\n\n  get state() {\n    if (this._recorder.state === \"inactive\") {\n      return \"stopped\";\n    } else if (this._recorder.state === \"paused\") {\n      return \"paused\";\n    } else {\n      return \"started\";\n    }\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"started\", \"Recorder is already started\");\n      const startPromise = new Promise(done => {\n        const handleStart = () => {\n          this._recorder.removeEventListener(\"start\", handleStart, false);\n\n          done();\n        };\n\n        this._recorder.addEventListener(\"start\", handleStart, false);\n      });\n\n      this._recorder.start();\n\n      return yield startPromise;\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"stopped\", \"Recorder is not started\");\n      const dataPromise = new Promise(done => {\n        const handleData = e => {\n          this._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n          done(e.data);\n        };\n\n        this._recorder.addEventListener(\"dataavailable\", handleData, false);\n      });\n\n      this._recorder.stop();\n\n      return yield dataPromise;\n    });\n  }\n\n  pause() {\n    assert(this.state === \"started\", \"Recorder must be started\");\n\n    this._recorder.pause();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n\n    this._stream.disconnect();\n\n    return this;\n  }\n\n}","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * const comp = new Tone.Compressor(-30, 3);\n * @category Component\n */\n\nexport class Compressor extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]));\n    this.name = \"Compressor\";\n    /**\n     * the compressor node\n     */\n\n    this._compressor = this.context.createDynamicsCompressor();\n    this.input = this._compressor;\n    this.output = this._compressor;\n    const options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]);\n    this.threshold = new Param({\n      minValue: this._compressor.threshold.minValue,\n      maxValue: this._compressor.threshold.maxValue,\n      context: this.context,\n      convert: false,\n      param: this._compressor.threshold,\n      units: \"decibels\",\n      value: options.threshold\n    });\n    this.attack = new Param({\n      minValue: this._compressor.attack.minValue,\n      maxValue: this._compressor.attack.maxValue,\n      context: this.context,\n      param: this._compressor.attack,\n      units: \"time\",\n      value: options.attack\n    });\n    this.release = new Param({\n      minValue: this._compressor.release.minValue,\n      maxValue: this._compressor.release.maxValue,\n      context: this.context,\n      param: this._compressor.release,\n      units: \"time\",\n      value: options.release\n    });\n    this.knee = new Param({\n      minValue: this._compressor.knee.minValue,\n      maxValue: this._compressor.knee.maxValue,\n      context: this.context,\n      convert: false,\n      param: this._compressor.knee,\n      units: \"decibels\",\n      value: options.knee\n    });\n    this.ratio = new Param({\n      minValue: this._compressor.ratio.minValue,\n      maxValue: this._compressor.ratio.maxValue,\n      context: this.context,\n      convert: false,\n      param: this._compressor.ratio,\n      units: \"positive\",\n      value: options.ratio\n    }); // set the defaults\n\n    readOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      attack: 0.003,\n      knee: 30,\n      ratio: 12,\n      release: 0.25,\n      threshold: -24\n    });\n  }\n  /**\n   * A read-only decibel value for metering purposes, representing the current amount of gain\n   * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n   */\n\n\n  get reduction() {\n    return this._compressor.reduction;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._compressor.disconnect();\n\n    this.attack.dispose();\n    this.release.dispose();\n    this.threshold.dispose();\n    this.ratio.dispose();\n    this.knee.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { GreaterThan } from \"../../signal/GreaterThan\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Follower } from \"../analysis/Follower\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { dbToGain, gainToDb } from \"../../core/type/Conversions\";\n/**\n * Gate only passes a signal through when the incoming\n * signal exceeds a specified threshold. It uses [[Follower]] to follow the ampltiude\n * of the incoming signal and compares it to the [[threshold]] value using [[GreaterThan]].\n *\n * @example\n * const gate = new Tone.Gate(-30, 0.2).toDestination();\n * const mic = new Tone.UserMedia().connect(gate);\n * // the gate will only pass through the incoming\n * // signal when it's louder than -30db\n */\n\nexport class Gate extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"])));\n    this.name = \"Gate\";\n    const options = optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"]);\n    this._follower = new Follower({\n      context: this.context,\n      smoothing: options.smoothing\n    });\n    this._gt = new GreaterThan({\n      context: this.context,\n      value: dbToGain(options.threshold)\n    });\n    this.input = new Gain({\n      context: this.context\n    });\n    this._gate = this.output = new Gain({\n      context: this.context\n    }); // connections\n\n    this.input.connect(this._gate); // the control signal\n\n    this.input.chain(this._follower, this._gt, this._gate.gain);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      smoothing: 0.1,\n      threshold: -40\n    });\n  }\n  /**\n   * The threshold of the gate in decibels\n   */\n\n\n  get threshold() {\n    return gainToDb(this._gt.value);\n  }\n\n  set threshold(thresh) {\n    this._gt.value = dbToGain(thresh);\n  }\n  /**\n   * The attack/decay speed of the gate. See [[Follower.smoothing]]\n   */\n\n\n  get smoothing() {\n    return this._follower.smoothing;\n  }\n\n  set smoothing(smoothingTime) {\n    this._follower.smoothing = smoothingTime;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n\n    this._follower.dispose();\n\n    this._gt.dispose();\n\n    this._gate.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Compressor } from \"./Compressor\";\nimport { readOnly } from \"../../core/util/Interface\";\n;\n/**\n * Limiter will limit the loudness of an incoming signal.\n * It is composed of a [[Compressor]] with a fast attack\n * and release and max ratio. Limiters are commonly used to safeguard against\n * signal clipping. Unlike a compressor, limiters do not provide\n * smooth gain reduction and almost completely prevent\n * additional gain above the threshold.\n *\n * @example\n * const limiter = new Tone.Limiter(-20).toDestination();\n * const oscillator = new Tone.Oscillator().connect(limiter);\n * oscillator.start();\n */\n\nexport class Limiter extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"])));\n    this.name = \"Limiter\";\n    const options = optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"]);\n    this._compressor = this.input = this.output = new Compressor({\n      context: this.context,\n      ratio: 20,\n      attack: 0,\n      release: 0,\n      threshold: options.threshold\n    });\n    this.threshold = this._compressor.threshold;\n    readOnly(this, \"threshold\");\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      threshold: -12\n    });\n  }\n  /**\n   * A read-only decibel value for metering purposes, representing the current amount of gain\n   * reduction that the compressor is applying to the signal.\n   */\n\n\n  get reduction() {\n    return this._compressor.reduction;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._compressor.dispose();\n\n    this.threshold.dispose();\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Compressor } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MidSideSplit } from \"../channel/MidSideSplit\";\nimport { MidSideMerge } from \"../channel/MidSideMerge\";\nimport { readOnly } from \"../../core/util/Interface\";\n/**\n * MidSideCompressor applies two different compressors to the [[mid]]\n * and [[side]] signal components of the input. See [[MidSideSplit]] and [[MidSideMerge]].\n */\n\nexport class MidSideCompressor extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(MidSideCompressor.getDefaults(), arguments)));\n    this.name = \"MidSideCompressor\";\n    const options = optionsFromArguments(MidSideCompressor.getDefaults(), arguments);\n    this._midSideSplit = this.input = new MidSideSplit({\n      context: this.context\n    });\n    this._midSideMerge = this.output = new MidSideMerge({\n      context: this.context\n    });\n    this.mid = new Compressor(Object.assign(options.mid, {\n      context: this.context\n    }));\n    this.side = new Compressor(Object.assign(options.side, {\n      context: this.context\n    }));\n\n    this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\n    this._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\n    readOnly(this, [\"mid\", \"side\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mid: {\n        ratio: 3,\n        threshold: -24,\n        release: 0.03,\n        attack: 0.02,\n        knee: 16\n      },\n      side: {\n        ratio: 6,\n        threshold: -30,\n        release: 0.25,\n        attack: 0.03,\n        knee: 10\n      }\n    });\n  }\n\n  dispose() {\n    super.dispose();\n    this.mid.dispose();\n    this.side.dispose();\n\n    this._midSideSplit.dispose();\n\n    this._midSideMerge.dispose();\n\n    return this;\n  }\n\n}","import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Compressor } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\nimport { Gain } from \"../../core/context/Gain\";\n/**\n * A compressor with separate controls over low/mid/high dynamics. See [[Compressor]] and [[MultibandSplit]]\n *\n * @example\n * const multiband = new Tone.MultibandCompressor({\n * \tlowFrequency: 200,\n * \thighFrequency: 1300,\n * \tlow: {\n * \t\tthreshold: -12\n * \t}\n * });\n */\n\nexport class MultibandCompressor extends ToneAudioNode {\n  constructor() {\n    super(Object.assign(optionsFromArguments(MultibandCompressor.getDefaults(), arguments)));\n    this.name = \"MultibandCompressor\";\n    const options = optionsFromArguments(MultibandCompressor.getDefaults(), arguments);\n    this._splitter = this.input = new MultibandSplit({\n      context: this.context,\n      lowFrequency: options.lowFrequency,\n      highFrequency: options.highFrequency\n    });\n    this.lowFrequency = this._splitter.lowFrequency;\n    this.highFrequency = this._splitter.highFrequency;\n    this.output = new Gain({\n      context: this.context\n    });\n    this.low = new Compressor(Object.assign(options.low, {\n      context: this.context\n    }));\n    this.mid = new Compressor(Object.assign(options.mid, {\n      context: this.context\n    }));\n    this.high = new Compressor(Object.assign(options.high, {\n      context: this.context\n    })); // connect the compressor\n\n    this._splitter.low.chain(this.low, this.output);\n\n    this._splitter.mid.chain(this.mid, this.output);\n\n    this._splitter.high.chain(this.high, this.output);\n\n    readOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      lowFrequency: 250,\n      highFrequency: 2000,\n      low: {\n        ratio: 6,\n        threshold: -30,\n        release: 0.25,\n        attack: 0.03,\n        knee: 10\n      },\n      mid: {\n        ratio: 3,\n        threshold: -24,\n        release: 0.03,\n        attack: 0.02,\n        knee: 16\n      },\n      high: {\n        ratio: 3,\n        threshold: -24,\n        release: 0.03,\n        attack: 0.02,\n        knee: 16\n      }\n    });\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._splitter.dispose();\n\n    this.low.dispose();\n    this.mid.dispose();\n    this.high.dispose();\n    this.output.dispose();\n    return this;\n  }\n\n}","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High.\n * @category Component\n */\n\nexport class EQ3 extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n    this.name = \"EQ3\";\n    /**\n     * the output\n     */\n\n    this.output = new Gain({\n      context: this.context\n    });\n    this._internalChannels = [];\n    const options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n    this.input = this._multibandSplit = new MultibandSplit({\n      context: this.context,\n      highFrequency: options.highFrequency,\n      lowFrequency: options.lowFrequency\n    });\n    this._lowGain = new Gain({\n      context: this.context,\n      gain: options.low,\n      units: \"decibels\"\n    });\n    this._midGain = new Gain({\n      context: this.context,\n      gain: options.mid,\n      units: \"decibels\"\n    });\n    this._highGain = new Gain({\n      context: this.context,\n      gain: options.high,\n      units: \"decibels\"\n    });\n    this.low = this._lowGain.gain;\n    this.mid = this._midGain.gain;\n    this.high = this._highGain.gain;\n    this.Q = this._multibandSplit.Q;\n    this.lowFrequency = this._multibandSplit.lowFrequency;\n    this.highFrequency = this._multibandSplit.highFrequency; // the frequency bands\n\n    this._multibandSplit.low.chain(this._lowGain, this.output);\n\n    this._multibandSplit.mid.chain(this._midGain, this.output);\n\n    this._multibandSplit.high.chain(this._highGain, this.output);\n\n    readOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n    this._internalChannels = [this._multibandSplit];\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      high: 0,\n      highFrequency: 2500,\n      low: 0,\n      lowFrequency: 400,\n      mid: 0\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    writable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\n    this._multibandSplit.dispose();\n\n    this.lowFrequency.dispose();\n    this.highFrequency.dispose();\n\n    this._lowGain.dispose();\n\n    this._midGain.dispose();\n\n    this._highGain.dispose();\n\n    this.low.dispose();\n    this.mid.dispose();\n    this.high.dispose();\n    this.Q.dispose();\n    return this;\n  }\n\n}","import { __awaiter } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { noOp } from \"../../core/util/Interface\";\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * // initializing the convolver with an impulse response\n * const convolver = new Tone.Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Component\n */\n\nexport class Convolver extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n    this.name = \"Convolver\";\n    /**\n     * The native ConvolverNode\n     */\n\n    this._convolver = this.context.createConvolver();\n    const options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n    this._buffer = new ToneAudioBuffer(options.url, buffer => {\n      this.buffer = buffer;\n      options.onload();\n    });\n    this.input = new Gain({\n      context: this.context\n    });\n    this.output = new Gain({\n      context: this.context\n    }); // set if it's already loaded, set it immediately\n\n    if (this._buffer.loaded) {\n      this.buffer = this._buffer;\n    } // initially set normalization\n\n\n    this.normalize = options.normalize; // connect it up\n\n    this.input.chain(this._convolver, this.output);\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      normalize: true,\n      onload: noOp\n    });\n  }\n  /**\n   * Load an impulse response url as an audio buffer.\n   * Decodes the audio asynchronously and invokes\n   * the callback once the audio buffer loads.\n   * @param url The url of the buffer to load. filetype support depends on the browser.\n   */\n\n\n  load(url) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.buffer = yield this._buffer.load(url);\n    });\n  }\n  /**\n   * The convolver's buffer\n   */\n\n\n  get buffer() {\n    if (this._buffer.length) {\n      return this._buffer;\n    } else {\n      return null;\n    }\n  }\n\n  set buffer(buffer) {\n    if (buffer) {\n      this._buffer.set(buffer);\n    } // if it's already got a buffer, create a new one\n\n\n    if (this._convolver.buffer) {\n      // disconnect the old one\n      this.input.disconnect();\n\n      this._convolver.disconnect(); // create and connect a new one\n\n\n      this._convolver = this.context.createConvolver();\n      this.input.chain(this._convolver, this.output);\n    }\n\n    const buff = this._buffer.get();\n\n    this._convolver.buffer = buff ? buff : null;\n  }\n  /**\n   * The normalize property of the ConvolverNode interface is a boolean that\n   * controls whether the impulse response from the buffer will be scaled by\n   * an equal-power normalization when the buffer attribute is set, or not.\n   */\n\n\n  get normalize() {\n    return this._convolver.normalize;\n  }\n\n  set normalize(norm) {\n    this._convolver.normalize = norm;\n  }\n\n  dispose() {\n    super.dispose();\n\n    this._buffer.dispose();\n\n    this._convolver.disconnect();\n\n    return this;\n  }\n\n}","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer\";\nexport { start } from \"./core/Global\";\nexport { supported } from \"./core/context/AudioContext\";\n/**\n * The current audio context time of the global [[Context]].\n * See [[Context.now]]\n * @category Core\n */\n\nexport const now = getContext().now.bind(getContext());\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @category Core\n */\n\nexport const immediate = getContext().immediate.bind(getContext());\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\n\nexport const Transport = getContext().transport;\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\n\nexport const Destination = getContext().destination;\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\n\nexport const Listener = getContext().listener;\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * See [[Draw]]\n * @category Core\n */\n\nexport const Draw = getContext().draw;\n/**\n * A reference to the global context\n * See [[Context]]\n * @category Core\n */\n\nexport const context = getContext();\n/**\n * Promise which resolves when all of the loading promises are resolved.\n * Alias for static [[ToneAudioBuffer.loaded]] method.\n * @category Core\n */\n\nexport const loaded = ToneAudioBuffer.loaded.bind(ToneAudioBuffer); // this fills in name changes from 13.x to 14.x\n\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource\";\nexport const Buffer = ToneAudioBuffer;\nexport const Buffers = ToneAudioBuffers;\nexport const BufferSource = ToneBufferSource;","export const getValueForKey = (map, key) => {\n  const value = map.get(key);\n\n  if (value === undefined) {\n    throw new Error('A value with the given key could not be found.');\n  }\n\n  return value;\n};","export const createNotSupportedError = () => {\n  try {\n    return new DOMException('', 'NotSupportedError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 9;\n    err.name = 'NotSupportedError';\n    return err;\n  }\n};","export const interceptConnections = (original, interceptor) => {\n  original.connect = interceptor.connect.bind(interceptor);\n  original.disconnect = interceptor.disconnect.bind(interceptor);\n  return original;\n};","export const isNativeAudioNodeFaker = nativeAudioNodeOrNativeAudioNodeFaker => {\n  return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeConvolverNodeFakerFactory } from './factories/native-convolver-node-faker-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioDestinationNodeFactory } from './factories/native-media-stream-audio-destination-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './factories/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, CYCLE_COUNTERS } from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\n\nexport * from './interfaces/index';\nexport * from './types/index';\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst auxiliaryGainNodeStore = new WeakMap();\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst audioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);\nexport { analyserNodeConstructor as AnalyserNode };\nconst audioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nexport { audioBufferConstructor as AudioBuffer };\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createNativeConvolverNodeFaker = createNativeConvolverNodeFakerFactory(createNativeAudioNode, createNativeGainNode, monitorConnections);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext);\nconst createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst unrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, new WeakSet());\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window); // The addAudioWorkletModule() function is only available in a SecureContext.\n\nexport const addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(createNotSupportedError, createEvaluateSource(window), exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, getNativeContext, new WeakMap(), new WeakMap(), // @todo window is guaranteed to be defined because isSecureContext checks that as well.\nwindow) : undefined;\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, new WeakSet(), getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext); // The AudioWorkletNode constructor is only available in a SecureContext.\n\nconst audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) : undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor), createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelMergerNodeChannelCountSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);","export const testPromiseSupport = nativeContext => {\n  // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n  try {\n    // Bug #1: Safari requires a successCallback.\n    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {// Ignore the success callback.\n    });\n\n    if (promise === undefined) {\n      return false;\n    }\n\n    promise.catch(() => {// Ignore rejected errors.\n    });\n    return true;\n  } catch {// Ignore errors.\n  }\n\n  return false;\n};","export const createIndexSizeError = () => {\n  try {\n    return new DOMException('', 'IndexSizeError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 1;\n    err.name = 'IndexSizeError';\n    return err;\n  }\n};","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n  for (const lmnt of set) {\n    if (predicate(lmnt)) {\n      if (ignoreDuplicates) {\n        return false;\n      }\n\n      throw Error('The set contains at least one similar element.');\n    }\n  }\n\n  set.add(element);\n  return true;\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToActive = audioNode => {\n  if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error('The AudioNode is already stored.');\n  }\n\n  ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach(eventListener => eventListener(true));\n};","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) : (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, function (exports, _slicedToArray, _classCallCheck, _createClass) {\n  'use strict';\n\n  _slicedToArray = _slicedToArray && Object.prototype.hasOwnProperty.call(_slicedToArray, 'default') ? _slicedToArray['default'] : _slicedToArray;\n  _classCallCheck = _classCallCheck && Object.prototype.hasOwnProperty.call(_classCallCheck, 'default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && Object.prototype.hasOwnProperty.call(_createClass, 'default') ? _createClass['default'] : _createClass;\n\n  var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n\n  var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n    return {\n      endTime: endTime,\n      insertTime: insertTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n\n  var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n    return {\n      startTime: startTime,\n      type: 'setValue',\n      value: value\n    };\n  };\n\n  var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n    return {\n      duration: duration,\n      startTime: startTime,\n      type: 'setValueCurve',\n      values: values\n    };\n  };\n\n  var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n    var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n  };\n\n  var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'exponentialRampToValue';\n  };\n\n  var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'linearRampToValue';\n  };\n\n  var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n  };\n\n  var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValue';\n  };\n\n  var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setValueCurve';\n  };\n\n  var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n    var automationEvent = automationEvents[index];\n    return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n  };\n\n  var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n    return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n  };\n\n  var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelAndHold';\n  };\n\n  var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n    return automationEvent.type === 'cancelScheduledValues';\n  };\n\n  var getEventTime = function getEventTime(automationEvent) {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n      return automationEvent.cancelTime;\n    }\n\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n      return automationEvent.endTime;\n    }\n\n    return automationEvent.startTime;\n  };\n\n  var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n        value = _ref.value;\n\n    if (valueAtStartTime === value) {\n      return value;\n    }\n\n    if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n      return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n    }\n\n    return 0;\n  };\n\n  var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n    var endTime = _ref.endTime,\n        value = _ref.value;\n    return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n  };\n\n  var interpolateValue = function interpolateValue(values, theoreticIndex) {\n    var lowerIndex = Math.floor(theoreticIndex);\n    var upperIndex = Math.ceil(theoreticIndex);\n\n    if (lowerIndex === upperIndex) {\n      return values[lowerIndex];\n    }\n\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n  };\n\n  var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n    var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n    var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n    return interpolateValue(values, theoreticIndex);\n  };\n\n  var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n    return automationEvent.type === 'setTarget';\n  };\n\n  var AutomationEventList = /*#__PURE__*/function () {\n    function AutomationEventList(defaultValue) {\n      _classCallCheck(this, AutomationEventList);\n\n      this._automationEvents = [];\n      this._currenTime = 0;\n      this._defaultValue = defaultValue;\n    }\n\n    _createClass(AutomationEventList, [{\n      key: Symbol.iterator,\n      value: function value() {\n        return this._automationEvents[Symbol.iterator]();\n      }\n    }, {\n      key: \"add\",\n      value: function add(automationEvent) {\n        var eventTime = getEventTime(automationEvent);\n\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) >= eventTime;\n          });\n\n          var removedAutomationEvent = this._automationEvents[index];\n\n          if (index !== -1) {\n            this._automationEvents = this._automationEvents.slice(0, index);\n          }\n\n          if (isCancelAndHoldAutomationEvent(automationEvent)) {\n            var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n            if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n              if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                throw new Error('The internal list is malformed.');\n              }\n\n              var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n              var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n              var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n              var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n              this._automationEvents.push(truncatedAutomationEvent);\n            }\n\n            if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n              this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n            }\n\n            if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n              this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n            }\n          }\n        } else {\n          var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > eventTime;\n          });\n\n          var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n          if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n            return false;\n          }\n\n          var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n          if (_index === -1) {\n            this._automationEvents.push(persistentAutomationEvent);\n          } else {\n            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n              return false;\n            }\n\n            this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n          }\n        }\n\n        return true;\n      }\n    }, {\n      key: \"flush\",\n      value: function flush(time) {\n        var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n          return getEventTime(currentAutomationEvent) > time;\n        });\n\n        if (index > 1) {\n          var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n          var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n          if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n            remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n          }\n\n          this._automationEvents = remainingAutomationEvents;\n        }\n      }\n    }, {\n      key: \"getValue\",\n      value: function getValue(time) {\n        if (this._automationEvents.length === 0) {\n          return this._defaultValue;\n        }\n\n        var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n        var index = this._automationEvents.findIndex(function (automationEvent) {\n          return getEventTime(automationEvent) > time;\n        });\n\n        var nextAutomationEvent = this._automationEvents[index];\n        var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n        if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n          return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n        }\n\n        if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n\n        if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n          if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n            return getValueCurveValueAtTime(time, currentAutomationEvent);\n          }\n\n          return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n\n        if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n          return currentAutomationEvent.value;\n        }\n\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n\n          return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n          var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n\n          return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n        }\n\n        return this._defaultValue;\n      }\n    }]);\n\n    return AutomationEventList;\n  }();\n\n  var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelAndHold'\n    };\n  };\n\n  var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n    return {\n      cancelTime: cancelTime,\n      type: 'cancelScheduledValues'\n    };\n  };\n\n  var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'exponentialRampToValue',\n      value: value\n    };\n  };\n\n  var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n    return {\n      endTime: endTime,\n      type: 'linearRampToValue',\n      value: value\n    };\n  };\n\n  var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n    return {\n      startTime: startTime,\n      target: target,\n      timeConstant: timeConstant,\n      type: 'setTarget'\n    };\n  };\n\n  exports.AutomationEventList = AutomationEventList;\n  exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n  exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n  exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n  exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n  exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n  exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n  exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","import { CYCLE_COUNTERS } from '../globals';\nexport const isPartOfACycle = audioNode => {\n  return CYCLE_COUNTERS.has(audioNode);\n};","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = audioNode => {\n  return getValueForKey(EVENT_LISTENERS, audioNode);\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalStateToPassive = audioNode => {\n  if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error('The AudioNode is not stored.');\n  }\n\n  ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach(eventListener => eventListener(false));\n};","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = outputConnection => {\n  return isAudioNode(outputConnection[0]);\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = audioNode => ACTIVE_AUDIO_NODE_STORE.has(audioNode);","export const isAudioNode = audioNodeOrAudioParam => {\n  return 'context' in audioNodeOrAudioParam;\n};","export const isNativeAudioNode = nativeAudioNodeOrAudioParam => {\n  return 'context' in nativeAudioNodeOrAudioParam;\n};","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioParamConnections = audioParam => {\n  return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = audioParam => {\n  return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};","export const wrapEventListener = (target, eventListener) => {\n  return event => {\n    const descriptor = {\n      value: target\n    };\n    Object.defineProperties(event, {\n      currentTarget: descriptor,\n      target: descriptor\n    });\n\n    if (typeof eventListener === 'function') {\n      return eventListener.call(target, event);\n    }\n\n    return eventListener.handleEvent.call(target, event);\n  };\n};","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = audioBuffer => {\n  audioBuffer.getChannelData = (getChannelData => {\n    return channel => {\n      try {\n        return getChannelData.call(audioBuffer, channel);\n      } catch (err) {\n        if (err.code === 12) {\n          throw createIndexSizeError();\n        }\n\n        throw err;\n      }\n    };\n  })(audioBuffer.getChannelData);\n};","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = nativeAudioScheduledSourceNode => {\n  nativeAudioScheduledSourceNode.start = (start => {\n    return (when = 0, offset = 0, duration) => {\n      if (typeof duration === 'number' && duration < 0 || offset < 0 || when < 0) {\n        throw new RangeError(\"The parameters can't be negative.\");\n      } // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n\n\n      start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n    };\n  })(nativeAudioScheduledSourceNode.start);\n};","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = nativeAudioScheduledSourceNode => {\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      if (when < 0) {\n        throw new RangeError(\"The parameter can't be negative.\");\n      }\n\n      stop.call(nativeAudioScheduledSourceNode, when);\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = nativeAudioBuffer => {\n  try {\n    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n  } catch {\n    return false;\n  }\n\n  return true;\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n    return [fakeNativeDestinationAudioNode, output, 0];\n  }\n\n  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n  return [nativeDestinationAudioNode, output, input];\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nexport const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n  } else {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n  }\n};","export function copyFromChannel(audioBuffer, // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n  if (typeof audioBuffer.copyFromChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength === 0) {\n      parent[key] = new Float32Array(128);\n    }\n\n    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset); // Bug #5: Safari does not support copyFromChannel().\n  } else {\n    const channelData = audioBuffer.getChannelData(channelNumber); // The byteLength will be 0 when the ArrayBuffer was transferred.\n\n    if (parent[key].byteLength === 0) {\n      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n    } else {\n      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n      parent[key].set(slicedInput);\n    }\n  }\n}","export const createNestedArrays = (x, y) => {\n  const arrays = [];\n\n  for (let i = 0; i < x; i += 1) {\n    const array = [];\n    const length = typeof y === 'number' ? y : y[i];\n\n    for (let j = 0; j < length; j += 1) {\n      array.push(new Float32Array(128));\n    }\n\n    arrays.push(array);\n  }\n\n  return arrays;\n};","export const createInvalidAccessError = () => {\n  try {\n    return new DOMException('', 'InvalidAccessError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 15;\n    err.name = 'InvalidAccessError';\n    return err;\n  }\n};","export const overwriteAccessors = (object, property, createGetter, createSetter) => {\n  let prototype = Object.getPrototypeOf(object);\n\n  while (!prototype.hasOwnProperty(property)) {\n    prototype = Object.getPrototypeOf(prototype);\n  }\n\n  const {\n    get,\n    set\n  } = Object.getOwnPropertyDescriptor(prototype, property);\n  Object.defineProperty(object, property, {\n    get: createGetter(get),\n    set: createSetter(set)\n  });\n};","export const isValidLatencyHint = latencyHint => {\n  return latencyHint === undefined || typeof latencyHint === 'number' || typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback');\n};","export class ReadOnlyMap {\n  constructor(parameters) {\n    this._map = new Map(parameters);\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  forEach(callback, thisArg = null) {\n    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n  }\n\n  get(name) {\n    return this._map.get(name);\n  }\n\n  has(name) {\n    return this._map.has(name);\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n}","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n  if (typeof audioBuffer.copyToChannel === 'function') {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n    } // Bug #5: Safari does not support copyToChannel().\n\n  } else {\n    // The byteLength will be 0 when the ArrayBuffer was transferred.\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n    }\n  }\n};","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n  const inputLength = input.length;\n  let i = bufferIndex;\n\n  for (let j = 0; j < inputLength; j += 1) {\n    let y = feedforward[0] * input[j];\n\n    for (let k = 1; k < minLength; k += 1) {\n      const x = i - k & bufferLength - 1; // tslint:disable-line:no-bitwise\n\n      y += feedforward[k] * xBuffer[x];\n      y -= feedback[k] * yBuffer[x];\n    }\n\n    for (let k = minLength; k < feedforwardLength; k += 1) {\n      y += feedforward[k] * xBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n    }\n\n    for (let k = minLength; k < feedbackLength; k += 1) {\n      y -= feedback[k] * yBuffer[i - k & bufferLength - 1]; // tslint:disable-line:no-bitwise\n    }\n\n    xBuffer[i] = input[j];\n    yBuffer[i] = y;\n    i = i + 1 & bufferLength - 1; // tslint:disable-line:no-bitwise\n\n    output[j] = y;\n  }\n\n  return i;\n};","export const computeBufferSize = (baseLatency, sampleRate) => {\n  if (baseLatency === null) {\n    return 512;\n  }\n\n  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};","export const createUnknownError = () => {\n  try {\n    return new DOMException('', 'UnknownError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.name = 'UnknownError';\n    return err;\n  }\n};","export const isDCCurve = curve => {\n  if (curve === null) {\n    return false;\n  }\n\n  const length = curve.length;\n\n  if (length % 2 !== 0) {\n    return curve[Math.floor(length / 2)] !== 0;\n  }\n\n  return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};","export * from './analyser-node';\nexport * from './analyser-options';\nexport * from './audio-buffer';\nexport * from './audio-buffer-options';\nexport * from './audio-buffer-source-node';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-options';\nexport * from './audio-context';\nexport * from './audio-context-options';\nexport * from './audio-destination-node';\nexport * from './audio-listener';\nexport * from './audio-node';\nexport * from './audio-node-options';\nexport * from './audio-node-renderer';\nexport * from './audio-param';\nexport * from './audio-param-descriptor';\nexport * from './audio-param-renderer';\nexport * from './audio-scheduled-source-node';\nexport * from './audio-scheduled-source-node-event-map';\nexport * from './audio-worklet';\nexport * from './audio-worklet-node';\nexport * from './audio-worklet-node-event-map';\nexport * from './audio-worklet-node-options';\nexport * from './audio-worklet-processor';\nexport * from './audio-worklet-processor-constructor';\nexport * from './automation';\nexport * from './base-audio-context';\nexport * from './biquad-filter-node';\nexport * from './biquad-filter-options';\nexport * from './channel-merger-options';\nexport * from './channel-splitter-options';\nexport * from './common-audio-context';\nexport * from './common-offline-audio-context';\nexport * from './constant-source-node';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-options';\nexport * from './convolver-node';\nexport * from './convolver-options';\nexport * from './delay-node';\nexport * from './delay-options';\nexport * from './dynamics-compressor-node';\nexport * from './dynamics-compressor-options';\nexport * from './gain-node';\nexport * from './gain-options';\nexport * from './iir-filter-node';\nexport * from './iir-filter-options';\nexport * from './media-element-audio-source-node';\nexport * from './media-element-audio-source-options';\nexport * from './media-stream-audio-destination-node';\nexport * from './media-stream-audio-source-node';\nexport * from './media-stream-audio-source-options';\nexport * from './media-stream-track-audio-source-node';\nexport * from './media-stream-track-audio-source-options';\nexport * from './minimal-audio-context';\nexport * from './minimal-base-audio-context';\nexport * from './minimal-base-audio-context-event-map';\nexport * from './minimal-offline-audio-context';\nexport * from './native-audio-node-faker';\nexport * from './native-audio-worklet-node-faker';\nexport * from './native-constant-source-node-faker';\nexport * from './native-convolver-node-faker';\nexport * from './native-iir-filter-node-faker';\nexport * from './native-panner-node-faker';\nexport * from './native-stereo-panner-node-faker';\nexport * from './native-wave-shaper-node-faker';\nexport * from './offline-audio-completion-event';\nexport * from './offline-audio-context';\nexport * from './offline-audio-context-constructor';\nexport * from './offline-audio-context-options';\nexport * from './oscillator-node';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-options';\nexport * from './panner-node';\nexport * from './panner-options';\nexport * from './periodic-wave';\nexport * from './periodic-wave-constraints';\nexport * from './periodic-wave-options';\nexport * from './read-only-map';\nexport * from './stereo-panner-node';\nexport * from './stereo-panner-options';\nexport * from './wave-shaper-node';\nexport * from './wave-shaper-options';\nexport * from './worklet-options';","export * from './abort-error-factory';\nexport * from './active-input-connection';\nexport * from './add-audio-node-connections-factory';\nexport * from './add-audio-node-connections-function';\nexport * from './add-audio-param-connections-factory';\nexport * from './add-audio-param-connections-function';\nexport * from './add-audio-worklet-module-factory';\nexport * from './add-audio-worklet-module-function';\nexport * from './add-silent-connection-factory';\nexport * from './add-silent-connection-function';\nexport * from './add-unrendered-audio-worklet-node-factory';\nexport * from './add-unrendered-audio-worklet-node-function';\nexport * from './analyser-node-constructor';\nexport * from './analyser-node-constructor-factory';\nexport * from './analyser-node-renderer-factory';\nexport * from './analyser-node-renderer-factory-factory';\nexport * from './any-audio-buffer';\nexport * from './any-context';\nexport * from './audio-buffer-constructor';\nexport * from './audio-buffer-constructor-factory';\nexport * from './audio-buffer-source-node-constructor';\nexport * from './audio-buffer-source-node-constructor-factory';\nexport * from './audio-buffer-source-node-renderer';\nexport * from './audio-buffer-source-node-renderer-factory';\nexport * from './audio-buffer-source-node-renderer-factory-factory';\nexport * from './audio-buffer-store';\nexport * from './audio-context-constructor';\nexport * from './audio-context-constructor-factory';\nexport * from './audio-context-latency-category';\nexport * from './audio-context-state';\nexport * from './audio-destination-node-constructor';\nexport * from './audio-destination-node-constructor-factory';\nexport * from './audio-destination-node-renderer-factory';\nexport * from './audio-listener-factory';\nexport * from './audio-listener-factory-factory';\nexport * from './audio-node-connections';\nexport * from './audio-node-connections-store';\nexport * from './audio-node-constructor';\nexport * from './audio-node-constructor-factory';\nexport * from './audio-node-output-connection';\nexport * from './audio-node-renderer';\nexport * from './audio-node-store';\nexport * from './audio-param-audio-node-store';\nexport * from './audio-param-connections';\nexport * from './audio-param-connections-store';\nexport * from './audio-param-factory';\nexport * from './audio-param-factory-factory';\nexport * from './audio-param-map';\nexport * from './audio-param-output-connection';\nexport * from './audio-param-renderer-factory';\nexport * from './audio-param-store';\nexport * from './audio-worklet-node-constructor';\nexport * from './audio-worklet-node-constructor-factory';\nexport * from './audio-worklet-node-renderer-factory';\nexport * from './audio-worklet-node-renderer-factory-factory';\nexport * from './auxiliary-gain-node-store';\nexport * from './base-audio-context-constructor';\nexport * from './base-audio-context-constructor-factory';\nexport * from './biquad-filter-node-constructor';\nexport * from './biquad-filter-node-constructor-factory';\nexport * from './biquad-filter-node-renderer-factory';\nexport * from './biquad-filter-node-renderer-factory-factory';\nexport * from './biquad-filter-type';\nexport * from './channel-count-mode';\nexport * from './channel-interpretation';\nexport * from './channel-merger-node-constructor';\nexport * from './channel-merger-node-constructor-factory';\nexport * from './channel-merger-node-renderer-factory';\nexport * from './channel-merger-node-renderer-factory-factory';\nexport * from './channel-splitter-node-constructor';\nexport * from './channel-splitter-node-constructor-factory';\nexport * from './channel-splitter-node-renderer-factory';\nexport * from './channel-splitter-node-renderer-factory-factory';\nexport * from './cache-test-result-factory';\nexport * from './cache-test-result-function';\nexport * from './connect-audio-param-factory';\nexport * from './connect-audio-param-function';\nexport * from './connect-multiple-outputs-factory';\nexport * from './connect-multiple-outputs-function';\nexport * from './connect-native-audio-node-to-native-audio-node-function';\nexport * from './connected-native-audio-buffer-source-node-factory';\nexport * from './connected-native-audio-buffer-source-node-factory-factory';\nexport * from './constant-source-node-constructor';\nexport * from './constant-source-node-constructor-factory';\nexport * from './constant-source-node-renderer';\nexport * from './constant-source-node-renderer-factory';\nexport * from './constant-source-node-renderer-factory-factory';\nexport * from './constructor';\nexport * from './context';\nexport * from './context-store';\nexport * from './convert-number-to-unsigned-long-factory';\nexport * from './convert-number-to-unsigned-long-function';\nexport * from './convolver-node-constructor';\nexport * from './convolver-node-constructor-factory';\nexport * from './convolver-node-renderer-factory';\nexport * from './convolver-node-renderer-factory-factory';\nexport * from './create-native-offline-audio-context-factory';\nexport * from './create-native-offline-audio-context-function';\nexport * from './cycle-counters';\nexport * from './data-clone-error-factory';\nexport * from './decode-audio-data-factory';\nexport * from './decode-audio-data-function';\nexport * from './decode-error-callback';\nexport * from './decode-success-callback';\nexport * from './decrement-cycle-counter-factory';\nexport * from './decrement-cycle-counter-function';\nexport * from './delay-node-constructor';\nexport * from './delay-node-constructor-factory';\nexport * from './delay-node-renderer-factory';\nexport * from './delay-node-renderer-factory-factory';\nexport * from './delete-unrendered-audio-worklet-node-factory';\nexport * from './delete-unrendered-audio-worklet-node-function';\nexport * from './detect-cycles-factory';\nexport * from './detect-cycles-function';\nexport * from './disconnect-multiple-outputs-factory';\nexport * from './disconnect-multiple-outputs-function';\nexport * from './disconnect-native-audio-node-from-native-audio-node-function';\nexport * from './distance-model-type';\nexport * from './dynamics-compressor-node-constructor';\nexport * from './dynamics-compressor-node-constructor-factory';\nexport * from './dynamics-compressor-node-renderer-factory';\nexport * from './dynamics-compressor-node-renderer-factory-factory';\nexport * from './encoding-error-factory';\nexport * from './error-event-handler';\nexport * from './evaluate-audio-worklet-global-scope-function';\nexport * from './evaluate-source-factory';\nexport * from './evaluate-source-function';\nexport * from './event-handler';\nexport * from './event-target-constructor';\nexport * from './event-target-constructor-factory';\nexport * from './expose-current-frame-and-current-time-factory';\nexport * from './expose-current-frame-and-current-time-function';\nexport * from './fetch-source-factory';\nexport * from './fetch-source-function';\nexport * from './gain-node-constructor';\nexport * from './gain-node-constructor-factory';\nexport * from './gain-node-renderer-factory';\nexport * from './gain-node-renderer-factory-factory';\nexport * from './get-audio-node-connections-function';\nexport * from './get-audio-node-renderer-factory';\nexport * from './get-audio-node-renderer-function';\nexport * from './get-audio-param-connections-function';\nexport * from './get-audio-param-renderer-factory';\nexport * from './get-audio-param-renderer-function';\nexport * from './get-backup-native-context-factory';\nexport * from './get-backup-native-context-function';\nexport * from './get-native-audio-node-function';\nexport * from './get-native-audio-param-function';\nexport * from './get-native-context-function';\nexport * from './get-native-context-factory';\nexport * from './get-unrendered-audio-worklet-nodes-factory';\nexport * from './get-unrendered-audio-worklet-nodes-function';\nexport * from './get-value-for-key-function';\nexport * from './iir-filter-node-constructor';\nexport * from './iir-filter-node-constructor-factory';\nexport * from './iir-filter-node-renderer-factory';\nexport * from './iir-filter-node-renderer-factory-factory';\nexport * from './increment-cycle-counter-factory';\nexport * from './increment-cycle-counter-factory-factory';\nexport * from './increment-cycle-counter-function';\nexport * from './index-size-error-factory';\nexport * from './insert-element-in-set-function';\nexport * from './internal-state-event-listener';\nexport * from './invalid-access-error-factory';\nexport * from './invalid-state-error-factory';\nexport * from './is-active-audio-node-function';\nexport * from './is-any-audio-context-factory';\nexport * from './is-any-audio-context-function';\nexport * from './is-any-audio-node-factory';\nexport * from './is-any-audio-node-function';\nexport * from './is-any-audio-param-factory';\nexport * from './is-any-audio-param-function';\nexport * from './is-any-offline-audio-context-factory';\nexport * from './is-any-offline-audio-context-function';\nexport * from './is-dc-curve-function';\nexport * from './is-native-audio-context-factory';\nexport * from './is-native-audio-context-function';\nexport * from './is-native-audio-node-factory';\nexport * from './is-native-audio-node-function';\nexport * from './is-native-audio-param-factory';\nexport * from './is-native-audio-param-function';\nexport * from './is-native-context-factory';\nexport * from './is-native-context-function';\nexport * from './is-native-offline-audio-context-factory';\nexport * from './is-native-offline-audio-context-function';\nexport * from './is-part-of-a-cycle-function';\nexport * from './is-secure-context-factory';\nexport * from './is-supported-promise-factory';\nexport * from './media-element-audio-source-node-constructor';\nexport * from './media-element-audio-source-node-constructor-factory';\nexport * from './media-stream-audio-destination-node-constructor';\nexport * from './media-stream-audio-destination-node-constructor-factory';\nexport * from './media-stream-audio-source-node-constructor';\nexport * from './media-stream-audio-source-node-constructor-factory';\nexport * from './media-stream-track-audio-source-node-constructor';\nexport * from './media-stream-track-audio-source-node-constructor-factory';\nexport * from './minimal-audio-context-constructor';\nexport * from './minimal-audio-context-constructor-factory';\nexport * from './minimal-base-audio-context-constructor';\nexport * from './minimal-base-audio-context-constructor-factory';\nexport * from './minimal-offline-audio-context-constructor';\nexport * from './minimal-offline-audio-context-constructor-factory';\nexport * from './monitor-connections-factory';\nexport * from './monitor-connections-function';\nexport * from './native-analyser-node';\nexport * from './native-analyser-node-factory';\nexport * from './native-analyser-node-factory-factory';\nexport * from './native-audio-buffer';\nexport * from './native-audio-buffer-constructor';\nexport * from './native-audio-buffer-constructor-factory';\nexport * from './native-audio-buffer-source-node';\nexport * from './native-audio-buffer-source-node-factory';\nexport * from './native-audio-buffer-source-node-factory-factory';\nexport * from './native-audio-context';\nexport * from './native-audio-context-constructor';\nexport * from './native-audio-context-constructor-factory';\nexport * from './native-audio-destination-node';\nexport * from './native-audio-destination-node-factory';\nexport * from './native-audio-destination-node-factory-factory';\nexport * from './native-audio-listener';\nexport * from './native-audio-node';\nexport * from './native-audio-node-factory';\nexport * from './native-audio-node-factory-factory';\nexport * from './native-audio-param';\nexport * from './native-audio-param-map';\nexport * from './native-audio-worklet';\nexport * from './native-audio-worklet-node';\nexport * from './native-audio-worklet-node-constructor';\nexport * from './native-audio-worklet-node-constructor-factory';\nexport * from './native-audio-worklet-node-factory';\nexport * from './native-audio-worklet-node-factory-factory';\nexport * from './native-audio-worklet-node-faker-factory';\nexport * from './native-audio-worklet-node-faker-factory-factory';\nexport * from './native-audio-worklet-node-options';\nexport * from './native-biquad-filter-node';\nexport * from './native-biquad-filter-node-factory';\nexport * from './native-biquad-filter-node-factory-factory';\nexport * from './native-channel-merger-node';\nexport * from './native-channel-merger-node-factory';\nexport * from './native-channel-merger-node-factory-factory';\nexport * from './native-channel-splitter-node';\nexport * from './native-channel-splitter-node-factory';\nexport * from './native-channel-splitter-node-factory-factory';\nexport * from './native-constant-source-node';\nexport * from './native-constant-source-node-factory';\nexport * from './native-constant-source-node-factory-factory';\nexport * from './native-constant-source-node-faker-factory';\nexport * from './native-constant-source-node-faker-factory-factory';\nexport * from './native-context';\nexport * from './native-convolver-node';\nexport * from './native-convolver-node-factory';\nexport * from './native-convolver-node-factory-factory';\nexport * from './native-convolver-node-faker-factory';\nexport * from './native-convolver-node-faker-factory-factory';\nexport * from './native-delay-node-factory';\nexport * from './native-delay-node-factory-factory';\nexport * from './native-delay-node';\nexport * from './native-dynamics-compressor-node';\nexport * from './native-dynamics-compressor-node-factory';\nexport * from './native-dynamics-compressor-node-factory-factory';\nexport * from './native-event-target';\nexport * from './native-gain-node';\nexport * from './native-gain-node-factory';\nexport * from './native-gain-node-factory-factory';\nexport * from './native-iir-filter-node';\nexport * from './native-iir-filter-node-factory';\nexport * from './native-iir-filter-node-factory-factory';\nexport * from './native-iir-filter-node-faker-factory';\nexport * from './native-iir-filter-node-faker-factory-factory';\nexport * from './native-media-element-audio-source-node';\nexport * from './native-media-element-audio-source-node-factory';\nexport * from './native-media-element-audio-source-node-factory-factory';\nexport * from './native-media-stream-audio-destination-node';\nexport * from './native-media-stream-audio-destination-node-factory';\nexport * from './native-media-stream-audio-destination-node-factory-factory';\nexport * from './native-media-stream-audio-source-node';\nexport * from './native-media-stream-audio-source-node-factory';\nexport * from './native-media-stream-audio-source-node-factory-factory';\nexport * from './native-media-stream-track-audio-source-node';\nexport * from './native-media-stream-track-audio-source-node-factory';\nexport * from './native-media-stream-track-audio-source-node-factory-factory';\nexport * from './native-offline-audio-context';\nexport * from './native-offline-audio-context-constructor';\nexport * from './native-offline-audio-context-constructor-factory';\nexport * from './native-oscillator-node';\nexport * from './native-oscillator-node-factory';\nexport * from './native-oscillator-node-factory-factory';\nexport * from './native-panner-node';\nexport * from './native-panner-node-factory';\nexport * from './native-panner-node-factory-factory';\nexport * from './native-panner-node-faker-factory';\nexport * from './native-panner-node-faker-factory-factory';\nexport * from './native-periodic-wave';\nexport * from './native-periodic-wave-factory';\nexport * from './native-periodic-wave-factory-factory';\nexport * from './native-script-processor-node';\nexport * from './native-script-processor-node-factory';\nexport * from './native-script-processor-node-factory-factory';\nexport * from './native-stereo-panner-node';\nexport * from './native-stereo-panner-node-factory';\nexport * from './native-stereo-panner-node-factory-factory';\nexport * from './native-stereo-panner-node-faker-factory';\nexport * from './native-stereo-panner-node-faker-factory-factory';\nexport * from './native-wave-shaper-node';\nexport * from './native-wave-shaper-node-factory';\nexport * from './native-wave-shaper-node-factory-factory';\nexport * from './native-wave-shaper-node-faker-factory';\nexport * from './native-wave-shaper-node-faker-factory-factory';\nexport * from './not-supported-error-factory';\nexport * from './offline-audio-context-constructor-factory';\nexport * from './oscillator-node-constructor';\nexport * from './oscillator-node-constructor-factory';\nexport * from './oscillator-node-renderer';\nexport * from './oscillator-node-renderer-factory';\nexport * from './oscillator-node-renderer-factory-factory';\nexport * from './oscillator-type';\nexport * from './output-connection';\nexport * from './over-sample-type';\nexport * from './overwrite-accessors-function';\nexport * from './panner-node-constructor';\nexport * from './panner-node-constructor-factory';\nexport * from './panner-node-renderer-factory';\nexport * from './panner-node-renderer-factory-factory';\nexport * from './panning-model-type';\nexport * from './passive-audio-node-input-connection';\nexport * from './passive-audio-param-input-connection';\nexport * from './periodic-wave-constructor';\nexport * from './periodic-wave-constructor-factory';\nexport * from './render-automation-factory';\nexport * from './render-automation-function';\nexport * from './render-inputs-of-audio-node-factory';\nexport * from './render-inputs-of-audio-node-function';\nexport * from './render-inputs-of-audio-param-factory';\nexport * from './render-inputs-of-audio-param-function';\nexport * from './render-native-offline-audio-context-factory';\nexport * from './render-native-offline-audio-context-function';\nexport * from './start-rendering-factory';\nexport * from './start-rendering-function';\nexport * from './stereo-panner-node-constructor';\nexport * from './stereo-panner-node-constructor-factory';\nexport * from './stereo-panner-node-renderer-factory-factory';\nexport * from './stereo-panner-node-renderer-factory';\nexport * from './test-audio-buffer-copy-channel-methods-subarray-support-factory';\nexport * from './test-audio-buffer-constructor-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-duration-parameter-support-factory';\nexport * from './test-audio-buffer-source-node-start-method-offset-clamping-support-factory';\nexport * from './test-audio-buffer-source-node-stop-method-nullified-buffer-support-factory';\nexport * from './test-audio-context-close-method-support-factory';\nexport * from './test-audio-context-decode-audio-data-method-type-error-support-factory';\nexport * from './test-audio-context-options-support-factory';\nexport * from './test-audio-node-connect-method-support-factory';\nexport * from './test-audio-scheduled-source-node-start-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-consecutive-calls-support-factory';\nexport * from './test-audio-scheduled-source-node-stop-method-negative-parameters-support-factory';\nexport * from './test-audio-worklet-processor-no-outputs-support-factory';\nexport * from './test-channel-merger-node-channel-count-support-factory';\nexport * from './test-constant-source-node-accurate-scheduling-support-factory';\nexport * from './test-convolver-node-buffer-reassignability-support-factory';\nexport * from './test-is-secure-context-support-factory';\nexport * from './test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nexport * from './test-offline-audio-context-current-time-support-factory';\nexport * from './test-stereo-panner-node-default-value-support-factory';\nexport * from './typed-array';\nexport * from './unknown-error-factory';\nexport * from './unrendered-audio-worklet-node-store';\nexport * from './unrendered-audio-worklet-nodes';\nexport * from './wave-shaper-node-constructor';\nexport * from './wave-shaper-node-constructor-factory';\nexport * from './wave-shaper-node-renderer-factory-factory';\nexport * from './wave-shaper-node-renderer-factory';\nexport * from './window-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-function';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory';\nexport * from './wrap-audio-buffer-copy-channel-methods-out-of-bounds-function';\nexport * from './wrap-audio-buffer-source-node-start-method-offset-clamping-function';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory';\nexport * from './wrap-audio-buffer-source-node-stop-method-nullified-buffer-function';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-factory';\nexport * from './wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function';\nexport * from './wrap-channel-merger-node-factory';\nexport * from './wrap-channel-merger-node-function';\nexport * from './wrap-event-listener-function';","export const createAbortError = () => {\n  try {\n    return new DOMException('', 'AbortError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 20;\n    err.name = 'AbortError';\n    return err;\n  }\n};","export const createAddAudioNodeConnections = audioNodeConnectionsStore => {\n  return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n    const activeInputs = [];\n\n    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n      activeInputs.push(new Set());\n    }\n\n    audioNodeConnectionsStore.set(audioNode, {\n      activeInputs,\n      outputs: new Set(),\n      passiveInputs: new WeakMap(),\n      renderer: audioNodeRenderer\n    });\n  };\n};","export const createAddAudioParamConnections = audioParamConnectionsStore => {\n  return (audioParam, audioParamRenderer) => {\n    audioParamConnectionsStore.set(audioParam, {\n      activeInputs: new Set(),\n      passiveInputs: new WeakMap(),\n      renderer: audioParamRenderer\n    });\n  };\n};","export const createAddSilentConnection = createNativeGainNode => {\n  return (nativeContext, nativeAudioScheduledSourceNode) => {\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n    nativeAudioScheduledSourceNode.connect(nativeGainNode)\n    /*\n     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n     * used here to make sure to connect the right destination.\n     */\n    .connect(nativeGainNode.context.destination);\n\n    const disconnect = () => {\n      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n  };\n};","export const createAddUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  fftSize: 2048,\n  maxDecibels: -30,\n  minDecibels: -100,\n  smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class AnalyserNode extends audionNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n      const analyserNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null;\n      super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n      this._nativeAnalyserNode = nativeAnalyserNode;\n    }\n\n    get fftSize() {\n      return this._nativeAnalyserNode.fftSize;\n    }\n\n    set fftSize(value) {\n      this._nativeAnalyserNode.fftSize = value;\n    }\n\n    get frequencyBinCount() {\n      return this._nativeAnalyserNode.frequencyBinCount;\n    }\n\n    get maxDecibels() {\n      return this._nativeAnalyserNode.maxDecibels;\n    }\n\n    set maxDecibels(value) {\n      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n      const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n      this._nativeAnalyserNode.maxDecibels = value;\n\n      if (!(value > this._nativeAnalyserNode.minDecibels)) {\n        this._nativeAnalyserNode.maxDecibels = maxDecibels;\n        throw createIndexSizeError();\n      }\n    }\n\n    get minDecibels() {\n      return this._nativeAnalyserNode.minDecibels;\n    }\n\n    set minDecibels(value) {\n      // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n      const minDecibels = this._nativeAnalyserNode.minDecibels;\n      this._nativeAnalyserNode.minDecibels = value;\n\n      if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n        this._nativeAnalyserNode.minDecibels = minDecibels;\n        throw createIndexSizeError();\n      }\n    }\n\n    get smoothingTimeConstant() {\n      return this._nativeAnalyserNode.smoothingTimeConstant;\n    }\n\n    set smoothingTimeConstant(value) {\n      this._nativeAnalyserNode.smoothingTimeConstant = value;\n    }\n\n    getByteFrequencyData(array) {\n      this._nativeAnalyserNode.getByteFrequencyData(array);\n    }\n\n    getByteTimeDomainData(array) {\n      this._nativeAnalyserNode.getByteTimeDomainData(array);\n    }\n\n    getFloatFrequencyData(array) {\n      this._nativeAnalyserNode.getFloatFrequencyData(array);\n    }\n\n    getFloatTimeDomainData(array) {\n      this._nativeAnalyserNode.getFloatTimeDomainData(array);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAnalyserNodes = new WeakMap();\n\n    const createAnalyserNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAnalyserNode = getNativeAudioNode(proxy); // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n      if (!nativeAnalyserNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAnalyserNode.channelCount,\n          channelCountMode: nativeAnalyserNode.channelCountMode,\n          channelInterpretation: nativeAnalyserNode.channelInterpretation,\n          fftSize: nativeAnalyserNode.fftSize,\n          maxDecibels: nativeAnalyserNode.maxDecibels,\n          minDecibels: nativeAnalyserNode.minDecibels,\n          smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n        };\n        nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode, trace);\n      return nativeAnalyserNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAnalyserNode !== undefined) {\n          return Promise.resolve(renderedNativeAnalyserNode);\n        }\n\n        return createAnalyserNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  let nativeOfflineAudioContext = null;\n  return class AudioBuffer {\n    constructor(options) {\n      if (nativeOfflineAudioContextConstructor === null) {\n        throw new Error('Missing the native OfflineAudioContext constructor.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n      }\n      /*\n       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n       * factory function. But since Firefox also supports the constructor everything should be fine.\n       */\n\n\n      const audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n        length,\n        numberOfChannels,\n        sampleRate\n      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError();\n      } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n\n\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n\n      audioBufferStore.add(audioBuffer);\n      /*\n       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n       * (Offline)AudioContexts.\n       */\n\n      return audioBuffer;\n    }\n\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class AudioBufferSourceNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n      super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      this._isBufferNullified = false;\n      this._isBufferSet = options.buffer !== null && options.buffer !== undefined;\n      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      this._onended = null; // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n\n      return this._nativeAudioBufferSourceNode.buffer;\n    }\n\n    set buffer(value) {\n      // Bug #71: Edge does not allow to set the buffer to null.\n      try {\n        this._nativeAudioBufferSourceNode.buffer = value;\n      } catch (err) {\n        if (value !== null || err.code !== 17) {\n          throw err;\n        } // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n\n\n        if (this._nativeAudioBufferSourceNode.buffer !== null) {\n          const buffer = this._nativeAudioBufferSourceNode.buffer;\n          const numberOfChannels = buffer.numberOfChannels;\n\n          for (let i = 0; i < numberOfChannels; i += 1) {\n            buffer.getChannelData(i).fill(0);\n          }\n\n          this._isBufferNullified = true;\n        }\n      } // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n\n\n      if (value !== null) {\n        if (this._isBufferSet) {\n          throw createInvalidStateError();\n        }\n\n        this._isBufferSet = true;\n      }\n    }\n\n    get loop() {\n      return this._nativeAudioBufferSourceNode.loop;\n    }\n\n    set loop(value) {\n      this._nativeAudioBufferSourceNode.loop = value;\n    }\n\n    get loopEnd() {\n      return this._nativeAudioBufferSourceNode.loopEnd;\n    }\n\n    set loopEnd(value) {\n      this._nativeAudioBufferSourceNode.loopEnd = value;\n    }\n\n    get loopStart() {\n      return this._nativeAudioBufferSourceNode.loopStart;\n    }\n\n    set loopStart(value) {\n      this._nativeAudioBufferSourceNode.loopStart = value;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioBufferSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    get playbackRate() {\n      return this._playbackRate;\n    }\n\n    start(when = 0, offset = 0, duration) {\n      this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeAudioBufferSourceNode.stop(when);\n\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createAudioBufferSourceNodeRendererFactory = (connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioBufferSourceNodes = new WeakMap();\n    let start = null;\n    let stop = null;\n\n    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        const options = {\n          buffer: nativeAudioBufferSourceNode.buffer,\n          channelCount: nativeAudioBufferSourceNode.channelCount,\n          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n          // Bug #149: Safari does not yet support the detune AudioParam.\n          loop: nativeAudioBufferSourceNode.loop,\n          loopEnd: nativeAudioBufferSourceNode.loopEnd,\n          loopStart: nativeAudioBufferSourceNode.loopStart,\n          playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n        };\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeAudioBufferSourceNode.start(...start);\n        }\n\n        if (stop !== null) {\n          nativeAudioBufferSourceNode.stop(stop);\n        }\n      }\n\n      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n      } else {\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode, trace);\n      return nativeAudioBufferSourceNode;\n    };\n\n    return {\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioBufferSourceNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioBufferSourceNode);\n        }\n\n        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n  return class AudioContext extends baseAudioContextConstructor {\n    constructor(options = {}) {\n      if (nativeAudioContextConstructor === null) {\n        throw new Error('Missing the native AudioContext constructor.');\n      }\n\n      const nativeAudioContext = new nativeAudioContextConstructor(options); // Bug #131 Safari returns null when there are four other AudioContexts running already.\n\n      if (nativeAudioContext === null) {\n        throw createUnknownError();\n      } // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n\n\n      if (!isValidLatencyHint(options.latencyHint)) {\n        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n      } // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n\n\n      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n        throw createNotSupportedError();\n      }\n\n      super(nativeAudioContext, 2);\n      const {\n        latencyHint\n      } = options;\n      const {\n        sampleRate\n      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n\n      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n      /*\n       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n       * ScriptProcessorNode.\n       */\n      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n      this._nativeAudioContext = nativeAudioContext;\n      this._state = null;\n      /*\n       * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n       * to 'running'.\n       */\n\n      if (nativeAudioContext.state === 'running') {\n        this._state = 'suspended';\n\n        const revokeState = () => {\n          if (this._state === 'suspended') {\n            this._state = null;\n          }\n\n          nativeAudioContext.removeEventListener('statechange', revokeState);\n        };\n\n        nativeAudioContext.addEventListener('statechange', revokeState);\n      }\n    }\n\n    get baseLatency() {\n      return this._baseLatency;\n    }\n\n    get state() {\n      return this._state !== null ? this._state : this._nativeAudioContext.state;\n    }\n\n    close() {\n      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n      if (this.state === 'closed') {\n        return this._nativeAudioContext.close().then(() => {\n          throw createInvalidStateError();\n        });\n      } // Bug #34: If the state was set to suspended before it should be revoked now.\n\n\n      if (this._state === 'suspended') {\n        this._state = null;\n      }\n\n      return this._nativeAudioContext.close();\n      /*\n       * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n       * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n       */\n    }\n\n    createMediaElementSource(mediaElement) {\n      return new mediaElementAudioSourceNodeConstructor(this, {\n        mediaElement\n      });\n    }\n\n    createMediaStreamDestination() {\n      return new mediaStreamAudioDestinationNodeConstructor(this);\n    }\n\n    createMediaStreamSource(mediaStream) {\n      return new mediaStreamAudioSourceNodeConstructor(this, {\n        mediaStream\n      });\n    }\n\n    createMediaStreamTrackSource(mediaStreamTrack) {\n      return new mediaStreamTrackAudioSourceNodeConstructor(this, {\n        mediaStreamTrack\n      });\n    }\n\n    resume() {\n      if (this._state === 'suspended') {\n        return new Promise((resolve, reject) => {\n          const resolvePromise = () => {\n            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n            if (this._nativeAudioContext.state === 'running') {\n              resolve();\n            } else {\n              this.resume().then(resolve, reject);\n            }\n          };\n\n          this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n        });\n      }\n\n      return this._nativeAudioContext.resume().catch(err => {\n        // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined || err.code === 15) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n    suspend() {\n      return this._nativeAudioContext.suspend().catch(err => {\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","export const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode) => {\n  return class AudioDestinationNode extends audioNodeConstructor {\n    constructor(context, channelCount) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null;\n      super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n      this._isNodeOfNativeOfflineAudioContext = isOffline;\n      this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n    }\n\n    get channelCount() {\n      return this._nativeAudioDestinationNode.channelCount;\n    }\n\n    set channelCount(value) {\n      // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n      // Bug #54: Firefox does throw an IndexSizeError.\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError();\n      } // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n\n\n      if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n        throw createIndexSizeError();\n      }\n\n      this._nativeAudioDestinationNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioDestinationNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      // Bug #53: No browser does throw an exception yet.\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError();\n      }\n\n      this._nativeAudioDestinationNode.channelCountMode = value;\n    }\n\n    get maxChannelCount() {\n      return this._nativeAudioDestinationNode.maxChannelCount;\n    }\n\n  };\n};","export const createAudioDestinationNodeRenderer = renderInputsOfAudioNode => {\n  let nativeAudioDestinationNodePromise = null;\n\n  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext, trace) => {\n    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n    await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode, trace);\n    return nativeAudioDestinationNode;\n  };\n\n  return {\n    render(proxy, nativeOfflineAudioContext, trace) {\n      if (nativeAudioDestinationNodePromise === null) {\n        nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n      return nativeAudioDestinationNodePromise;\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n  return (context, nativeContext) => {\n    const nativeListener = nativeContext.listener; // Bug #117: Only Chrome & Opera support the new interface already.\n\n    const createFakeAudioParams = () => {\n      const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: 9\n      });\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n      const createFakeAudioParam = (input, value) => {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: value\n        });\n        constantSourceNode.connect(channelMergerNode, 0, input); // @todo This should be stopped when the context is closed.\n\n        constantSourceNode.start();\n        Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n          get() {\n            return value;\n          }\n\n        });\n        /*\n         * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n         * minValue for GainNodes.\n         */\n\n        return createAudioParam({\n          context\n        }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      };\n\n      let lastOrientation = [0, 0, -1, 0, 1, 0];\n      let lastPosition = [0, 0, 0];\n\n      scriptProcessorNode.onaudioprocess = ({\n        inputBuffer\n      }) => {\n        const orientation = [inputBuffer.getChannelData(0)[0], inputBuffer.getChannelData(1)[0], inputBuffer.getChannelData(2)[0], inputBuffer.getChannelData(3)[0], inputBuffer.getChannelData(4)[0], inputBuffer.getChannelData(5)[0]];\n\n        if (orientation.some((value, index) => value !== lastOrientation[index])) {\n          nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n          lastOrientation = orientation;\n        }\n\n        const positon = [inputBuffer.getChannelData(6)[0], inputBuffer.getChannelData(7)[0], inputBuffer.getChannelData(8)[0]];\n\n        if (positon.some((value, index) => value !== lastPosition[index])) {\n          nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n          lastPosition = positon;\n        }\n      };\n\n      channelMergerNode.connect(scriptProcessorNode);\n      return {\n        forwardX: createFakeAudioParam(0, 0),\n        forwardY: createFakeAudioParam(1, 0),\n        forwardZ: createFakeAudioParam(2, -1),\n        positionX: createFakeAudioParam(6, 0),\n        positionY: createFakeAudioParam(7, 0),\n        positionZ: createFakeAudioParam(8, 0),\n        upX: createFakeAudioParam(3, 0),\n        upY: createFakeAudioParam(4, 1),\n        upZ: createFakeAudioParam(5, 0)\n      };\n    };\n\n    const {\n      forwardX,\n      forwardY,\n      forwardZ,\n      positionX,\n      positionY,\n      positionZ,\n      upX,\n      upY,\n      upZ\n    } = nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n    return {\n      get forwardX() {\n        return forwardX;\n      },\n\n      get forwardY() {\n        return forwardY;\n      },\n\n      get forwardZ() {\n        return forwardZ;\n      },\n\n      get positionX() {\n        return positionX;\n      },\n\n      get positionY() {\n        return positionY;\n      },\n\n      get positionZ() {\n        return positionZ;\n      },\n\n      get upX() {\n        return upX;\n      },\n\n      get upY() {\n        return upY;\n      },\n\n      get upZ() {\n        return upZ;\n      }\n\n    };\n  };\n};","import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n    const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n\n      exponentialRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n\n      setValueCurveAtTime(values, startTime, duration) {\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (values.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? values[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          audioParam.setValueAtTime(values[values.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n        }\n\n        return audioParam;\n      }\n\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","export const createAudioParamRenderer = automationEventList => {\n  return {\n    replay(audioParam) {\n      for (const automationEvent of automationEventList) {\n        if (automationEvent.type === 'exponentialRampToValue') {\n          const {\n            endTime,\n            value\n          } = automationEvent;\n          audioParam.exponentialRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === 'linearRampToValue') {\n          const {\n            endTime,\n            value\n          } = automationEvent;\n          audioParam.linearRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === 'setTarget') {\n          const {\n            startTime,\n            target,\n            timeConstant\n          } = automationEvent;\n          audioParam.setTargetAtTime(target, startTime, timeConstant);\n        } else if (automationEvent.type === 'setValue') {\n          const {\n            startTime,\n            value\n          } = automationEvent;\n          audioParam.setValueAtTime(value, startTime);\n        } else if (automationEvent.type === 'setValueCurve') {\n          const {\n            duration,\n            startTime,\n            values\n          } = automationEvent;\n          audioParam.setValueCurveAtTime(values, startTime, duration);\n        } else {\n          throw new Error(\"Can't apply an unknown automation.\");\n        }\n      }\n    }\n\n  };\n};","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nconst createChannelCount = length => {\n  const channelCount = [];\n\n  for (let i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  };\n};\n\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n  return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(_nativeContext, numberOfChannels) {\n      super(_nativeContext, numberOfChannels);\n      this._nativeContext = _nativeContext;\n      this._audioWorklet = addAudioWorkletModule === undefined ? undefined : {\n        addModule: (moduleURL, options) => {\n          return addAudioWorkletModule(this, moduleURL, options);\n        }\n      };\n    }\n\n    get audioWorklet() {\n      return this._audioWorklet;\n    }\n\n    createAnalyser() {\n      return new analyserNodeConstructor(this);\n    }\n\n    createBiquadFilter() {\n      return new biquadFilterNodeConstructor(this);\n    }\n\n    createBuffer(numberOfChannels, length, sampleRate) {\n      return new audioBufferConstructor({\n        length,\n        numberOfChannels,\n        sampleRate\n      });\n    }\n\n    createBufferSource() {\n      return new audioBufferSourceNodeConstructor(this);\n    }\n\n    createChannelMerger(numberOfInputs = 6) {\n      return new channelMergerNodeConstructor(this, {\n        numberOfInputs\n      });\n    }\n\n    createChannelSplitter(numberOfOutputs = 6) {\n      return new channelSplitterNodeConstructor(this, {\n        numberOfOutputs\n      });\n    }\n\n    createConstantSource() {\n      return new constantSourceNodeConstructor(this);\n    }\n\n    createConvolver() {\n      return new convolverNodeConstructor(this);\n    }\n\n    createDelay(maxDelayTime = 1) {\n      return new delayNodeConstructor(this, {\n        maxDelayTime\n      });\n    }\n\n    createDynamicsCompressor() {\n      return new dynamicsCompressorNodeConstructor(this);\n    }\n\n    createGain() {\n      return new gainNodeConstructor(this);\n    }\n\n    createIIRFilter(feedforward, feedback) {\n      return new iIRFilterNodeConstructor(this, {\n        feedback,\n        feedforward\n      });\n    }\n\n    createOscillator() {\n      return new oscillatorNodeConstructor(this);\n    }\n\n    createPanner() {\n      return new pannerNodeConstructor(this);\n    }\n\n    createPeriodicWave(real, imag, constraints = {\n      disableNormalization: false\n    }) {\n      return new periodicWaveConstructor(this, { ...constraints,\n        imag,\n        real\n      });\n    }\n\n    createStereoPanner() {\n      return new stereoPannerNodeConstructor(this);\n    }\n\n    createWaveShaper() {\n      return new waveShaperNodeConstructor(this);\n    }\n\n    decodeAudioData(audioData, successCallback, errorCallback) {\n      return decodeAudioData(this._nativeContext, audioData).then(audioBuffer => {\n        if (typeof successCallback === 'function') {\n          successCallback(audioBuffer);\n        }\n\n        return audioBuffer;\n      }).catch(err => {\n        if (typeof errorCallback === 'function') {\n          errorCallback(err);\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  Q: 1,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  detune: 0,\n  frequency: 350,\n  gain: 0,\n  type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class BiquadFilterNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer() : null;\n      super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer); // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT); // Bug #78: Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n\n      this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));\n      /*\n       * Bug #77: Edge does not export the correct values for maxValue and minValue. Firefox & Safari do not export the correct value\n       * for minValue.\n       */\n\n      this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0); // Bug #79: Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n\n      this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);\n      this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n    }\n\n    get detune() {\n      return this._detune;\n    }\n\n    get frequency() {\n      return this._frequency;\n    }\n\n    get gain() {\n      return this._gain;\n    }\n\n    get Q() {\n      return this._Q;\n    }\n\n    get type() {\n      return this._nativeBiquadFilterNode.type;\n    }\n\n    set type(value) {\n      this._nativeBiquadFilterNode.type = value;\n    }\n\n    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n      this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse); // Bug #68: Only Chrome, Firefox & Opera do throw an error if the parameters differ in their length.\n\n\n      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n        throw createInvalidAccessError();\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createBiquadFilterNodeRendererFactory = (connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeBiquadFilterNodes = new WeakMap();\n\n    const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n      if (!nativeBiquadFilterNodeIsOwnedByContext) {\n        const options = {\n          Q: nativeBiquadFilterNode.Q.value,\n          channelCount: nativeBiquadFilterNode.channelCount,\n          channelCountMode: nativeBiquadFilterNode.channelCountMode,\n          channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n          detune: nativeBiquadFilterNode.detune.value,\n          frequency: nativeBiquadFilterNode.frequency.value,\n          gain: nativeBiquadFilterNode.gain.value,\n          type: nativeBiquadFilterNode.type\n        };\n        nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n      if (!nativeBiquadFilterNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode, trace);\n      return nativeBiquadFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeBiquadFilterNode !== undefined) {\n          return Promise.resolve(renderedNativeBiquadFilterNode);\n        }\n\n        return createBiquadFilterNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createCacheTestResult = (ongoingTests, testResults) => {\n  return (tester, test) => {\n    const cachedTestResult = testResults.get(tester);\n\n    if (cachedTestResult !== undefined) {\n      return cachedTestResult;\n    }\n\n    const ongoingTest = ongoingTests.get(tester);\n\n    if (ongoingTest !== undefined) {\n      return ongoingTest;\n    }\n\n    try {\n      const synchronousTestResult = test();\n\n      if (synchronousTestResult instanceof Promise) {\n        ongoingTests.set(tester, synchronousTestResult);\n        return synchronousTestResult.catch(() => false).then(finalTestResult => {\n          ongoingTests.delete(tester);\n          testResults.set(tester, finalTestResult);\n          return finalTestResult;\n        });\n      }\n\n      testResults.set(tester, synchronousTestResult);\n      return synchronousTestResult;\n    } catch {\n      testResults.set(tester, false);\n      return false;\n    }\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 1,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ChannelMergerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n      const channelMergerNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null;\n      super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAudioNode.channelCount,\n          channelCountMode: nativeAudioNode.channelCountMode,\n          channelInterpretation: nativeAudioNode.channelInterpretation,\n          numberOfInputs: nativeAudioNode.numberOfInputs\n        };\n        nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n      return nativeAudioNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 6,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'discrete',\n  numberOfOutputs: 6\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    channelCount: options.numberOfOutputs\n  };\n};\n\nexport const createChannelSplitterNodeConstructor = (audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ChannelSplitterNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n      const channelSplitterNodeRenderer = isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null;\n      super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAudioNode.channelCount,\n          channelCountMode: nativeAudioNode.channelCountMode,\n          channelInterpretation: nativeAudioNode.channelInterpretation,\n          numberOfOutputs: nativeAudioNode.numberOfOutputs\n        };\n        nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode, trace);\n      return nativeAudioNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createConnectAudioParam = renderInputsOfAudioParam => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n  };\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = createIndexSizeError => {\n  return (outputAudioNodes, destination, output = 0, input = 0) => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n      throw createIndexSizeError();\n    }\n\n    if (isNativeAudioNode(destination)) {\n      return outputAudioNode.connect(destination, 0, input);\n    }\n\n    return outputAudioNode.connect(destination, 0);\n  };\n};","export const createConnectedNativeAudioBufferSourceNodeFactory = createNativeAudioBufferSourceNode => {\n  return (nativeContext, nativeAudioNode) => {\n    const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.loop = true;\n    nativeAudioBufferSourceNode.connect(nativeAudioNode);\n    nativeAudioBufferSourceNode.start();\n    return () => {\n      nativeAudioBufferSourceNode.stop();\n      nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n    };\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  offset: 1\n};\nexport const createConstantSourceNodeConstructor = (audioNodeConstructor, createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class ConstantSourceNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory() : null;\n      super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n      this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n      this._nativeConstantSourceNode = nativeConstantSourceNode;\n      /*\n       * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n       * minValue for GainNodes.\n       */\n\n      this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._onended = null;\n    }\n\n    get offset() {\n      return this._offset;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeConstantSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeConstantSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    start(when = 0) {\n      this._nativeConstantSourceNode.start(when);\n\n      if (this._constantSourceNodeRenderer !== null) {\n        this._constantSourceNodeRenderer.start = when;\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeConstantSourceNode.stop(when);\n\n      if (this._constantSourceNodeRenderer !== null) {\n        this._constantSourceNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConstantSourceNodeRendererFactory = (connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeConstantSourceNodes = new WeakMap();\n    let start = null;\n    let stop = null;\n\n    const createConstantSourceNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeConstantSourceNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n      if (!nativeConstantSourceNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeConstantSourceNode.channelCount,\n          channelCountMode: nativeConstantSourceNode.channelCountMode,\n          channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n          offset: nativeConstantSourceNode.offset.value\n        };\n        nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeConstantSourceNode.start(start);\n        }\n\n        if (stop !== null) {\n          nativeConstantSourceNode.stop(stop);\n        }\n      }\n\n      renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n      if (!nativeConstantSourceNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode, trace);\n      return nativeConstantSourceNode;\n    };\n\n    return {\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeConstantSourceNode !== undefined) {\n          return Promise.resolve(renderedNativeConstantSourceNode);\n        }\n\n        return createConstantSourceNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createConvertNumberToUnsignedLong = unit32Array => {\n  return value => {\n    unit32Array[0] = value;\n    return unit32Array[0];\n  };\n};","const DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class ConvolverNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer() : null;\n      super(context, false, nativeConvolverNode, convolverNodeRenderer);\n      this._isBufferNullified = false;\n      this._nativeConvolverNode = nativeConvolverNode;\n    }\n\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n\n      return this._nativeConvolverNode.buffer;\n    }\n\n    set buffer(value) {\n      this._nativeConvolverNode.buffer = value; // Bug #115: Safari does not allow to set the buffer to null.\n\n      if (value === null && this._nativeConvolverNode.buffer !== null) {\n        const nativeContext = this._nativeConvolverNode.context;\n        this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n        this._isBufferNullified = true;\n      } else {\n        this._isBufferNullified = false;\n      }\n    }\n\n    get normalize() {\n      return this._nativeConvolverNode.normalize;\n    }\n\n    set normalize(value) {\n      this._nativeConvolverNode.normalize = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeConvolverNodes = new WeakMap();\n\n    const createConvolverNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeConvolverNode = getNativeAudioNode(proxy); // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n      if (!nativeConvolverNodeIsOwnedByContext) {\n        const options = {\n          buffer: nativeConvolverNode.buffer,\n          channelCount: nativeConvolverNode.channelCount,\n          channelCountMode: nativeConvolverNode.channelCountMode,\n          channelInterpretation: nativeConvolverNode.channelInterpretation,\n          disableNormalization: !nativeConvolverNode.normalize\n        };\n        nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n      if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode, trace);\n      }\n\n      return nativeConvolverNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeConvolverNode !== undefined) {\n          return Promise.resolve(renderedNativeConvolverNode);\n        }\n\n        return createConvolverNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n  return (numberOfChannels, length, sampleRate) => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      throw new Error('Missing the native OfflineAudioContext constructor.');\n    }\n\n    try {\n      return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n    } catch (err) {\n      // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n      // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n      // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n      if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n        throw createNotSupportedError();\n      }\n\n      throw err;\n    }\n  };\n};","export const createDataCloneError = () => {\n  try {\n    return new DOMException('', 'DataCloneError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 25;\n    err.name = 'DataCloneError';\n    return err;\n  }\n};","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode, cycleCounters, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext) => {\n  return (audioNode, count) => {\n    const cycleCounter = cycleCounters.get(audioNode);\n\n    if (cycleCounter === undefined) {\n      throw new Error('Missing the expected cycle count.');\n    }\n\n    const nativeContext = getNativeContext(audioNode.context);\n    const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n    if (cycleCounter === count) {\n      cycleCounters.delete(audioNode);\n\n      if (!isOffline && isActiveAudioNode(audioNode)) {\n        const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n        const {\n          outputs\n        } = getAudioNodeConnections(audioNode);\n\n        for (const output of outputs) {\n          if (isAudioNodeOutputConnection(output)) {\n            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n            connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n          } else {\n            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n          }\n        }\n      }\n    } else {\n      cycleCounters.set(audioNode, cycleCounter - count);\n    }\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  delayTime: 0,\n  maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class DelayNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const delayNodeRenderer = isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null;\n      super(context, false, nativeDelayNode, delayNodeRenderer); // Bug #161: Edge does not export the correct values for maxValue and minValue.\n\n      this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n    }\n\n    get delayTime() {\n      return this._delayTime;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDelayNodeRendererFactory = (connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return maxDelayTime => {\n    const renderedNativeDelayNodes = new WeakMap();\n\n    const createDelayNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeDelayNode = getNativeAudioNode(proxy); // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n      if (!nativeDelayNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeDelayNode.channelCount,\n          channelCountMode: nativeDelayNode.channelCountMode,\n          channelInterpretation: nativeDelayNode.channelInterpretation,\n          delayTime: nativeDelayNode.delayTime.value,\n          maxDelayTime\n        };\n        nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n      if (!nativeDelayNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode, trace);\n      return nativeDelayNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeDelayNode !== undefined) {\n          return Promise.resolve(renderedNativeDelayNode);\n        }\n\n        return createDelayNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createDeleteUnrenderedAudioWorkletNode = getUnrenderedAudioWorkletNodes => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n  };\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\n\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n  const outputAudioNode = outputAudioNodes[output];\n\n  if (outputAudioNode === undefined) {\n    throw createIndexSizeError();\n  }\n\n  return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs = createIndexSizeError => {\n  return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n    if (destinationOrOutput === undefined) {\n      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect());\n    }\n\n    if (typeof destinationOrOutput === 'number') {\n      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n    }\n\n    if (isNativeAudioNode(destinationOrOutput)) {\n      if (output === undefined) {\n        return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));\n      }\n\n      if (input === undefined) {\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n      }\n\n      return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n    }\n\n    if (output === undefined) {\n      return outputAudioNodes.forEach(outputAudioNode => outputAudioNode.disconnect(destinationOrOutput));\n    }\n\n    return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n  };\n};","const DEFAULT_OPTIONS = {\n  attack: 0.003,\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  knee: 30,\n  ratio: 12,\n  release: 0.25,\n  threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, getNativeContext, isNativeOfflineAudioContext) => {\n  return class DynamicsCompressorNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer() : null;\n      super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer); // Bug #110: Edge does not export the correct values for maxValue and minValue.\n\n      this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n      this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n      this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n      this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n      this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n      this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n    }\n\n    get attack() {\n      return this._attack;\n    }\n    /*\n     * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n     * to be overwritten here.\n     */\n\n\n    get channelCount() {\n      return this._nativeDynamicsCompressorNode.channelCount;\n    }\n\n    set channelCount(value) {\n      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n      this._nativeDynamicsCompressorNode.channelCount = value;\n\n      if (value > 2) {\n        this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n        throw createNotSupportedError();\n      }\n    }\n    /*\n     * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n     * overwritten here.\n     */\n\n\n    get channelCountMode() {\n      return this._nativeDynamicsCompressorNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n      this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n      if (value === 'max') {\n        this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n        throw createNotSupportedError();\n      }\n    }\n\n    get knee() {\n      return this._knee;\n    }\n\n    get ratio() {\n      return this._ratio;\n    }\n\n    get reduction() {\n      // Bug #111: Safari returns an AudioParam instead of a number.\n      if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n        return this._nativeDynamicsCompressorNode.reduction.value;\n      }\n\n      return this._nativeDynamicsCompressorNode.reduction;\n    }\n\n    get release() {\n      return this._release;\n    }\n\n    get threshold() {\n      return this._threshold;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createDynamicsCompressorNodeRendererFactory = (connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeDynamicsCompressorNodes = new WeakMap();\n\n    const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n       * created again.\n       */\n\n      const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n        const options = {\n          attack: nativeDynamicsCompressorNode.attack.value,\n          channelCount: nativeDynamicsCompressorNode.channelCount,\n          channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n          channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n          knee: nativeDynamicsCompressorNode.knee.value,\n          ratio: nativeDynamicsCompressorNode.ratio.value,\n          release: nativeDynamicsCompressorNode.release.value,\n          threshold: nativeDynamicsCompressorNode.threshold.value\n        };\n        nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n      if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode, trace);\n      return nativeDynamicsCompressorNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeDynamicsCompressorNode !== undefined) {\n          return Promise.resolve(renderedNativeDynamicsCompressorNode);\n        }\n\n        return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createEncodingError = () => {\n  try {\n    return new DOMException('', 'EncodingError');\n  } catch (err) {\n    // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n    err.code = 0;\n    err.name = 'EncodingError';\n    return err;\n  }\n};","export const createEvaluateSource = window => {\n  return source => new Promise((resolve, reject) => {\n    if (window === null) {\n      reject(new SyntaxError());\n      return;\n    }\n\n    const head = window.document.head;\n\n    if (head === null) {\n      reject(new SyntaxError());\n    } else {\n      const script = window.document.createElement('script'); // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n\n      const blob = new Blob([source], {\n        type: 'application/javascript'\n      });\n      const url = URL.createObjectURL(blob);\n      const originalOnErrorHandler = window.onerror;\n\n      const removeErrorEventListenerAndRevokeUrl = () => {\n        window.onerror = originalOnErrorHandler;\n        URL.revokeObjectURL(url);\n      };\n\n      window.onerror = (message, src, lineno, colno, error) => {\n        // @todo Edge thinks the source is the one of the html document.\n        if (src === url || src === window.location.href && lineno === 1 && colno === 1) {\n          removeErrorEventListenerAndRevokeUrl();\n          reject(error);\n          return false;\n        }\n\n        if (originalOnErrorHandler !== null) {\n          return originalOnErrorHandler(message, src, lineno, colno, error);\n        }\n      };\n\n      script.onerror = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        reject(new SyntaxError());\n      };\n\n      script.onload = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        resolve();\n      };\n\n      script.src = url;\n      script.type = 'module';\n      head.appendChild(script);\n    }\n  });\n};","export const createEventTargetConstructor = wrapEventListener => {\n  return class EventTarget {\n    constructor(_nativeEventTarget) {\n      this._nativeEventTarget = _nativeEventTarget;\n      this._listeners = new WeakMap();\n    }\n\n    addEventListener(type, listener, options) {\n      if (listener !== null) {\n        let wrappedEventListener = this._listeners.get(listener);\n\n        if (wrappedEventListener === undefined) {\n          wrappedEventListener = wrapEventListener(this, listener);\n\n          if (typeof listener === 'function') {\n            this._listeners.set(listener, wrappedEventListener);\n          }\n        }\n\n        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n      }\n    }\n\n    dispatchEvent(event) {\n      return this._nativeEventTarget.dispatchEvent(event);\n    }\n\n    removeEventListener(type, listener, options) {\n      const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n    }\n\n  };\n};","export const createExposeCurrentFrameAndCurrentTime = window => {\n  return (currentTime, sampleRate, fn) => {\n    Object.defineProperties(window, {\n      currentFrame: {\n        configurable: true,\n\n        get() {\n          return Math.round(currentTime * sampleRate);\n        }\n\n      },\n      currentTime: {\n        configurable: true,\n\n        get() {\n          return currentTime;\n        }\n\n      }\n    });\n\n    try {\n      return fn();\n    } finally {\n      if (window !== null) {\n        delete window.currentFrame;\n        delete window.currentTime;\n      }\n    }\n  };\n};","export const createFetchSource = createAbortError => {\n  return async url => {\n    try {\n      const response = await fetch(url);\n\n      if (response.ok) {\n        return response.text();\n      }\n    } catch {}\n    /* Ignore errors. */\n    // tslint:disable-line:no-empty\n\n\n    throw createAbortError();\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  gain: 1\n};\nexport const createGainNodeConstructor = (audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class GainNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const gainNodeRenderer = isOffline ? createGainNodeRenderer() : null;\n      super(context, false, nativeGainNode, gainNodeRenderer); // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get gain() {\n      return this._gain;\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createGainNodeRendererFactory = (connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeGainNodes = new WeakMap();\n\n    const createGainNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeGainNode = getNativeAudioNode(proxy); // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n      if (!nativeGainNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeGainNode.channelCount,\n          channelCountMode: nativeGainNode.channelCountMode,\n          channelInterpretation: nativeGainNode.channelInterpretation,\n          gain: nativeGainNode.gain.value\n        };\n        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n      if (!nativeGainNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode, trace);\n      return nativeGainNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeGainNode !== undefined) {\n          return Promise.resolve(renderedNativeGainNode);\n        }\n\n        return createGainNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createGetAudioNodeRenderer = getAudioNodeConnections => {\n  return audioNode => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n    if (audioNodeConnections.renderer === null) {\n      throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n    }\n\n    return audioNodeConnections.renderer;\n  };\n};","export const createGetAudioParamRenderer = getAudioParamConnections => {\n  return audioParam => {\n    const audioParamConnections = getAudioParamConnections(audioParam);\n\n    if (audioParamConnections.renderer === null) {\n      throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n    }\n\n    return audioParamConnections.renderer;\n  };\n};","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n  return nativeContext => {\n    /*\n     * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n     * backupNativeContext in that case.\n     */\n    if (nativeContext.state === 'closed' && nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n\n        if (backupNativeContext !== undefined) {\n          return backupNativeContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor !== null) {\n          // @todo Copy the attached AudioWorkletProcessors and other settings.\n          const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n          BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n          return bckpNtveCntxt;\n        }\n      } else {\n        const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n\n        if (backupNativeContext !== undefined) {\n          return backupNativeContext;\n        } // @todo Copy the attached AudioWorkletProcessors and other settings.\n\n\n        const bckpNtveCntxt = new nativeAudioContextConstructor();\n        BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n        return bckpNtveCntxt;\n      }\n    }\n\n    return null;\n  };\n};","import { createInvalidStateError } from './invalid-state-error';\nexport const createGetNativeContext = contextStore => {\n  return context => {\n    const nativeContext = contextStore.get(context);\n\n    if (nativeContext === undefined) {\n      throw createInvalidStateError();\n    }\n\n    return nativeContext;\n  };\n};","export const createGetUnrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore => {\n  return nativeContext => {\n    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n    if (unrenderedAudioWorkletNodes === undefined) {\n      throw new Error('The context has no set of AudioWorkletNodes.');\n    }\n\n    return unrenderedAudioWorkletNodes;\n  };\n};","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n  const feedbackLength = feedback.length;\n  const feedforwardLength = feedforward.length;\n  const minLength = Math.min(feedbackLength, feedforwardLength);\n\n  if (feedback[0] !== 1) {\n    for (let i = 0; i < feedbackLength; i += 1) {\n      feedforward[i] /= feedback[0];\n    }\n\n    for (let i = 1; i < feedforwardLength; i += 1) {\n      feedback[i] /= feedback[0];\n    }\n  }\n\n  const bufferLength = 32;\n  const xBuffer = new Float32Array(bufferLength);\n  const yBuffer = new Float32Array(bufferLength);\n  const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n  const numberOfChannels = renderedBuffer.numberOfChannels;\n\n  for (let i = 0; i < numberOfChannels; i += 1) {\n    const input = renderedBuffer.getChannelData(i);\n    const output = filteredBuffer.getChannelData(i);\n    xBuffer.fill(0);\n    yBuffer.fill(0);\n    filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n  }\n\n  return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (feedback, feedforward) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let filteredBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioBufferSourceNode = null;\n      let nativeIIRFilterNode = getNativeAudioNode(proxy); // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext); // Bug #9: Safari does not support IIRFilterNodes.\n\n      if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n      } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n        nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, ntvCntxt => {\n          return ntvCntxt.createIIRFilter(feedforward, feedback);\n        });\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n\n      if (nativeAudioBufferSourceNode !== null) {\n        if (filteredBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor( // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n          proxy.context.destination.channelCount, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n\n          filteredBufferPromise = (async () => {\n            await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination, trace);\n            const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n            return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n          })();\n        }\n\n        const filteredBuffer = await filteredBufferPromise;\n        nativeAudioBufferSourceNode.buffer = filteredBuffer;\n        nativeAudioBufferSourceNode.start(0);\n        return nativeAudioBufferSourceNode;\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode, trace);\n      return nativeIIRFilterNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nexport const createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode) => {\n  return isOffline => {\n    return (audioNode, count) => {\n      const cycleCounter = cycleCounters.get(audioNode);\n\n      if (cycleCounter === undefined) {\n        if (!isOffline && isActiveAudioNode(audioNode)) {\n          const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n          const {\n            outputs\n          } = getAudioNodeConnections(audioNode);\n\n          for (const output of outputs) {\n            if (isAudioNodeOutputConnection(output)) {\n              const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n              disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n            } else {\n              const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n            }\n          }\n        }\n\n        cycleCounters.set(audioNode, count);\n      } else {\n        cycleCounters.set(audioNode, cycleCounter + count);\n      }\n    };\n  };\n};","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n  return anything => {\n    const nativeContext = contextStore.get(anything);\n    return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n  };\n};","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n  return anything => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n  return anything => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n  return anything => {\n    const nativeContext = contextStore.get(anything);\n    return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n  };\n};","export const createIsNativeAudioContext = nativeAudioContextConstructor => {\n  return anything => {\n    return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n  };\n};","export const createIsNativeAudioNode = window => {\n  return anything => {\n    return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n  };\n};","export const createIsNativeAudioParam = window => {\n  return anything => {\n    return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n  };\n};","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n  return anything => {\n    return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n  };\n};","export const createIsNativeOfflineAudioContext = nativeOfflineAudioContextConstructor => {\n  return anything => {\n    return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n  };\n};","export const createIsSecureContext = window => window !== null && window.isSecureContext;","export const createIsSupportedPromise = async (cacheTestResult, testAudioBufferCopyChannelMethodsSubarraySupport, testAudioContextCloseMethodSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextOptionsSupport, testAudioNodeConnectMethodSupport, testAudioWorkletProcessorNoOutputsSupport, testChannelMergerNodeChannelCountSupport, testConstantSourceNodeAccurateSchedulingSupport, testConvolverNodeBufferReassignabilitySupport, testIsSecureContextSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testStereoPannerNodeDefaultValueSupport, testTransferablesSupport) => {\n  if (cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) && cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) && cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) && cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) && cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) && cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) && cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) && cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) && cacheTestResult(testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport, testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport)) {\n    const results = await Promise.all([cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport), cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport), cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport), cacheTestResult(testTransferablesSupport, testTransferablesSupport)]);\n    return results.every(result => result);\n  }\n\n  return false;\n};","export const createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaElementAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options); // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw TypeError();\n      }\n\n      super(context, true, nativeMediaElementAudioSourceNode, null); // Bug #63: Edge does not expose the mediaElement yet.\n\n      this._mediaElement = options.mediaElement;\n      this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n    }\n\n    get mediaElement() {\n      return this._nativeMediaElementAudioSourceNode.mediaElement === undefined ? this._mediaElement : this._nativeMediaElementAudioSourceNode.mediaElement;\n    }\n\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers'\n};\nexport const createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaStreamAudioDestinationNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context); // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw new TypeError();\n      }\n\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n      super(context, false, nativeMediaStreamAudioDestinationNode, null);\n      this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n    }\n\n    get stream() {\n      return this._nativeMediaStreamAudioDestinationNode.stream;\n    }\n\n  };\n};","export const createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext) => {\n  return class MediaStreamAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options); // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n\n      if (isNativeOfflineAudioContext(nativeContext)) {\n        throw new TypeError();\n      }\n\n      super(context, true, nativeMediaStreamAudioSourceNode, null);\n      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n    }\n\n    get mediaStream() {\n      return this._nativeMediaStreamAudioSourceNode.mediaStream;\n    }\n\n  };\n};","export const createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext) => {\n  return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n      super(context, true, nativeMediaStreamTrackAudioSourceNode, null);\n    }\n\n  };\n};","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n  return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(options = {}) {\n      if (nativeAudioContextConstructor === null) {\n        throw new Error('Missing the native AudioContext constructor.');\n      }\n\n      const nativeAudioContext = new nativeAudioContextConstructor(options); // Bug #131 Safari returns null when there are four other AudioContexts running already.\n\n      if (nativeAudioContext === null) {\n        throw createUnknownError();\n      } // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n\n\n      if (!isValidLatencyHint(options.latencyHint)) {\n        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n      } // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n\n\n      if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n        throw createNotSupportedError();\n      }\n\n      super(nativeAudioContext, 2);\n      const {\n        latencyHint\n      } = options;\n      const {\n        sampleRate\n      } = nativeAudioContext; // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n\n      this._baseLatency = typeof nativeAudioContext.baseLatency === 'number' ? nativeAudioContext.baseLatency : latencyHint === 'balanced' ? 512 / sampleRate : latencyHint === 'interactive' || latencyHint === undefined ? 256 / sampleRate : latencyHint === 'playback' ? 1024 / sampleRate :\n      /*\n       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n       * ScriptProcessorNode.\n       */\n      Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate;\n      this._nativeAudioContext = nativeAudioContext;\n      this._state = null;\n      /*\n       * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n       * changes to 'running'.\n       */\n\n      if (nativeAudioContext.state === 'running') {\n        this._state = 'suspended';\n\n        const revokeState = () => {\n          if (this._state === 'suspended') {\n            this._state = null;\n          }\n\n          nativeAudioContext.removeEventListener('statechange', revokeState);\n        };\n\n        nativeAudioContext.addEventListener('statechange', revokeState);\n      }\n    }\n\n    get baseLatency() {\n      return this._baseLatency;\n    }\n\n    get state() {\n      return this._state !== null ? this._state : this._nativeAudioContext.state;\n    }\n\n    close() {\n      // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n      if (this.state === 'closed') {\n        return this._nativeAudioContext.close().then(() => {\n          throw createInvalidStateError();\n        });\n      } // Bug #34: If the state was set to suspended before it should be revoked now.\n\n\n      if (this._state === 'suspended') {\n        this._state = null;\n      }\n\n      return this._nativeAudioContext.close();\n      /*\n       * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n       * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n       */\n    }\n\n    resume() {\n      if (this._state === 'suspended') {\n        return new Promise((resolve, reject) => {\n          const resolvePromise = () => {\n            this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n            if (this._nativeAudioContext.state === 'running') {\n              resolve();\n            } else {\n              this.resume().then(resolve, reject);\n            }\n          };\n\n          this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n        });\n      }\n\n      return this._nativeAudioContext.resume().catch(err => {\n        // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined || err.code === 15) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n    suspend() {\n      return this._nativeAudioContext.suspend().catch(err => {\n        // Bug #56: Safari invokes the catch handler but without an error.\n        if (err === undefined) {\n          throw createInvalidStateError();\n        }\n\n        throw err;\n      });\n    }\n\n  };\n};","import { CONTEXT_STORE } from '../globals';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener) => {\n  return class MinimalBaseAudioContext extends eventTargetConstructor {\n    constructor(_nativeContext, numberOfChannels) {\n      super(_nativeContext);\n      this._nativeContext = _nativeContext;\n      CONTEXT_STORE.set(this, _nativeContext); // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n\n      const sampleRate = _nativeContext.sampleRate;\n      Object.defineProperty(_nativeContext, 'sampleRate', {\n        get: () => sampleRate\n      });\n\n      if (isNativeOfflineAudioContext(_nativeContext)) {\n        unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n      }\n\n      this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n      this._listener = createAudioListener(this, _nativeContext);\n      this._onstatechange = null;\n    }\n\n    get currentTime() {\n      return this._nativeContext.currentTime;\n    }\n\n    get destination() {\n      return this._destination;\n    }\n\n    get listener() {\n      return this._listener;\n    }\n\n    get onstatechange() {\n      return this._onstatechange;\n    }\n\n    set onstatechange(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeContext.onstatechange = wrappedListener;\n      const nativeOnStateChange = this._nativeContext.onstatechange;\n      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n    }\n\n    get sampleRate() {\n      return this._nativeContext.sampleRate;\n    }\n\n    get state() {\n      return this._nativeContext.state;\n    }\n\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n  return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n    constructor(options) {\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).then(audioBuffer => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        return audioBuffer;\n      }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n      .catch(err => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        throw err;\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","export const createMonitorConnections = (insertElementInSet, isNativeAudioNode) => {\n  return (nativeAudioNode, whenConnected, whenDisconnected) => {\n    const connections = new Set();\n\n    nativeAudioNode.connect = (connect => {\n      return (destination, output = 0, input = 0) => {\n        const wasDisconnected = connections.size === 0;\n\n        if (isNativeAudioNode(destination)) {\n          // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n          connect.call(nativeAudioNode, destination, output, input);\n          insertElementInSet(connections, [destination, output, input], connection => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n\n          if (wasDisconnected) {\n            whenConnected();\n          }\n\n          return destination;\n        }\n\n        connect.call(nativeAudioNode, destination, output);\n        insertElementInSet(connections, [destination, output], connection => connection[0] === destination && connection[1] === output, true);\n\n        if (wasDisconnected) {\n          whenConnected();\n        }\n\n        return;\n      };\n    })(nativeAudioNode.connect);\n\n    nativeAudioNode.disconnect = (disconnect => {\n      return (destinationOrOutput, output, input) => {\n        const wasConnected = connections.size > 0;\n\n        if (destinationOrOutput === undefined) {\n          disconnect.apply(nativeAudioNode);\n          connections.clear();\n        } else if (typeof destinationOrOutput === 'number') {\n          // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n          disconnect.call(nativeAudioNode, destinationOrOutput);\n\n          for (const connection of connections) {\n            if (connection[1] === destinationOrOutput) {\n              connections.delete(connection);\n            }\n          }\n        } else {\n          if (isNativeAudioNode(destinationOrOutput)) {\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n          } else {\n            // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n            disconnect.call(nativeAudioNode, destinationOrOutput, output);\n          }\n\n          for (const connection of connections) {\n            if (connection[0] === destinationOrOutput && (output === undefined || connection[1] === output) && (input === undefined || connection[2] === input)) {\n              connections.delete(connection);\n            }\n          }\n        }\n\n        const isDisconnected = connections.size === 0;\n\n        if (wasConnected && isDisconnected) {\n          whenDisconnected();\n        }\n      };\n    })(nativeAudioNode.disconnect);\n\n    return nativeAudioNode;\n  };\n};","export const createNativeAudioBufferConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('AudioBuffer')) {\n    return window.AudioBuffer;\n  }\n\n  return null;\n};","export const createNativeAudioContextConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('AudioContext')) {\n    return window.AudioContext;\n  }\n\n  return window.hasOwnProperty('webkitAudioContext') ? window.webkitAudioContext : null;\n};","export const createNativeAudioDestinationNodeFactory = (createNativeGainNode, overwriteAccessors) => {\n  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination; // Bug #132: Edge & Safari do not have the correct channelCount.\n\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n      try {\n        nativeAudioDestinationNode.channelCount = channelCount;\n      } catch {// Bug #169: Safari throws an error on each attempt to change the channelCount.\n      }\n    } // Bug #83: Edge & Safari do not have the correct channelCountMode.\n\n\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n      nativeAudioDestinationNode.channelCountMode = 'explicit';\n    } // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n\n\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n      Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n        value: channelCount\n      });\n    } // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n\n\n    const gainNode = createNativeGainNode(nativeContext, {\n      channelCount,\n      channelCountMode: nativeAudioDestinationNode.channelCountMode,\n      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n      gain: 1\n    });\n    overwriteAccessors(gainNode, 'channelCount', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n\n      try {\n        nativeAudioDestinationNode.channelCount = value;\n      } catch (err) {\n        // Bug #169: Safari throws an error on each attempt to change the channelCount.\n        if (value > nativeAudioDestinationNode.maxChannelCount) {\n          throw err;\n        }\n      }\n    });\n    overwriteAccessors(gainNode, 'channelCountMode', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelCountMode = value;\n    });\n    overwriteAccessors(gainNode, 'channelInterpretation', get => () => get.call(gainNode), set => value => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelInterpretation = value;\n    });\n    Object.defineProperty(gainNode, 'maxChannelCount', {\n      get: () => nativeAudioDestinationNode.maxChannelCount\n    }); // @todo This should be disconnected when the context is closed.\n\n    gainNode.connect(nativeAudioDestinationNode);\n    return gainNode;\n  };\n};","export const createNativeAudioNodeFactory = getBackupNativeContext => {\n  return (nativeContext, factoryFunction) => {\n    // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n    const backupNativeContext = getBackupNativeContext(nativeContext);\n\n    if (backupNativeContext !== null) {\n      return factoryFunction(backupNativeContext);\n    }\n\n    return factoryFunction(nativeContext);\n  };\n};","export const createNativeAudioWorkletNodeConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBiquadFilter());\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n    return nativeBiquadFilterNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n  return (nativeContext, options) => {\n    const nativeChannelMergerNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createChannelMerger(options.numberOfInputs);\n    }); // Bug #15: Safari does not return the default properties.\n\n    if (nativeChannelMergerNode.channelCount !== 1 && nativeChannelMergerNode.channelCountMode !== 'explicit') {\n      wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n    }\n\n    assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n    return nativeChannelMergerNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n  return (nativeContext, options) => {\n    // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n    if (nativeContext.createConstantSource === undefined) {\n      return createNativeConstantSourceNodeFaker(nativeContext, options);\n    }\n\n    const nativeConstantSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createConstantSource();\n    });\n    assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset'); // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n    } // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeConstantSourceNode);\n    return nativeConstantSourceNode;\n  };\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, {\n    offset,\n    ...audioNodeOptions\n  }) => {\n    const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n    const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: offset\n    }); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    const channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.\n\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    const nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return gainNode.context;\n      },\n\n      get inputs() {\n        return [];\n      },\n\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n\n      get offset() {\n        return gainNode.gain;\n      },\n\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n\n      addEventListener(...args) {\n        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return audioBufferSourceNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n      },\n\n      start(when = 0) {\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n\n      stop(when = 0) {\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n\n    };\n\n    const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode); // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, audioBufferSourceNode);\n    return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNativeConvolverNodeFaker, createNotSupportedError, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeConvolverNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createConvolver());\n\n    try {\n      // Bug #166: Opera does not allow yet to set the channelCount to 1.\n      nativeConvolverNode.channelCount = 1;\n    } catch (err) {\n      return createNativeConvolverNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativeConvolverNode, options); // The normalize property needs to be set before setting the buffer.\n\n    if (options.disableNormalization === nativeConvolverNode.normalize) {\n      nativeConvolverNode.normalize = !options.disableNormalization;\n    }\n\n    assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer'); // Bug #113: Edge & Safari allow to set the channelCount to a value larger than 2.\n\n    if (options.channelCount > 2) {\n      throw createNotSupportedError();\n    }\n\n    overwriteAccessors(nativeConvolverNode, 'channelCount', get => () => get.call(nativeConvolverNode), set => value => {\n      if (value > 2) {\n        throw createNotSupportedError();\n      }\n\n      return set.call(nativeConvolverNode, value);\n    }); // Bug #114: Edge & Safari allow to set the channelCountMode to 'max'.\n\n    if (options.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    overwriteAccessors(nativeConvolverNode, 'channelCountMode', get => () => get.call(nativeConvolverNode), set => value => {\n      if (value === 'max') {\n        throw createNotSupportedError();\n      }\n\n      return set.call(nativeConvolverNode, value);\n    });\n    return nativeConvolverNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConvolverNodeFakerFactory = (createNativeAudioNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, {\n    buffer,\n    channelCount,\n    channelCountMode,\n    channelInterpretation,\n    disableNormalization\n  }) => {\n    const convolverNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createConvolver());\n    assignNativeAudioNodeOptions(convolverNode, {\n      // Bug #166: Opera does not allow yet to set the channelCount to 1.\n      channelCount: Math.max(channelCount, 2),\n      // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n      channelCountMode: channelCountMode === 'max' ? channelCountMode : 'clamped-max',\n      channelInterpretation\n    });\n    const gainNode = createNativeGainNode(nativeContext, {\n      channelCount,\n      channelCountMode,\n      channelInterpretation,\n      gain: 1\n    });\n    const nativeConvolverNodeFaker = {\n      get buffer() {\n        return convolverNode.buffer;\n      },\n\n      set buffer(value) {\n        convolverNode.buffer = value;\n      },\n\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        // Bug #166: Opera does not allow yet to set the channelCount to 1.\n        if (value > 2) {\n          convolverNode.channelCount = value;\n        }\n\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        // Bug #167: Opera does not allow yet to set the channelCountMode to 'explicit'.\n        if (value === 'max') {\n          convolverNode.channelCountMode = value;\n        }\n\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return convolverNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        convolverNode.channelInterpretation = value;\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return convolverNode.context;\n      },\n\n      get inputs() {\n        return [convolverNode];\n      },\n\n      get numberOfInputs() {\n        return convolverNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return convolverNode.numberOfOutputs;\n      },\n\n      get normalize() {\n        return convolverNode.normalize;\n      },\n\n      set normalize(value) {\n        convolverNode.normalize = value;\n      },\n\n      addEventListener(...args) {\n        return convolverNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return convolverNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return convolverNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    }; // The normalize property needs to be set before setting the buffer.\n\n    if (disableNormalization === nativeConvolverNodeFaker.normalize) {\n      nativeConvolverNodeFaker.normalize = !disableNormalization;\n    }\n\n    if (buffer !== nativeConvolverNodeFaker.buffer) {\n      nativeConvolverNodeFaker.buffer = buffer;\n    }\n\n    const whenConnected = () => convolverNode.connect(gainNode);\n\n    const whenDisconnected = () => convolverNode.disconnect(gainNode);\n\n    return monitorConnections(interceptConnections(nativeConvolverNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeDelayNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createDelay(options.maxDelayTime));\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n    return nativeDelayNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n  return (nativeContext, options) => {\n    const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createDynamicsCompressor());\n    assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options); // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n\n    if (options.channelCount > 2) {\n      throw createNotSupportedError();\n    } // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n\n\n    if (options.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n    assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n    return nativeDynamicsCompressorNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeGainNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createGain());\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n    return nativeGainNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n  return (nativeContext, baseLatency, options) => {\n    // Bug #9: Safari does not support IIRFilterNodes.\n    if (nativeContext.createIIRFilter === undefined) {\n      return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n    }\n\n    const nativeIIRFilterNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n    });\n    assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n    return nativeIIRFilterNode;\n  };\n};","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\n\nfunction divide(a, b) {\n  const denominator = b[0] * b[0] + b[1] * b[1];\n  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a, b) {\n  return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient, z) {\n  let result = [0, 0];\n\n  for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n    result = multiply(result, z);\n    result[0] += coefficient[i];\n  }\n\n  return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n  return (nativeContext, baseLatency, {\n    channelCount,\n    channelCountMode,\n    channelInterpretation,\n    feedback,\n    feedforward\n  }) => {\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (feedback.length === 0 || feedback.length > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (feedback[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (feedforward.length === 0 || feedforward.length > 20) {\n      throw createNotSupportedError();\n    }\n\n    if (feedforward[0] === 0) {\n      throw createInvalidStateError();\n    }\n\n    if (feedback[0] !== 1) {\n      for (let i = 0; i < feedforwardLength; i += 1) {\n        feedforward[i] /= feedback[0];\n      }\n\n      for (let i = 1; i < feedbackLength; i += 1) {\n        feedback[i] /= feedback[0];\n      }\n    }\n\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n    scriptProcessorNode.channelCount = channelCount;\n    scriptProcessorNode.channelCountMode = channelCountMode;\n    scriptProcessorNode.channelInterpretation = channelInterpretation;\n    const bufferLength = 32;\n    const bufferIndexes = [];\n    const xBuffers = [];\n    const yBuffers = [];\n\n    for (let i = 0; i < channelCount; i += 1) {\n      bufferIndexes.push(0);\n      const xBuffer = new Float32Array(bufferLength);\n      const yBuffer = new Float32Array(bufferLength);\n      xBuffer.fill(0);\n      yBuffer.fill(0);\n      xBuffers.push(xBuffer);\n      yBuffers.push(yBuffer);\n    }\n\n    scriptProcessorNode.onaudioprocess = event => {\n      const inputBuffer = event.inputBuffer;\n      const outputBuffer = event.outputBuffer;\n      const numberOfChannels = inputBuffer.numberOfChannels;\n\n      for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = inputBuffer.getChannelData(i);\n        const output = outputBuffer.getChannelData(i);\n        bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n      }\n    };\n\n    const nyquist = nativeContext.sampleRate / 2;\n    const nativeIIRFilterNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return scriptProcessorNode.channelCount;\n      },\n\n      set channelCount(value) {\n        scriptProcessorNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return scriptProcessorNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        scriptProcessorNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return scriptProcessorNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        scriptProcessorNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return [scriptProcessorNode];\n      },\n\n      get numberOfInputs() {\n        return scriptProcessorNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return scriptProcessorNode.numberOfOutputs;\n      },\n\n      addEventListener(...args) {\n        // @todo Dissallow adding an audioprocess listener.\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n        if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n          throw createInvalidAccessError();\n        }\n\n        const length = frequencyHz.length;\n\n        for (let i = 0; i < length; i += 1) {\n          const omega = -Math.PI * (frequencyHz[i] / nyquist);\n          const z = [Math.cos(omega), Math.sin(omega)];\n          const numerator = evaluatePolynomial(feedforward, z);\n          const denominator = evaluatePolynomial(feedback, z);\n          const response = divide(numerator, denominator);\n          magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n          phaseResponse[i] = Math.atan2(response[1], response[0]);\n        }\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n  };\n};","export const createNativeMediaElementAudioSourceNodeFactory = createNativeAudioNode => {\n  return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n    return ntvDCntxt.createMediaElementSource(options.mediaElement);\n  });\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeMediaStreamAudioDestinationNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n  return (nativeAudioContext, options) => {\n    // Bug #64: Edge does not support MediaStreamAudioDestinationNodes.\n    if (nativeAudioContext.createMediaStreamDestination === undefined) {\n      throw createNotSupportedError();\n    }\n\n    const nativeMediaStreamAudioDestinationNode = createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      return ntvDCntxt.createMediaStreamDestination();\n    });\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options); // Bug #174: Safari does expose a wrong numberOfOutputs.\n\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n      Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', {\n        get: () => 0\n      });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n  };\n};","export const createNativeMediaStreamAudioSourceNodeFactory = createNativeAudioNode => {\n  return (nativeAudioContext, {\n    mediaStream\n  }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      /*\n       * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n       * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n       */\n      const filteredAudioStreamTracks = audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0).slice(0, 1);\n      return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n    }); // Bug #63: Edge does not expose the mediaStream yet.\n\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', {\n      value: mediaStream\n    });\n    return nativeMediaStreamAudioSourceNode;\n  };\n};","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode, isNativeOfflineAudioContext) => {\n  return (nativeAudioContext, {\n    mediaStreamTrack\n  }) => {\n    if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n      return createNativeAudioNode(nativeAudioContext, ntvDCntxt => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n    } // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n\n\n    return createNativeAudioNode(nativeAudioContext, ntvDCntxt => {\n      const mediaStream = new MediaStream([mediaStreamTrack]);\n      const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream); // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n\n      if (mediaStreamTrack.kind !== 'audio') {\n        throw createInvalidStateError();\n      } // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n\n\n      if (isNativeOfflineAudioContext(ntvDCntxt)) {\n        throw new TypeError();\n      }\n\n      return nativeMediaStreamAudioSourceNode;\n    });\n  };\n};","export const createNativeOfflineAudioContextConstructor = window => {\n  if (window === null) {\n    return null;\n  }\n\n  if (window.hasOwnProperty('OfflineAudioContext')) {\n    return window.OfflineAudioContext;\n  }\n\n  return window.hasOwnProperty('webkitOfflineAudioContext') ? window.webkitOfflineAudioContext : null;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n  return (nativeContext, options) => {\n    const nativeOscillatorNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n    assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n    if (options.periodicWave !== undefined) {\n      nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n    } else {\n      assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n    } // Bug #44: Only Chrome & Opera throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n    } // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeOscillatorNode);\n    return nativeOscillatorNode;\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n  return (nativeContext, options) => {\n    const nativePannerNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createPanner()); // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n\n    if (nativePannerNode.orientationX === undefined) {\n      return createNativePannerNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativePannerNode, options);\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n    assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n    assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n    return nativePannerNode;\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode, createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError, disconnectNativeAudioNodeFromNativeAudioNode, monitorConnections) => {\n  return (nativeContext, {\n    coneInnerAngle,\n    coneOuterAngle,\n    coneOuterGain,\n    distanceModel,\n    maxDistance,\n    orientationX,\n    orientationY,\n    orientationZ,\n    panningModel,\n    positionX,\n    positionY,\n    positionZ,\n    refDistance,\n    rolloffFactor,\n    ...audioNodeOptions\n  }) => {\n    const pannerNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createPanner()); // Bug #125: Safari does not throw an error yet.\n\n    if (audioNodeOptions.channelCount > 2) {\n      throw createNotSupportedError();\n    } // Bug #126: Safari does not throw an error yet.\n\n\n    if (audioNodeOptions.channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n    const SINGLE_CHANNEL_OPTIONS = {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete'\n    };\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      channelInterpretation: 'speakers',\n      numberOfInputs: 6\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 1\n    });\n    const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    });\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n    const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      curve: new Float32Array([1, 1]),\n      oversample: 'none'\n    });\n    let lastOrientation = [orientationX, orientationY, orientationZ];\n    let lastPosition = [positionX, positionY, positionZ];\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer\n    }) => {\n      const orientation = [inputBuffer.getChannelData(0)[0], inputBuffer.getChannelData(1)[0], inputBuffer.getChannelData(2)[0]];\n\n      if (orientation.some((value, index) => value !== lastOrientation[index])) {\n        pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n        lastOrientation = orientation;\n      }\n\n      const positon = [inputBuffer.getChannelData(3)[0], inputBuffer.getChannelData(4)[0], inputBuffer.getChannelData(5)[0]];\n\n      if (positon.some((value, index) => value !== lastPosition[index])) {\n        pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n        lastPosition = positon;\n      }\n    };\n\n    Object.defineProperty(orientationYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(orientationZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionXGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionYGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    Object.defineProperty(positionZGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    const nativePannerNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return pannerNode.channelCount;\n      },\n\n      set channelCount(value) {\n        // Bug #125: Safari does not throw an error yet.\n        if (value > 2) {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCount = value;\n        pannerNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return pannerNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        // Bug #126: Safari does not throw an error yet.\n        if (value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n        pannerNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return pannerNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        pannerNode.channelInterpretation = value;\n      },\n\n      get coneInnerAngle() {\n        return pannerNode.coneInnerAngle;\n      },\n\n      set coneInnerAngle(value) {\n        pannerNode.coneInnerAngle = value;\n      },\n\n      get coneOuterAngle() {\n        return pannerNode.coneOuterAngle;\n      },\n\n      set coneOuterAngle(value) {\n        pannerNode.coneOuterAngle = value;\n      },\n\n      get coneOuterGain() {\n        return pannerNode.coneOuterGain;\n      },\n\n      set coneOuterGain(value) {\n        // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n        if (value < 0 || value > 1) {\n          throw createInvalidStateError();\n        }\n\n        pannerNode.coneOuterGain = value;\n      },\n\n      get context() {\n        return pannerNode.context;\n      },\n\n      get distanceModel() {\n        return pannerNode.distanceModel;\n      },\n\n      set distanceModel(value) {\n        pannerNode.distanceModel = value;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get maxDistance() {\n        return pannerNode.maxDistance;\n      },\n\n      set maxDistance(value) {\n        // Bug #128: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.maxDistance = value;\n      },\n\n      get numberOfInputs() {\n        return pannerNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return pannerNode.numberOfOutputs;\n      },\n\n      get orientationX() {\n        return orientationXGainNode.gain;\n      },\n\n      get orientationY() {\n        return orientationYGainNode.gain;\n      },\n\n      get orientationZ() {\n        return orientationZGainNode.gain;\n      },\n\n      get panningModel() {\n        return pannerNode.panningModel;\n      },\n\n      set panningModel(value) {\n        pannerNode.panningModel = value; // Bug #123: Edge does not support HRTF as panningModel.\n\n        if (pannerNode.panningModel !== value && value === 'HRTF') {\n          throw createNotSupportedError();\n        }\n      },\n\n      get positionX() {\n        return positionXGainNode.gain;\n      },\n\n      get positionY() {\n        return positionYGainNode.gain;\n      },\n\n      get positionZ() {\n        return positionZGainNode.gain;\n      },\n\n      get refDistance() {\n        return pannerNode.refDistance;\n      },\n\n      set refDistance(value) {\n        // Bug #129: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.refDistance = value;\n      },\n\n      get rolloffFactor() {\n        return pannerNode.rolloffFactor;\n      },\n\n      set rolloffFactor(value) {\n        // Bug #130: Edge & Safari do not throw an error yet.\n        if (value < 0) {\n          throw new RangeError();\n        }\n\n        pannerNode.rolloffFactor = value;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n\n    if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n      nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n    }\n\n    if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n      nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n    }\n\n    if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n      nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n    }\n\n    if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n      nativePannerNodeFaker.distanceModel = distanceModel;\n    }\n\n    if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n      nativePannerNodeFaker.maxDistance = maxDistance;\n    }\n\n    if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n      nativePannerNodeFaker.orientationX.value = orientationX;\n    }\n\n    if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n      nativePannerNodeFaker.orientationY.value = orientationY;\n    }\n\n    if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n      nativePannerNodeFaker.orientationZ.value = orientationZ;\n    }\n\n    if (panningModel !== nativePannerNodeFaker.panningModel) {\n      nativePannerNodeFaker.panningModel = panningModel;\n    }\n\n    if (positionX !== nativePannerNodeFaker.positionX.value) {\n      nativePannerNodeFaker.positionX.value = positionX;\n    }\n\n    if (positionY !== nativePannerNodeFaker.positionY.value) {\n      nativePannerNodeFaker.positionY.value = positionY;\n    }\n\n    if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n      nativePannerNodeFaker.positionZ.value = positionZ;\n    }\n\n    if (refDistance !== nativePannerNodeFaker.refDistance) {\n      nativePannerNodeFaker.refDistance = refDistance;\n    }\n\n    if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n      nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n    }\n\n    if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n      pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n    }\n\n    if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n      pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n      waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n      waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n      waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n      waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n      waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n      channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(pannerNode); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n      disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n      waveShaperNode.disconnect(orientationXGainNode);\n      orientationXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationYGainNode);\n      orientationYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(orientationZGainNode);\n      orientationZGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionXGainNode);\n      positionXGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionYGainNode);\n      positionYGainNode.disconnect(channelMergerNode);\n      waveShaperNode.disconnect(positionZGainNode);\n      positionZGainNode.disconnect(channelMergerNode);\n      channelMergerNode.disconnect(scriptProcessorNode);\n      scriptProcessorNode.disconnect(nativeContext.destination);\n    };\n\n    return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n  };\n};","export const createNativePeriodicWaveFactory = getBackupNativeContext => {\n  return (nativeContext, {\n    disableNormalization,\n    imag,\n    real\n  }) => {\n    // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n    const backupNativeContext = getBackupNativeContext(nativeContext); // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n\n    const wrappedImag = new Float32Array(imag);\n    const wrappedReal = new Float32Array(real);\n\n    if (backupNativeContext !== null) {\n      return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, {\n        disableNormalization\n      });\n    }\n\n    return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, {\n      disableNormalization\n    });\n  };\n};","export const createNativeScriptProcessorNodeFactory = createNativeAudioNode => {\n  return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n    return createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n    });\n  };\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n  return (nativeContext, options) => createNativeAudioNode(nativeContext, ntvCntxt => {\n    const channelCountMode = options.channelCountMode;\n    /*\n     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n     * which supports it and therefore it can't be supported at all.\n     */\n\n    if (channelCountMode === 'clamped-max') {\n      throw createNotSupportedError();\n    } // Bug #105: Safari does not support the StereoPannerNode.\n\n\n    if (nativeContext.createStereoPanner === undefined) {\n      return createNativeStereoPannerNodeFaker(nativeContext, options);\n    }\n\n    const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n    assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n    /*\n     * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n     * which supports it and therefore it can't be supported at all.\n     */\n\n    Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n      get: () => channelCountMode,\n      set: value => {\n        if (value !== channelCountMode) {\n          throw createNotSupportedError();\n        }\n      }\n    });\n    return nativeStereoPannerNode;\n  });\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) => {\n  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n  const CURVE_SIZE = 16385;\n  const DC_CURVE = new Float32Array([1, 1]);\n  const HALF_PI = Math.PI / 2;\n  const SINGLE_CHANNEL_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete'\n  };\n  const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS,\n    oversample: 'none'\n  };\n\n  const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      const x = i / (CURVE_SIZE - 1) * HALF_PI;\n      leftWaveShaperCurve[i] = Math.cos(x);\n      rightWaveShaperCurve[i] = Math.sin(x);\n    }\n\n    const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(leftGainNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n        inputGainNode.disconnect(rightGainNode);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.disconnect(leftGainNode.gain);\n        rightWaveShaperNode.disconnect(rightGainNode.gain);\n        leftGainNode.disconnect(channelMergerNode, 0, 0);\n        rightGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n    const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n    for (let i = 0; i < CURVE_SIZE; i += 1) {\n      if (i > centerIndex) {\n        const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n        rightInputForLeftOutputWaveShaperCurve[i] = 0;\n        rightInputForRightOutputWaveShaperCurve[i] = 1;\n      } else {\n        const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = 1;\n        leftInputForRightOutputWaveShaperCurve[i] = 0;\n        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n      }\n    }\n\n    const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 2\n    });\n    const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForLeftOutputWaveShaperCurve\n    });\n    const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: leftInputForRightOutputWaveShaperCurve\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: DC_CURVE\n    });\n    const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForLeftOutputWaveShaperCurve\n    });\n    const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS,\n      gain: 0\n    }); // Bug #119: Safari does not fully support the WaveShaperNode.\n\n    const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n      curve: rightInputForRightOutputWaveShaperCurve\n    });\n    return {\n      connectGraph() {\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n      },\n\n      disconnectGraph() {\n        inputGainNode.disconnect(channelSplitterNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n\n    };\n  };\n\n  const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n    if (channelCount === 1) {\n      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    if (channelCount === 2) {\n      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n\n    throw createNotSupportedError();\n  };\n\n  return (nativeContext, {\n    channelCount,\n    channelCountMode,\n    pan,\n    ...audioNodeOptions\n  }) => {\n    if (channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n\n    const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...audioNodeOptions,\n      channelCount: 1,\n      channelCountMode,\n      numberOfInputs: 2\n    });\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      channelCount,\n      channelCountMode,\n      gain: 1\n    });\n    const panGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: pan\n    });\n    let {\n      connectGraph,\n      disconnectGraph\n    } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n    Object.defineProperty(panGainNode.gain, 'defaultValue', {\n      get: () => 0\n    });\n    const nativeStereoPannerNodeFakerFactory = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return inputGainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        if (inputGainNode.channelCount !== value) {\n          if (isConnected) {\n            disconnectGraph();\n          }\n\n          ({\n            connectGraph,\n            disconnectGraph\n          } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));\n\n          if (isConnected) {\n            connectGraph();\n          }\n        }\n\n        inputGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return inputGainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        if (value === 'clamped-max' || value === 'max') {\n          throw createNotSupportedError();\n        }\n\n        inputGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return inputGainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return inputGainNode.context;\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return inputGainNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return inputGainNode.numberOfOutputs;\n      },\n\n      get pan() {\n        return panGainNode.gain;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    let isConnected = false;\n\n    const whenConnected = () => {\n      connectGraph();\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      disconnectGraph();\n      isConnected = false;\n    };\n\n    return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n\n    try {\n      // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n      // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n      nativeWaveShaperNode.curve = new Float32Array([1]);\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    } catch {\n      /* Ignore errors. */\n    }\n\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve; // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    }\n\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n\n      return value;\n    });\n\n    const whenConnected = () => {\n      isConnected = true;\n\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeAudioNode, createNativeGainNode, isDCCurve, monitorConnections) => {\n  return (nativeContext, {\n    curve,\n    oversample,\n    ...audioNodeOptions\n  }) => {\n    const negativeWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n    const positiveWaveShaperNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createWaveShaper());\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: 1\n    });\n    const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: -1\n    });\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    let unmodifiedCurve = null;\n    const nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n\n      get curve() {\n        return unmodifiedCurve;\n      },\n\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          const curveLength = value.length;\n          const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          const length = Math.ceil((curveLength + 1) / 2);\n          const centerIndex = (curveLength + 1) / 2 - 1;\n\n          for (let i = 1; i < length; i += 1) {\n            const theoreticIndex = i / length * centerIndex;\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n\n        unmodifiedCurve = value;\n\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n\n      addEventListener(...args) {\n        return inputGainNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      dispatchEvent(...args) {\n        return inputGainNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n\n    if (curve !== nativeWaveShaperNodeFaker.curve) {\n      nativeWaveShaperNodeFaker.curve = curve;\n    }\n\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n\n    const whenConnected = () => {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n  return class OfflineAudioContext extends baseAudioContextConstructor {\n    constructor(a, b, c) {\n      let options;\n\n      if (typeof a === 'number' && b !== undefined && c !== undefined) {\n        options = {\n          length: b,\n          numberOfChannels: a,\n          sampleRate: c\n        };\n      } else if (typeof a === 'object') {\n        options = a;\n      } else {\n        throw new Error('The given parameters are not valid.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).then(audioBuffer => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        return audioBuffer;\n      }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n      .catch(err => {\n        this._state = null;\n        /*\n         * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n         * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n         */\n\n        throw err;\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","import { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  detune: 0,\n  frequency: 440,\n  type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (audioNodeConstructor, createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) => {\n  return class OscillatorNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer() : null;\n      const nyquist = context.sampleRate / 2;\n      super(context, false, nativeOscillatorNode, oscillatorNodeRenderer); // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n\n      this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600); // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n\n      this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n      this._nativeOscillatorNode = nativeOscillatorNode;\n      this._onended = null;\n      this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n      if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n        this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;\n      }\n    }\n\n    get detune() {\n      return this._detune;\n    }\n\n    get frequency() {\n      return this._frequency;\n    }\n\n    get onended() {\n      return this._onended;\n    }\n\n    set onended(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeOscillatorNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeOscillatorNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n\n    get type() {\n      return this._nativeOscillatorNode.type;\n    }\n\n    set type(value) {\n      this._nativeOscillatorNode.type = value; // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n\n      if (value === 'custom') {\n        throw createInvalidStateError();\n      }\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.periodicWave = null;\n      }\n    }\n\n    setPeriodicWave(periodicWave) {\n      this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.periodicWave = periodicWave;\n      }\n    }\n\n    start(when = 0) {\n      this._nativeOscillatorNode.start(when);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.start = when;\n      } else {\n        setInternalStateToActive(this);\n\n        const resetInternalStateToPassive = () => {\n          this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive); // @todo Determine a meaningful delay instead of just using one second.\n\n\n          setTimeout(() => setInternalStateToPassive(this), 1000);\n        };\n\n        this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n      }\n    }\n\n    stop(when = 0) {\n      this._nativeOscillatorNode.stop(when);\n\n      if (this._oscillatorNodeRenderer !== null) {\n        this._oscillatorNodeRenderer.stop = when;\n      }\n    }\n\n  };\n};","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createOscillatorNodeRendererFactory = (connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeOscillatorNodes = new WeakMap();\n    let periodicWave = null;\n    let start = null;\n    let stop = null;\n\n    const createOscillatorNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeOscillatorNode = getNativeAudioNode(proxy); // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n      if (!nativeOscillatorNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeOscillatorNode.channelCount,\n          channelCountMode: nativeOscillatorNode.channelCountMode,\n          channelInterpretation: nativeOscillatorNode.channelInterpretation,\n          detune: nativeOscillatorNode.detune.value,\n          frequency: nativeOscillatorNode.frequency.value,\n          periodicWave: periodicWave === null ? undefined : periodicWave,\n          type: nativeOscillatorNode.type\n        };\n        nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n        if (start !== null) {\n          nativeOscillatorNode.start(start);\n        }\n\n        if (stop !== null) {\n          nativeOscillatorNode.stop(stop);\n        }\n      }\n\n      renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n      if (!nativeOscillatorNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency, trace);\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode, trace);\n      return nativeOscillatorNode;\n    };\n\n    return {\n      set periodicWave(value) {\n        periodicWave = value;\n      },\n\n      set start(value) {\n        start = value;\n      },\n\n      set stop(value) {\n        stop = value;\n      },\n\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeOscillatorNode !== undefined) {\n          return Promise.resolve(renderedNativeOscillatorNode);\n        }\n\n        return createOscillatorNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'clamped-max',\n  channelInterpretation: 'speakers',\n  coneInnerAngle: 360,\n  coneOuterAngle: 360,\n  coneOuterGain: 0,\n  distanceModel: 'inverse',\n  maxDistance: 10000,\n  orientationX: 1,\n  orientationY: 0,\n  orientationZ: 0,\n  panningModel: 'equalpower',\n  positionX: 0,\n  positionY: 0,\n  positionZ: 0,\n  refDistance: 1,\n  rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class PannerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const pannerNodeRenderer = isOffline ? createPannerNodeRenderer() : null;\n      super(context, false, nativePannerNode, pannerNodeRenderer);\n      this._nativePannerNode = nativePannerNode; // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n\n      this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n\n    get coneInnerAngle() {\n      return this._nativePannerNode.coneInnerAngle;\n    }\n\n    set coneInnerAngle(value) {\n      this._nativePannerNode.coneInnerAngle = value;\n    }\n\n    get coneOuterAngle() {\n      return this._nativePannerNode.coneOuterAngle;\n    }\n\n    set coneOuterAngle(value) {\n      this._nativePannerNode.coneOuterAngle = value;\n    }\n\n    get coneOuterGain() {\n      return this._nativePannerNode.coneOuterGain;\n    }\n\n    set coneOuterGain(value) {\n      this._nativePannerNode.coneOuterGain = value;\n    }\n\n    get distanceModel() {\n      return this._nativePannerNode.distanceModel;\n    }\n\n    set distanceModel(value) {\n      this._nativePannerNode.distanceModel = value;\n    }\n\n    get maxDistance() {\n      return this._nativePannerNode.maxDistance;\n    }\n\n    set maxDistance(value) {\n      this._nativePannerNode.maxDistance = value;\n    }\n\n    get orientationX() {\n      return this._orientationX;\n    }\n\n    get orientationY() {\n      return this._orientationY;\n    }\n\n    get orientationZ() {\n      return this._orientationZ;\n    }\n\n    get panningModel() {\n      return this._nativePannerNode.panningModel;\n    }\n\n    set panningModel(value) {\n      this._nativePannerNode.panningModel = value;\n    }\n\n    get positionX() {\n      return this._positionX;\n    }\n\n    get positionY() {\n      return this._positionY;\n    }\n\n    get positionZ() {\n      return this._positionZ;\n    }\n\n    get refDistance() {\n      return this._nativePannerNode.refDistance;\n    }\n\n    set refDistance(value) {\n      this._nativePannerNode.refDistance = value;\n    }\n\n    get rolloffFactor() {\n      return this._nativePannerNode.rolloffFactor;\n    }\n\n    set rolloffFactor(value) {\n      this._nativePannerNode.rolloffFactor = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createPannerNodeRendererFactory = (connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let renderedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeGainNode = null;\n      let nativePannerNode = getNativeAudioNode(proxy);\n      const commonAudioNodeOptions = {\n        channelCount: nativePannerNode.channelCount,\n        channelCountMode: nativePannerNode.channelCountMode,\n        channelInterpretation: nativePannerNode.channelInterpretation\n      };\n      const commonNativePannerNodeOptions = { ...commonAudioNodeOptions,\n        coneInnerAngle: nativePannerNode.coneInnerAngle,\n        coneOuterAngle: nativePannerNode.coneOuterAngle,\n        coneOuterGain: nativePannerNode.coneOuterGain,\n        distanceModel: nativePannerNode.distanceModel,\n        maxDistance: nativePannerNode.maxDistance,\n        panningModel: nativePannerNode.panningModel,\n        refDistance: nativePannerNode.refDistance,\n        rolloffFactor: nativePannerNode.rolloffFactor\n      }; // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext); // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n\n      if ('bufferSize' in nativePannerNode) {\n        nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n      } else if (!nativePannerNodeIsOwnedByContext) {\n        const options = { ...commonNativePannerNodeOptions,\n          orientationX: nativePannerNode.orientationX.value,\n          orientationY: nativePannerNode.orientationY.value,\n          orientationZ: nativePannerNode.orientationZ.value,\n          positionX: nativePannerNode.positionX.value,\n          positionY: nativePannerNode.positionY.value,\n          positionZ: nativePannerNode.positionZ.value\n        };\n        nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n      if (nativeGainNode !== null) {\n        if (renderedBufferPromise === null) {\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          }\n\n          const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(6, // Bug #17: Safari does not yet expose the length.\n          proxy.context.length, nativeOfflineAudioContext.sampleRate);\n          const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n          });\n          nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n          renderedBufferPromise = (async () => {\n            const nativeConstantSourceNodes = await Promise.all([proxy.orientationX, proxy.orientationY, proxy.orientationZ, proxy.positionX, proxy.positionY, proxy.positionZ].map(async (audioParam, index) => {\n              const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: index === 0 ? 1 : 0\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset, trace);\n              return nativeConstantSourceNode;\n            }));\n\n            for (let i = 0; i < 6; i += 1) {\n              nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n              nativeConstantSourceNodes[i].start(0);\n            }\n\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          })();\n        }\n\n        const renderedBuffer = await renderedBufferPromise;\n        const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode, trace);\n        const channelDatas = [];\n\n        for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n          channelDatas.push(renderedBuffer.getChannelData(i));\n        }\n\n        let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n        let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n        let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n          gain: 1\n        });\n        let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n          orientationX: lastOrientation[0],\n          orientationY: lastOrientation[1],\n          orientationZ: lastOrientation[2],\n          positionX: lastPosition[0],\n          positionY: lastPosition[1],\n          positionZ: lastPosition[2]\n        });\n        inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n        partialPannerNode.connect(nativeGainNode);\n\n        for (let i = 128; i < renderedBuffer.length; i += 128) {\n          const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n          const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n          if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {\n            lastOrientation = orientation;\n            lastPosition = positon;\n            const currentTime = i / nativeOfflineAudioContext.sampleRate;\n            gateGainNode.gain.setValueAtTime(0, currentTime);\n            gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions,\n              gain: 0\n            });\n            partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, { ...commonNativePannerNodeOptions,\n              orientationX: lastOrientation[0],\n              orientationY: lastOrientation[1],\n              orientationZ: lastOrientation[2],\n              positionX: lastPosition[0],\n              positionY: lastPosition[1],\n              positionZ: lastPosition[2]\n            });\n            gateGainNode.gain.setValueAtTime(1, currentTime);\n            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);\n            partialPannerNode.connect(nativeGainNode);\n          }\n        }\n\n        return nativeGainNode;\n      }\n\n      if (!nativePannerNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n        await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY, trace);\n        await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ, trace);\n      }\n\n      if (isNativeAudioNodeFaker(nativePannerNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode, trace);\n      }\n\n      return nativePannerNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n          return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","const DEFAULT_OPTIONS = {\n  disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, getNativeContext, periodicWaveStore) => {\n  return class PeriodicWave {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n      periodicWaveStore.add(periodicWave); // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n\n      return periodicWave;\n    }\n\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);\n    }\n\n  };\n};","export const createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam, trace) => {\n    const audioParamRenderer = getAudioParamRenderer(audioParam);\n    audioParamRenderer.replay(nativeAudioParam);\n    return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam, trace);\n  };\n};","export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode, trace) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    const nextTrace = [...trace, audioNode];\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).filter(([source]) => !nextTrace.includes(source)).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, nextTrace);\n      const destination = audioNode.context.destination;\n\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","export const createRenderInputsOfAudioParam = (getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle) => {\n  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam, trace) => {\n    const audioParamConnections = getAudioParamConnections(audioParam);\n    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext, trace);\n\n      if (!isPartOfACycle(source)) {\n        renderedNativeAudioNode.connect(nativeAudioParam, output);\n      }\n    }));\n  };\n};","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n  return nativeOfflineAudioContext => {\n    // Bug #21: Safari does not support promises yet.\n    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n      // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n      return Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then(isOfflineAudioContextCurrentTimeSupported => {\n        if (!isOfflineAudioContextCurrentTimeSupported) {\n          const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n          nativeOfflineAudioContext.oncomplete = () => {\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            scriptProcessorNode.disconnect();\n          };\n\n          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n\n          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n        }\n\n        return nativeOfflineAudioContext.startRendering();\n      });\n    }\n\n    return new Promise(resolve => {\n      // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n      const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        gain: 0\n      });\n\n      nativeOfflineAudioContext.oncomplete = event => {\n        gainNode.disconnect();\n        resolve(event.renderedBuffer);\n      };\n\n      gainNode.connect(nativeOfflineAudioContext.destination);\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  const trace = [];\n  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext, trace)\n  /*\n   * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n   * destination.\n   */\n  .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(audioWorkletNode => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace)))).then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext)).then(audioBuffer => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n    if (typeof audioBuffer.copyFromChannel !== 'function') {\n      wrapAudioBufferCopyChannelMethods(audioBuffer);\n      wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n    } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n      wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n    }\n\n    audioBufferStore.add(audioBuffer);\n    return audioBuffer;\n  });\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n\n  /*\n   * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n   * behavior.\n   */\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  pan: 0\n};\nexport const createStereoPannerNodeConstructor = (audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class StereoPannerNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer() : null;\n      super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer); // Bug #106: Edge does not export a maxValue and minValue property.\n\n      this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n    }\n\n    get pan() {\n      return this._pan;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createStereoPannerNodeRendererFactory = (connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeStereoPannerNodes = new WeakMap();\n\n    const createStereoPannerNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeStereoPannerNode = getNativeAudioNode(proxy);\n      /*\n       * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n       * again.\n       */\n\n      const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n      if (!nativeStereoPannerNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeStereoPannerNode.channelCount,\n          channelCountMode: nativeStereoPannerNode.channelCountMode,\n          channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n          pan: nativeStereoPannerNode.pan.value\n        };\n        nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n      if (!nativeStereoPannerNodeIsOwnedByContext) {\n        await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n      } else {\n        await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan, trace);\n      }\n\n      if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode, trace);\n      }\n\n      return nativeStereoPannerNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeStereoPannerNode !== undefined) {\n          return Promise.resolve(renderedNativeStereoPannerNode);\n        }\n\n        return createStereoPannerNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = nativeAudioBufferConstructor => {\n  return () => {\n    if (nativeAudioBufferConstructor === null) {\n      return false;\n    }\n\n    try {\n      new nativeAudioBufferConstructor({\n        length: 1,\n        sampleRate: 44100\n      }); // tslint:disable-line:no-unused-expression\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    if (nativeAudioBuffer.copyToChannel === undefined) {\n      return true;\n    }\n\n    const source = new Float32Array(2);\n\n    try {\n      nativeAudioBuffer.copyFromChannel(source, 0, 0);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.start();\n\n    try {\n      nativeAudioBufferSourceNode.start();\n    } catch {\n      return true;\n    }\n\n    return false;\n  };\n};","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n    const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n    audioBuffer.getChannelData(0)[0] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.start(0, 0, 0);\n    audioBufferSourceNode.connect(offlineAudioContext.destination); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      offlineAudioContext.oncomplete = ({\n        renderedBuffer\n      }) => {\n        // Bug #5: Safari does not support copyFromChannel().\n        resolve(renderedBuffer.getChannelData(0)[0] === 0);\n      };\n\n      offlineAudioContext.startRendering();\n    });\n  };\n};","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n      nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioBufferSourceNodeStopMethodNullifiedBufferSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.start();\n\n    try {\n      nativeAudioBufferSourceNode.stop();\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestAudioContextCloseMethodSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    } // Try to check the prototype before constructing the AudioContext.\n\n\n    if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n      return true;\n    }\n\n    const audioContext = new nativeAudioContextConstructor();\n    const isAudioContextClosable = audioContext.close !== undefined;\n\n    try {\n      audioContext.close();\n    } catch {// Ignore errors.\n    }\n\n    return isAudioContextClosable;\n  };\n};","/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      let isPending = true;\n\n      const resolvePromise = err => {\n        if (isPending) {\n          isPending = false;\n          offlineAudioContext.startRendering();\n          resolve(err instanceof TypeError);\n        }\n      };\n\n      let promise; // Bug #26: Safari throws a synchronous error.\n\n      try {\n        promise = offlineAudioContext // Bug #1: Safari requires a successCallback.\n        .decodeAudioData(null, () => {// Ignore the success callback.\n        }, resolvePromise);\n      } catch (err) {\n        resolvePromise(err);\n      } // Bug #21: Safari does not support promises yet.\n\n\n      if (promise !== undefined) {\n        // Bug #6 Chrome does not call the errorCallback\n        promise.catch(resolvePromise);\n      }\n    });\n  };\n};","export const createTestAudioContextOptionsSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    }\n\n    let audioContext;\n\n    try {\n      audioContext = new nativeAudioContextConstructor({\n        latencyHint: 'balanced'\n      });\n    } catch {\n      return false;\n    }\n\n    audioContext.close();\n    return true;\n  };\n};","// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeGainNode = nativeOfflineAudioContext.createGain();\n    const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n    nativeGainNode.disconnect(nativeGainNode);\n    return isSupported;\n  };\n};","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n\n    try {\n      nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n      return err instanceof RangeError;\n    }\n\n    return false;\n  };\n};","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n      nativeAudioBufferSourceNode.stop();\n      return true;\n    } catch {\n      return false;\n    }\n  };\n};","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createNativeAudioNode => {\n  return nativeContext => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createOscillator());\n\n    try {\n      nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n      return err instanceof RangeError;\n    }\n\n    return false;\n  };\n};","/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport = (nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor) => {\n  return async () => {\n    // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n    if (nativeAudioWorkletNodeConstructor === null) {\n      return true;\n    }\n\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const blob = new Blob(['class A extends AudioWorkletProcessor{process(){this.port.postMessage(0)}}registerProcessor(\"a\",A)'], {\n      type: 'application/javascript; charset=utf-8'\n    });\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 3200);\n    const url = URL.createObjectURL(blob);\n    let isCallingProcess = false;\n\n    try {\n      await offlineAudioContext.audioWorklet.addModule(url);\n      const gainNode = offlineAudioContext.createGain();\n      const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', {\n        numberOfOutputs: 0\n      });\n\n      audioWorkletNode.port.onmessage = () => isCallingProcess = true;\n\n      gainNode.connect(audioWorkletNode);\n      await offlineAudioContext.startRendering();\n    } catch {// Ignore errors.\n    } finally {\n      URL.revokeObjectURL(url);\n    }\n\n    return isCallingProcess;\n  };\n};","/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeChannelMergerNode = createNativeAudioNode(offlineAudioContext, ntvCntxt => ntvCntxt.createChannelMerger());\n\n    try {\n      nativeChannelMergerNode.channelCount = 2;\n    } catch {\n      return true;\n    }\n\n    return false;\n  };\n};","export const createTestConstantSourceNodeAccurateSchedulingSupport = (createNativeAudioNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n\n    if (nativeOfflineAudioContext.createConstantSource === undefined) {\n      return true;\n    }\n\n    const nativeConstantSourceNode = createNativeAudioNode(nativeOfflineAudioContext, ntvCntxt => ntvCntxt.createConstantSource());\n    /*\n     * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n     * the implementation of Firefox right now, but it could probably be done in a better way.\n     */\n\n    return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n  };\n};","// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return false;\n    }\n\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    const nativeConvolverNode = offlineAudioContext.createConvolver();\n    nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n\n    try {\n      nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n    } catch {\n      return false;\n    }\n\n    return true;\n  };\n};","export const createTestIsSecureContextSupport = window => {\n  return () => window !== null && window.hasOwnProperty('isSecureContext');\n};","// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport = nativeAudioContextConstructor => {\n  return () => {\n    if (nativeAudioContextConstructor === null) {\n      return false;\n    }\n\n    const audioContext = new nativeAudioContextConstructor();\n\n    try {\n      audioContext.createMediaStreamSource(new MediaStream());\n      return false;\n    } catch (err) {\n      return true;\n    }\n  };\n};","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100); // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n\n    const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    }); // Bug #21: Safari does not support promises yet.\n\n    return new Promise(resolve => {\n      nativeOfflineAudioContext.oncomplete = () => {\n        gainNode.disconnect();\n        resolve(nativeOfflineAudioContext.currentTime !== 0);\n      };\n\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};","/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport = nativeOfflineAudioContextConstructor => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor === null) {\n      return Promise.resolve(false);\n    }\n\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n    /*\n     * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n     * support the tested behaviour.\n     */\n\n    if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n      return Promise.resolve(true);\n    } // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n\n\n    if (nativeOfflineAudioContext.createConstantSource === undefined) {\n      return Promise.resolve(true);\n    }\n\n    const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n    const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n    constantSourceNode.channelCount = 1;\n    constantSourceNode.offset.value = 1;\n    stereoPanner.channelCount = 1;\n    constantSourceNode.start();\n    constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n    return nativeOfflineAudioContext.startRendering().then(buffer => buffer.getChannelData(0)[0] !== 1);\n  };\n};","const DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  curve: null,\n  oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class WaveShaperNode extends audioNodeConstructor {\n    constructor(context, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null; // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n\n      super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n      this._isCurveNullified = false;\n      this._nativeWaveShaperNode = nativeWaveShaperNode;\n    }\n\n    get curve() {\n      if (this._isCurveNullified) {\n        return null;\n      }\n\n      return this._nativeWaveShaperNode.curve;\n    }\n\n    set curve(value) {\n      // Bug #103: Safari does not allow to set the curve to null.\n      if (value === null) {\n        this._isCurveNullified = true;\n        this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n      } else {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (value.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        this._isCurveNullified = false;\n        this._nativeWaveShaperNode.curve = value;\n      }\n    }\n\n    get oversample() {\n      return this._nativeWaveShaperNode.oversample;\n    }\n\n    set oversample(value) {\n      this._nativeWaveShaperNode.oversample = value;\n    }\n\n  };\n};","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeWaveShaperNodes = new WeakMap();\n\n    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n      if (!nativeWaveShaperNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeWaveShaperNode.channelCount,\n          channelCountMode: nativeWaveShaperNode.channelCountMode,\n          channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n          curve: nativeWaveShaperNode.curve,\n          oversample: nativeWaveShaperNode.oversample\n        };\n        nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0], trace);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode, trace);\n      }\n\n      return nativeWaveShaperNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeWaveShaperNode !== undefined) {\n          return Promise.resolve(renderedNativeWaveShaperNode);\n        }\n\n        return createWaveShaperNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","export const createWindow = () => typeof window === 'undefined' ? null : window;","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const destinationLength = destination.length;\n\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n        destination[i] = channelData[i + bufferOffset];\n      }\n    };\n\n    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError();\n      }\n\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const sourceLength = source.length;\n\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n        channelData[i + bufferOffset] = source[i];\n      }\n    };\n  };\n};","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = convertNumberToUnsignedLong => {\n  return audioBuffer => {\n    audioBuffer.copyFromChannel = (copyFromChannel => {\n      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyFromChannel);\n\n    audioBuffer.copyToChannel = (copyToChannel => {\n      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyToChannel);\n  };\n};","export const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = overwriteAccessors => {\n  return (nativeAudioBufferSourceNode, nativeContext) => {\n    const nullifiedBuffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n\n    if (nativeAudioBufferSourceNode.buffer === null) {\n      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n    }\n\n    overwriteAccessors(nativeAudioBufferSourceNode, 'buffer', get => () => {\n      const value = get.call(nativeAudioBufferSourceNode);\n      return value === nullifiedBuffer ? null : value;\n    }, set => value => {\n      return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n    });\n  };\n};","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createNativeAudioNode => {\n  return (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createGain());\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = (disconnect => {\n      return () => {\n        // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n        disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n      };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = (stop => {\n      let isStopped = false;\n      return (when = 0) => {\n        if (isStopped) {\n          try {\n            stop.call(nativeAudioScheduledSourceNode, when);\n          } catch {\n            nativeGainNode.gain.setValueAtTime(0, when);\n          }\n        } else {\n          stop.call(nativeAudioScheduledSourceNode, when);\n          isStopped = true;\n        }\n      };\n    })(nativeAudioScheduledSourceNode.stop);\n  };\n};","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode, monitorConnectionsFunction) => {\n  return (nativeContext, channelMergerNode) => {\n    channelMergerNode.channelCount = 1;\n    channelMergerNode.channelCountMode = 'explicit';\n    Object.defineProperty(channelMergerNode, 'channelCount', {\n      get: () => 1,\n      set: () => {\n        throw createInvalidStateError();\n      }\n    });\n    Object.defineProperty(channelMergerNode, 'channelCountMode', {\n      get: () => 'explicit',\n      set: () => {\n        throw createInvalidStateError();\n      }\n    }); // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n\n    const audioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n\n    const whenConnected = () => {\n      const length = channelMergerNode.numberOfInputs;\n\n      for (let i = 0; i < length; i += 1) {\n        audioBufferSourceNode.connect(channelMergerNode, 0, i);\n      }\n    };\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n    monitorConnectionsFunction(channelMergerNode, whenConnected, whenDisconnected);\n  };\n};","// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () => new Promise(resolve => {\n  const arrayBuffer = new ArrayBuffer(0);\n  const {\n    port1,\n    port2\n  } = new MessageChannel();\n\n  port1.onmessage = ({\n    data\n  }) => resolve(data !== null);\n\n  port2.postMessage(arrayBuffer, [arrayBuffer]);\n});","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = nativeAudioBufferSourceNode => {\n  nativeAudioBufferSourceNode.start = (start => {\n    return (when = 0, offset = 0, duration) => {\n      const buffer = nativeAudioBufferSourceNode.buffer; // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n\n      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset); // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n\n      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n        start.call(nativeAudioBufferSourceNode, when, 0, 0);\n      } else {\n        start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n      }\n    };\n  })(nativeAudioBufferSourceNode.start);\n};","export const isAudioWorkletNode = audioNode => {\n  return 'port' in audioNode;\n};","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n  const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n  if (!eventListeners.delete(eventListener)) {\n    throw new Error('Missing the expected event listener.');\n  }\n};","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = audioNode => {\n  return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};","export const pickElementFromSet = (set, predicate) => {\n  const matchingElements = Array.from(set).filter(predicate);\n\n  if (matchingElements.length > 1) {\n    throw Error('More than one element was found.');\n  }\n\n  if (matchingElements.length === 0) {\n    throw Error('No element was found.');\n  }\n\n  const [matchingElement] = matchingElements;\n  set.delete(matchingElement);\n  return matchingElement;\n};","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive'; // Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\n\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n  if (!isAudioWorkletNode(audioNode) && activeInputs.every(connections => connections.size === 0)) {\n    setInternalStateToPassive(audioNode);\n  }\n};","export const testAudioNodeDisconnectMethodSupport = nativeAudioContext => {\n  return new Promise(resolve => {\n    const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n    const dummy = nativeAudioContext.createGain(); // Bug #95: Safari does not play one sample buffers.\n\n    const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n    const channelData = ones.getChannelData(0);\n    channelData[0] = 1;\n    channelData[1] = 1;\n    const source = nativeAudioContext.createBufferSource();\n    source.buffer = ones;\n    source.loop = true;\n    source.connect(analyzer).connect(nativeAudioContext.destination);\n    source.connect(dummy);\n    source.disconnect(dummy);\n\n    analyzer.onaudioprocess = event => {\n      const chnnlDt = event.inputBuffer.getChannelData(0);\n\n      if (Array.prototype.some.call(chnnlDt, sample => sample === 1)) {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n\n      source.stop();\n      analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n      source.disconnect(analyzer);\n      analyzer.disconnect(nativeAudioContext.destination);\n    };\n\n    source.start();\n  });\n};","export const visitEachAudioNodeOnce = (cycles, visitor) => {\n  const counts = new Map();\n\n  for (const cycle of cycles) {\n    for (const audioNode of cycle) {\n      const count = counts.get(audioNode);\n      counts.set(audioNode, count === undefined ? 1 : count + 1);\n    }\n  }\n\n  counts.forEach((count, audioNode) => visitor(audioNode, count));\n};","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n\n  nativeAudioNode.connect = (connect => {\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.\n\n      const connectionsToDestination = connections.get(destination);\n\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n  insertElementInSet(activeInputs[input], [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n  insertElementInSet(activeInputs, [source, output, eventListener], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\n\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n  return pickElementFromSet(activeInputs[input], activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n  return pickElementFromSet(activeInputs, activeInputConnection => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\n\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n  const passiveInputConnections = passiveInputs.get(source);\n\n  if (passiveInputConnections === undefined) {\n    passiveInputs.set(source, new Set([[output, input, eventListener]]));\n  } else {\n    insertElementInSet(passiveInputConnections, [output, input, eventListener], passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n  }\n};\n\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n  const passiveInputConnections = passiveInputs.get(source);\n\n  if (passiveInputConnections === undefined) {\n    passiveInputs.set(source, new Set([[output, eventListener]]));\n  } else {\n    insertElementInSet(passiveInputConnections, [output, eventListener], passiveInputConnection => passiveInputConnection[0] === output, ignoreDuplicates);\n  }\n};\n\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n\n  return matchingConnection;\n};\n\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, passiveInputConnection => passiveInputConnection[0] === output);\n\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n\n  return matchingConnection;\n};\n\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeDestinationAudioNode = getNativeAudioNode(destination);\n    const nativeSourceAudioNode = getNativeAudioNode(source);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n      addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n      }\n\n      if (isPassiveAudioNode(destination)) {\n        setInternalStateToActive(destination);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n      addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n      }\n\n      if (isActiveAudioNode(destination)) {\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n\n  if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n      if (!isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    const {\n      activeInputs\n    } = getAudioParamConnections(destination);\n    addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n    return true;\n  }\n\n  return false;\n};\n\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n  for (const activeInputConnection of activeInputConnections) {\n    if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n      activeInputConnections.delete(activeInputConnection);\n      return activeInputConnection;\n    }\n  }\n\n  return null;\n};\n\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nconst deleteAnyConnection = source => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, ...outputConnection);\n    }\n\n    destinations.push(outputConnection[0]);\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nconst deleteConnectionAtOutput = (source, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, ...outputConnection);\n      }\n\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n\n  return destinations;\n};\n\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, ...outputConnection);\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport const createAudioNodeConstructor = (addAudioNodeConnections, auxiliaryGainNodeStore, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n  return class AudioNode extends eventTargetConstructor {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, new Set());\n\n      if (isActive) {\n        setInternalStateToActive(this);\n      }\n\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n\n    get context() {\n      return this._context;\n    }\n\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    }\n\n    connect(destination, output = 0, input = 0) {\n      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n        throw createInvalidAccessError();\n      }\n\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n\n          if (isOffline || isPassiveAudioNode(this)) {\n            this._nativeAudioNode.disconnect(...connection);\n          } else if (isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          } // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n          // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n\n\n          if (isAudioWorkletNode(destination)) {\n            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeDestinationAudioNode);\n\n            if (auxiliaryGainNodes === undefined) {\n              const nativeGainNode = nativeContext.createGain();\n              nativeGainNode.connect(connection[0], 0, connection[2]);\n              auxiliaryGainNodeStore.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n            } else if (auxiliaryGainNodes.get(input) === undefined) {\n              const nativeGainNode = nativeContext.createGain();\n              nativeGainNode.connect(connection[0], 0, connection[2]);\n              auxiliaryGainNodes.set(input, nativeGainNode);\n            }\n          }\n        } catch (err) {\n          // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        const isNewConnectionToAudioNode = isOffline ? addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input) : addConnectionToAudioNodeOfAudioContext(this, destination, output, input); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n\n        return destination;\n      }\n\n      const nativeAudioParam = getNativeAudioParam(destination);\n      /*\n       * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n       * Safari.\n       */\n\n      if (nativeAudioParam.name === 'playbackRate') {\n        throw createNotSupportedError();\n      }\n\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err) {\n        // Bug #58: Only Firefox does throw an InvalidStateError yet.\n        if (err.code === 12) {\n          throw createInvalidAccessError();\n        }\n\n        throw err;\n      }\n\n      const isNewConnectionToAudioParam = isOffline ? addConnectionToAudioParamOfOfflineAudioContext(this, destination, output) : addConnectionToAudioParamOfAudioContext(this, destination, output); // Bug #164: Only Firefox detects cycles so far.\n\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n\n      if (destinationOrOutput === undefined) {\n        destinations = deleteAnyConnection(this);\n      } else if (typeof destinationOrOutput === 'number') {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionAtOutput(this, destinationOrOutput);\n      } else {\n        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError();\n        }\n\n        if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionToDestination(this, destinationOrOutput, output, input);\n\n        if (destinations.length === 0) {\n          throw createInvalidAccessError();\n        }\n      } // Bug #164: Only Firefox detects cycles so far.\n\n\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n\n  };\n};","export const cloneAudioWorkletNodeOptions = audioWorkletNodeOptions => {\n  return new Promise((resolve, reject) => {\n    const {\n      port1,\n      port2\n    } = new MessageChannel();\n\n    port1.onmessage = ({\n      data\n    }) => {\n      port1.close();\n      port2.close();\n      resolve(data);\n    };\n\n    port1.onmessageerror = ({\n      data\n    }) => {\n      port1.close();\n      port2.close();\n      reject(data);\n    }; // This will throw an error if the audioWorkletNodeOptions are not clonable.\n\n\n    port2.postMessage(audioWorkletNodeOptions);\n  });\n};","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n  const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n  return new processorConstructor(clonedAudioWorkletNodeOptions);\n};","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    if (options.outputChannelCount !== undefined) {\n      // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n      if (options.outputChannelCount.some(channelCount => channelCount < 1)) {\n        throw createNotSupportedError();\n      }\n\n      if (options.outputChannelCount.length !== options.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    const constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const {\n        defaultValue,\n        maxValue,\n        minValue,\n        name\n      } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: options.outputChannelCount[i]\n      }));\n    }\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(({\n      name\n    }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n\n    };\n    const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return (...args) => {\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, {\n      name\n    }) => ({ ...prmtrs,\n      [name]: new Float32Array(128)\n    }), {});\n    let isActive = true;\n\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n        for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n\n        outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n      }\n    };\n\n    scriptProcessorNode.onaudioprocess = ({\n      inputBuffer,\n      outputBuffer\n    }) => {\n      if (audioWorkletProcessor !== null) {\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({\n              name\n            }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n\n              if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                return [];\n              }\n\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n\n              outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              error\n            }));\n          }\n\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n\n            break;\n          }\n        }\n      }\n    };\n\n    let isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode)\n    /*\n     * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n     * to make sure to connect the right destination.\n     */\n    .connect(nativeGainNode.context.destination);\n\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n  let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n  if (nodeToProcessorMap === undefined) {\n    nodeToProcessorMap = new WeakMap();\n    NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n  }\n\n  const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n  return audioWorkletProcessorPromise;\n};","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (addSilentConnection, cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n  return (nativeContext, options = {}) => {\n    const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createBufferSource());\n    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate'); // Bug #71: Edge does not allow to set the buffer to null.\n\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer'); // Bug #149: Safari does not yet support the detune AudioParam.\n\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart'); // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n    } // Bug #92: Chrome & Edge do not respect the duration parameter yet.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n      wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n    } // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n\n\n    if (!cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))) {\n      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n    } // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n    } // Bug #44: Only Firefox does not throw a RangeError yet.\n\n\n    if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n    } // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n    return nativeAudioBufferSourceNode;\n  };\n};","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = nativeAudioBufferSourceNode => {\n  nativeAudioBufferSourceNode.start = (start => {\n    let isScheduled = false;\n    return (when = 0, offset = 0, duration) => {\n      if (isScheduled) {\n        throw createInvalidStateError();\n      }\n\n      start.call(nativeAudioBufferSourceNode, when, offset, duration);\n      isScheduled = true;\n    };\n  })(nativeAudioBufferSourceNode.start);\n};","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n  let endTime = Number.POSITIVE_INFINITY;\n  let stopTime = Number.POSITIVE_INFINITY;\n\n  nativeAudioScheduledSourceNode.start = ((start, stop) => {\n    return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n      start.call(nativeAudioScheduledSourceNode, when, offset);\n\n      if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n        const actualStartTime = Math.max(when, nativeContext.currentTime); // @todo The playbackRate could of course also have been automated and is not always fixed.\n\n        const durationInBufferTime = duration / nativeAudioScheduledSourceNode.playbackRate.value;\n        endTime = actualStartTime + durationInBufferTime;\n        stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n      }\n    };\n  })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    return (when = 0) => {\n      stopTime = Math.max(when, nativeContext.currentTime);\n      stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = nativeAnalyserNode => {\n  return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n  return (nativeContext, options) => {\n    const nativeAnalyserNode = createNativeAudioNode(nativeContext, ntvCntxt => ntvCntxt.createAnalyser()); // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n\n    assignNativeAudioNodeOptions(nativeAnalyserNode, options); // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n\n    if (!(options.maxDecibels > options.minDecibels)) {\n      throw createIndexSizeError();\n    }\n\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n    assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant'); // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n\n    if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n      wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n    }\n\n    return nativeAnalyserNode;\n  };\n};","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = nativeAnalyserNode => {\n  nativeAnalyserNode.getFloatTimeDomainData = array => {\n    const byteTimeDomainData = new Uint8Array(array.length);\n    nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n    const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n    for (let i = 0; i < length; i += 1) {\n      array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n    }\n\n    return array;\n  };\n};","const handler = {\n  construct() {\n    return handler;\n  }\n\n};\nexport const isConstructible = constructible => {\n  try {\n    const proxy = new Proxy(constructible, handler);\n    new proxy(); // tslint:disable-line:no-unused-expression\n  } catch {\n    return false;\n  }\n\n  return true;\n};","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source, url) => {\n  const importStatements = [];\n  let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n  while (result !== null) {\n    const unresolvedUrl = result[1].slice(1, -1);\n    const importStatementWithResolvedUrl = result[0].replace(/([\\s]+)?;?$/, '').replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n    importStatements.push(importStatementWithResolvedUrl);\n    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n  }\n\n  return [importStatements.join(';'), sourceWithoutImportStatements];\n};","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\n\nconst verifyParameterDescriptors = parameterDescriptors => {\n  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n  }\n};\n\nconst verifyProcessorCtor = processorCtor => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError('The given value for processorCtor should be a constructor.');\n  }\n\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n    throw new TypeError('The given value for processorCtor should have a prototype.');\n  }\n};\n\nexport const createAddAudioWorkletModule = (createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, getNativeContext, ongoingRequests, resolvedRequests, window) => {\n  return (context, moduleURL, options = {\n    credentials: 'omit'\n  }) => {\n    const nativeContext = getNativeContext(context);\n    const absoluteUrl = new URL(moduleURL, window.location.href).toString(); // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n\n    if (nativeContext.audioWorklet !== undefined) {\n      return fetchSource(moduleURL).then(source => {\n        const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n        /*\n         * Bug #170: Chrome and Opera do call process() with an array with empty channelData for each input if no input is\n         * connected.\n         *\n         * This is the unminified version of the code used below:\n         *\n         * ```js\n         * `${ importStatements };\n         * ((registerProcessor) => {${ sourceWithoutImportStatements }\n         * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n         *\n         *     process (inputs, outputs, parameters) {\n         *         return super.process(\n         *             (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n         *             outputs,\n         *             parameters\n         *         );\n         *     }\n         *\n         * }))`\n         * ```\n         */\n\n        const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{process(i,o,p){return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}))`; // tslint:disable-line:max-line-length\n\n        const blob = new Blob([wrappedSource], {\n          type: 'application/javascript; charset=utf-8'\n        });\n        const url = URL.createObjectURL(blob);\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        const nativeContextOrBackupNativeContext = backupNativeContext !== null ? backupNativeContext : nativeContext;\n        return nativeContextOrBackupNativeContext.audioWorklet.addModule(url, options).then(() => URL.revokeObjectURL(url)) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n        .catch(err => {\n          URL.revokeObjectURL(url);\n\n          if (err.code === undefined || err.name === 'SyntaxError') {\n            err.code = 12;\n          }\n\n          throw err;\n        });\n      });\n    }\n\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n    if (ongoingRequestsOfContext !== undefined) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n      if (promiseOfOngoingRequest !== undefined) {\n        return promiseOfOngoingRequest;\n      }\n    }\n\n    const promise = fetchSource(moduleURL).then(source => {\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * ${ importStatements };\n       * ((a, b) => {\n       *     (a[b] = a[b] || [ ]).push(\n       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n       *             ${ sourceWithoutImportStatements }\n       *         }\n       *     );\n       * })(window, '_AWGS');\n       * ```\n       */\n      // tslint:disable-next-line:max-line-length\n\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.\n\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n\n      if (evaluateAudioWorkletGlobalScope === undefined) {\n        throw new SyntaxError();\n      }\n\n      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {\n        if (name.trim() === '') {\n          throw createNotSupportedError();\n        }\n\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n        if (nodeNameToProcessorConstructorMap !== undefined) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError();\n          }\n\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, undefined, undefined));\n    }).catch(err => {\n      if (err.code === undefined || err.name === 'SyntaxError') {\n        err.code = 12;\n      }\n\n      throw err;\n    });\n\n    if (ongoingRequestsOfContext === undefined) {\n      ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n\n    promise.then(() => {\n      const rslvdRqstsFCntxt = resolvedRequests.get(context);\n\n      if (rslvdRqstsFCntxt === undefined) {\n        resolvedRequests.set(context, new Set([moduleURL]));\n      } else {\n        rslvdRqstsFCntxt.add(moduleURL);\n      }\n    }).catch(() => {}) // tslint:disable-line:no-empty\n    // @todo Use finally when it becomes available in all supported browsers.\n    .then(() => {\n      const ngngRqstsFCntxt = ongoingRequests.get(context);\n\n      if (ngngRqstsFCntxt !== undefined) {\n        ngngRqstsFCntxt.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};","export const isDelayNode = audioNode => {\n  return 'delayTime' in audioNode;\n};","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n  return function detectCycles(chain, nextLink) {\n    const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey(audioParamAudioNodeStore, nextLink);\n\n    if (isDelayNode(audioNode)) {\n      return [];\n    }\n\n    if (chain[0] === audioNode) {\n      return [chain];\n    }\n\n    if (chain.includes(audioNode)) {\n      return [];\n    }\n\n    const {\n      outputs\n    } = getAudioNodeConnections(audioNode);\n    return Array.from(outputs).map(outputConnection => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n  };\n};","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, detachedArrayBuffers, getNativeContext, isNativeContext, isNativeOfflineAudioContext, nativeOfflineAudioContextConstructor, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  return (anyContext, audioData) => {\n    const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext); // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n\n    if (detachedArrayBuffers.has(audioData)) {\n      const err = createDataCloneError();\n      return Promise.reject(err);\n    } // The audioData parameter maybe of a type which can't be added to a WeakSet.\n\n\n    try {\n      detachedArrayBuffers.add(audioData);\n    } catch {} // Ignore errors.\n    // Bug #21: Safari does not support promises yet.\n\n\n    if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n      // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n      const nativeContextOrBackupNativeContext = nativeContext.state === 'closed' && nativeOfflineAudioContextConstructor !== null && isNativeOfflineAudioContext(nativeContext) ? new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) : nativeContext;\n      const promise = nativeContextOrBackupNativeContext.decodeAudioData(audioData).catch(err => {\n        // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n        if (err instanceof DOMException && err.name === 'NotSupportedError') {\n          throw new TypeError();\n        }\n\n        throw err;\n      });\n      return promise.then(audioBuffer => {\n        // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n          wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n      });\n    } // Bug #21: Safari does not return a Promise yet.\n\n\n    return new Promise((resolve, reject) => {\n      const complete = () => {\n        // Bug #133: Safari does neuter the ArrayBuffer.\n        try {\n          detachArrayBuffer(audioData);\n        } catch {\n          /* Ignore errors. */\n        }\n      };\n\n      const fail = err => {\n        reject(err);\n        complete();\n      }; // Bug #26: Safari throws a synchronous error.\n\n\n      try {\n        // Bug #1: Safari requires a successCallback.\n        nativeContext.decodeAudioData(audioData, audioBuffer => {\n          // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n          // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n          if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n          }\n\n          audioBufferStore.add(audioBuffer);\n          complete();\n          resolve(audioBuffer);\n        }, err => {\n          // Bug #4: Safari returns null instead of an error.\n          if (err === null) {\n            fail(createEncodingError());\n          } else {\n            fail(err);\n          }\n        });\n      } catch (err) {\n        fail(err);\n      }\n    });\n  };\n};","export const detachArrayBuffer = arrayBuffer => {\n  const {\n    port1\n  } = new MessageChannel();\n  port1.postMessage(arrayBuffer, [arrayBuffer]);\n};","export const testClonabilityOfAudioWorkletNodeOptions = audioWorkletNodeOptions => {\n  const {\n    port1\n  } = new MessageChannel();\n\n  try {\n    // This will throw an error if the audioWorkletNodeOptions are not clonable.\n    port1.postMessage(audioWorkletNodeOptions);\n  } finally {\n    port1.close();\n  }\n};","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections) => {\n  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n    if (nativeAudioWorkletNodeConstructor !== null) {\n      try {\n        const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n          return new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n        });\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n\n        let onprocessorerror = null;\n        Object.defineProperties(nativeAudioWorkletNode, {\n          /*\n           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n           * browsers have no native implementation to achieve a consistent behavior.\n           */\n          channelCount: {\n            get: () => options.channelCount,\n            set: () => {\n              throw createInvalidStateError();\n            }\n          },\n          channelCountMode: {\n            get: () => 'explicit',\n            set: () => {\n              throw createInvalidStateError();\n            }\n          },\n          // Bug #156: Chrome & Opera do not yet fire an ErrorEvent.\n          onprocessorerror: {\n            get: () => onprocessorerror,\n            set: value => {\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n              }\n\n              onprocessorerror = typeof value === 'function' ? value : null;\n\n              if (typeof onprocessorerror === 'function') {\n                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n              }\n            }\n          }\n        });\n\n        nativeAudioWorkletNode.addEventListener = (addEventListener => {\n          return (...args) => {\n            if (args[0] === 'processorerror') {\n              const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n              if (unpatchedEventListener !== null) {\n                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                if (patchedEventListener !== undefined) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = event => {\n                    unpatchedEventListener(new ErrorEvent(args[0], { ...event,\n                      error: new Error()\n                    }));\n                  };\n\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n\n            return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        })(nativeAudioWorkletNode.addEventListener);\n\n        nativeAudioWorkletNode.removeEventListener = (removeEventListener => {\n          return (...args) => {\n            if (args[0] === 'processorerror') {\n              const patchedEventListener = patchedEventListeners.get(args[1]);\n\n              if (patchedEventListener !== undefined) {\n                patchedEventListeners.delete(args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n\n            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        })(nativeAudioWorkletNode.removeEventListener);\n        /*\n         * Bug #86: Chrome & Opera do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but has\n         * an output.\n         */\n\n\n        if (options.numberOfOutputs !== 0) {\n          const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n          });\n          nativeAudioWorkletNode.connect(nativeGainNode)\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n          .connect(nativeGainNode.context.destination);\n\n          const whenConnected = () => nativeGainNode.disconnect();\n          /*\n           * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is\n           * used here to make sure to connect the right destination.\n           */\n\n\n          const whenDisconnected = () => nativeGainNode.connect(nativeGainNode.context.destination); // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n\n\n          return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n        }\n\n        return nativeAudioWorkletNode;\n      } catch (err) {\n        // Bug #60: Chrome & Opera throw an InvalidStateError instead of a NotSupportedError.\n        if (err.code === 11) {\n          throw createNotSupportedError();\n        }\n\n        throw err;\n      }\n    } // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n\n    if (processorConstructor === undefined) {\n      throw createNotSupportedError();\n    }\n\n    testClonabilityOfAudioWorkletNodeOptions(options);\n    return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n  };\n};","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({\n        name\n      }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        error\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: options.outputChannelCount[i]\n          }));\n        }\n\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm), trace);\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n\n    };\n  };\n};","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n  const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n  const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n  return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = channelSplitterNode => {\n  const channelCount = channelSplitterNode.numberOfOutputs; // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n\n  Object.defineProperty(channelSplitterNode, 'channelCount', {\n    get: () => channelCount,\n    set: value => {\n      if (value !== channelCount) {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  /*\n   * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n   * explicit.\n   */\n\n  Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n    get: () => 'explicit',\n    set: value => {\n      if (value !== 'explicit') {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  /*\n   * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n   * discrete.\n   */\n\n  Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n    get: () => 'discrete',\n    set: value => {\n      if (value !== 'discrete') {\n        throw createInvalidStateError();\n      }\n    }\n  });\n};","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = createNativeAudioNode => {\n  return (nativeContext, options) => {\n    const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, ntvCntxt => {\n      return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n    }); // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Edge & Safari do not have the correct channelCountMode.\n    // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options); // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n    return nativeChannelSplitterNode;\n  };\n};","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = nativeIIRFilterNode => {\n  nativeIIRFilterNode.getFrequencyResponse = (getFrequencyResponse => {\n    return (frequencyHz, magResponse, phaseResponse) => {\n      if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n        throw createInvalidAccessError();\n      }\n\n      return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n    };\n  })(nativeIIRFilterNode.getFrequencyResponse);\n};","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext) => {\n  return class IIRFilterNode extends audioNodeConstructor {\n    constructor(context, options) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n      const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null;\n      super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer); // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n      // @todo Write a test which allows other browsers to remain unpatched.\n\n      wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n      this._nativeIIRFilterNode = nativeIIRFilterNode;\n    }\n\n    getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n      return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n    }\n\n  };\n};","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  }; // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    } // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  } // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\n\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    } // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n\n\n    context.delegate = null;\n    return ContinueSentinel;\n  } // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n\n\n  defineIteratorMethods(Gp);\n  Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse(); // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      } // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    } // Return an iterator with no values.\n\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      this.prev = 0;\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function () {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      } // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  }; // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n\n  return exports;\n}( // If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\ntypeof module === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","// const Tone = require(\"tone\");\n// import Synth from 'tone/Tone/instrument/Synth';\nimport * as Tone from \"tone\";\n\n\nconst synths = [\n    new Tone.PolySynth(Tone.Synth, {\n        \"oscillator\": {\n            \"type\": \"sawtooth\"\n        }\n    }),\n    new Tone.PolySynth(Tone.Synth, {\n        \"oscillator\": {\n            \"type\": \"sine\"\n        }\n    }),\n    new Tone.PolySynth(Tone.Synth, {\n        \"oscillator\": {\n            \"type\": \"triangle\"\n        }\n    }),\n    new Tone.PolySynth(Tone.Synth, {\n        \"oscillator\": {\n            \"type\": \"square\"\n        }\n    }),\n]\n\n// const synth = new Tone.PolySynth(Tone.Synth, {\n//     \"oscillator\": {\n//         \"type\": \"sawtooth\"\n//     }\n// });\n\nconst gain = new Tone.Gain(0.5);\ngain.toMaster();\n\nlet synth = synths[0];\n\nconst options = document.body.querySelectorAll('li');\n\nfor (let i = 0; i < options.length; i++) {\n    let option = options[i];\n    option.addEventListener('click', async () => {\n\n        synth = synths[option.value];\n        option.classList.add('active');\n        synth.connect(gain);\n    })\n}\n\nsynth.connect(gain);\n\n\n\n\nlet index = 0;\n\n\nconst check = document.body.querySelectorAll('input');\nconst play = document.body.querySelector('.play-btn');\nconst pause = document.body.querySelector('.pause-btn');\nconst rows = document.body.querySelectorAll('.note-container > div');\nconst tempo = document.body.querySelector('.tempo-control')\nconst clear = document.body.querySelector('.clear-btn');\nconst reset = document.body.querySelector('.rewind-btn');\nconst notes = ['C6', 'B5', 'A#5', 'A5', 'G#5', 'G5', 'F#5', 'F5', 'E5', 'D#5', 'D5', 'C#5', 'C5', 'B4', 'A#4', 'A4', 'G#4', 'G4', 'F#4', 'F4', 'E4', 'D#4', 'D4', 'C#4', 'C4']\n\nTone.Transport.scheduleRepeat(repeat, '4n');\nTone.Transport.bpm.value = 128;\n\nplay.addEventListener('click', async () => {\n    // debugger\n    Tone.start()\n    Tone.Transport.start()\n});\n\npause.addEventListener('click', async () => {\n    Tone.Transport.stop()\n});\n\ntempo.addEventListener('change', e => {\n    Tone.Transport.bpm.rampTo(e.target.value, 0.1);\n});\n\nreset.addEventListener('click', e => {\n    index = 0;\n    for (let i = 0; i < rows.length; i++) {\n        let row = rows[i];\n        let inputs = row.querySelectorAll('label div');\n        for (let j = 0; j < inputs.length; j++) {\n            inputs[j].style.boxShadow = '';\n        }\n    }\n})\n\nclear.addEventListener('click', e => {\n    for (let i = 0; i < check.length; i++) {\n        if (check[i].checked === true) {\n            check[i].checked = false\n        }\n\n        if (rows[i]) {\n            let row = rows[i];\n            let inputs = row.querySelectorAll('label div');\n            for (let j = 0; j < inputs.length; j++) {\n                inputs[j].style.boxShadow = '';\n            }\n        }\n\n    }\n})\n\nfunction repeat(time) {\n    let step = index % 16;\n    for (let i = 0; i < rows.length; i++) {\n        let note = notes[i];\n        let row = rows[i];\n\n        if (step !== 0) {\n            let prevInput = row.querySelector(`label:nth-child(${step})`);\n            let prevBox = prevInput.querySelector('div');\n\n            prevBox.style.boxShadow = '';\n        } else if (step === 0) {\n            let lastInput = row.querySelector(`label:last-child`);\n            let lastBox = lastInput.querySelector('div');\n\n            lastBox.style.boxShadow = '';\n        }\n\n\n        let input = row.querySelector(`label:nth-child(${step + 1})`);\n        let checkbox = input.querySelector('input');\n        let box = input.querySelector('div');\n\n        box.style.boxShadow = '0 0 0.7px #7fff08, 0 0 2.5px #7fff08, 0 0 6px #7fff08';\n\n        if (checkbox.checked) {\n            synth.triggerAttackRelease(note, '8n', time).volume.value = 3;\n        }\n    }\n    index++;\n\n};","const ToneNote = require(\"tone\");\nimport { Synth, Gain } from 'tone'\n// import ToneNote from \"Tone\";\n\nconst synthNote = new ToneNote.PolySynth({\n    \"oscillator\": {\n        \"type\": \"sine\"\n    },\n    \"envelope\": {\n        \"attack\": 0.1,\n        \"decay\": 0.15,\n        \"sustain\": 0.3,\n        \"release\": 10\n    }\n})\n\nconst gainNote = new ToneNote.Gain(0.5)\ngainNote.toMaster()\n\nsynthNote.connect(gainNote)\n\nconst rows = document.body.querySelectorAll('.note-container > div');\nconst buttons = document.body.querySelectorAll('#piano-roll div, #piano-roll div div');\n\nconst keys = ['C6', 'B5', 'A#5', 'A5', 'G#5', 'G5', 'F#5', 'F5', 'E5', 'D#5', 'D5', 'C#5', 'C5', 'B4', 'A#4', 'A4', 'G#4', 'G4', 'F#4', 'F4', 'E4', 'D#4', 'D4', 'C#4', 'C4']\n\n\nlet pianoKey;\nfor (let i = 0; i < keys.length; i++) {\n    let row = rows[i];\n    pianoKey = document.querySelector(`.note-${i + 1}`);\n\n    buttons[i].addEventListener('click', async function (e) {\n        e.stopPropagation();\n        pianoKey = document.querySelector(`.note-${i + 1}`);\n        row.classList.remove(`row${i + 1}-animation`);\n\n        void row.offsetWidth;\n        await ToneNote.start();\n        synthNote.triggerAttackRelease(keys[i], '8n').volume.value = 3;\n\n        row.classList.add(`row${i + 1}-animation`);\n    })\n}\n\nlet sequencerKey;\nfor (let i = 0; i < keys.length; i++) {\n    sequencerKey = document.querySelectorAll(`.checkbox-row${i + 1}`);\n    for (let j = 0; j < sequencerKey.length; j++) {\n        sequencerKey[j].addEventListener('click', async () => {\n            await ToneNote.start();\n            synthNote.triggerAttackRelease(keys[i], '8n').volume.value = 3;\n        })\n\n    }\n}\n"],"sourceRoot":""}